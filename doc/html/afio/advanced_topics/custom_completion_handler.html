<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>How to write your own custom AFIO completion handler</title>
<link rel="stylesheet" href="../../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="up" href="../advanced_topics.html" title="Advanced Topics">
<link rel="prev" href="../advanced_topics.html" title="Advanced Topics">
<link rel="next" href="../release_notes.html" title="Release Notes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../advanced_topics.html"><img src="../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../advanced_topics.html"><img src="../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../afio.html"><img src="../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../release_notes.html"><img src="../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="afio.advanced_topics.custom_completion_handler"></a><a class="link" href="custom_completion_handler.html" title="How to write your own custom AFIO completion handler">How to
      write your own custom AFIO completion handler</a>
</h3></div></div></div>
<p>
        If you want to extend Boost.AFIO with additional asynchronous functionality,
        you're probably going to have to implement your own custom AFIO completion
        handler which can be scheduled using <a class="link" href="../reference/classes/async_file_io_dispatcher_base/completion_2_batch_bound_functions.html" title="completion (batch bound functions)"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">completion</span><span class="special">()</span></code></a>.
        These are the second most lowest level, second most primitive completion
        handler AFIO has and while a non-trivial amount of programmer effort to utilise,
        they do offer a maximum amount of flexibility, functionality and of course,
        performance<sup>[<a name="afio.advanced_topics.custom_completion_handler.f0" href="#ftn.afio.advanced_topics.custom_completion_handler.f0" class="footnote">13</a>]</sup>. If you are NOT extending AFIO with extra functionality, you
        almost certainly want <a class="link" href="../reference/classes/async_file_io_dispatcher_base/call_2_batch_bound_functions.html" title="call (batch bound functions)"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">call</span><span class="special">()</span></code></a>
        instead.
      </p>
<p>
        Some advantages of custom completion handlers include:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Access to op id and any precondition op which was supplied at the point
            of scheduling.
          </li>
<li class="listitem">
            Ability to schedule immediate completions which are executed instantly
            after their precondition instead of later when the thread source gets
            round to them. This is particularly useful when your host OS has real
            async i/o support, because you can use immediate completions to schedule
            non-blocking async i/o operations as quickly as possible. Another use
            is taking advantage of Lx cache locality while the cache lines are still
            paged in.
          </li>
<li class="listitem">
            Direct control of exception handling and error propagation, where arbitrary
            ops can be completed at any time by any thread in any circumstance.
          </li>
<li class="listitem">
            Performance: completion handlers only have a single <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> invocation overhead, rather than
            more as would be the case with <code class="computeroutput"><span class="identifier">call</span><span class="special">()</span></code>. The reason why nesting <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>
            invocations is bad is because each entails type erasure, which requires
            the CPU to do an indirect jump (like a virtual function call) and while
            modern branch predictors eliminate any penalty for executing just one
            of those, they most certainly struggle when they have to execute a sequence
            of indirect jumps. For example, a single indirect jump might cost just
            two CPU cycles, while a mispredicted indirect jump might cost as much
            as 18-25 CPU cycles.
          </li>
</ul></div>
<p>
        Some disadvantages of custom completion handlers include:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Unlike <a class="link" href="../reference/classes/async_file_io_dispatcher_base/call_2_batch_bound_functions.html" title="call (batch bound functions)"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">call</span><span class="special">()</span></code></a>,
            there is no custom return type machinery i.e. you'll have to implement
            your own. This isn't hard &#8212; note how <a class="link" href="../reference/classes/async_file_io_dispatcher_base/enumerate_1_batch.html" title="enumerate (batch)"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">enumerate</span><span class="special">()</span></code></a>'s
            internal completion handler in afio.cpp takes a shared pointer as a parameter
            containing the promises of output for the enumerations, thus allowing
            <a class="link" href="../reference/classes/async_file_io_dispatcher_base/enumerate_1_batch.html" title="enumerate (batch)"><code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">enumerate</span><span class="special">()</span></code></a>
            to set up a batch of futures corresponding to those promises and return
            those to the user.
          </li>
<li class="listitem">
            Exception handling is rather more manual. That comes of course with flexibility
            as well as hassle.
          </li>
</ul></div>
<p>
        So, let's have a look at an example of a custom AFIO completion handler,
        this being pretty much the simplest formulation possible:
      </p>
<pre class="programlisting"><span class="comment">// Create a dispatcher instance</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">&gt;</span> <span class="identifier">dispatcher</span><span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">make_async_file_io_dispatcher</span><span class="special">();</span>

<span class="comment">// Completion handlers are the lowest level completion routine available, and therefore the least</span>
<span class="comment">// overhead but at the cost of considerable extra programmer effort. You almost certainly want</span>
<span class="comment">// to use the call() member function instead.</span>

<span class="comment">// First create some callable entity ...</span>
<span class="keyword">auto</span> <span class="identifier">completer</span><span class="special">=[](</span>
    <span class="comment">/* These are always the standard parameters */</span>
    <span class="identifier">size_t</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span> <span class="identifier">precondition</span><span class="special">,</span>
    <span class="comment">/* From now on user defined parameters */</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">text</span><span class="special">)</span>
  <span class="comment">/* This is always the return type */</span>
  <span class="special">-&gt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_handle</span><span class="special">&gt;&gt;</span>
<span class="special">{</span>
    <span class="comment">/* id is the unique, non-zero integer id of this op.
       precondition is the op you supplied as precondition. As it will by definition
       have completed by now, you can fetch from its h member variable a shared pointer
       to the shared future containing either the output async_io_handle or the error state.
    */</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">text</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Return whether this completion has completed now or is it deferred,</span>
    <span class="comment">// along with the handle we pass onto any completions completing on this op</span>
    <span class="comment">// Note that op.get() by default rethrows any exception contained by the op.</span>
    <span class="comment">// Normally this is highly desirable.</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="keyword">true</span><span class="special">,</span> <span class="identifier">precondition</span><span class="special">.</span><span class="identifier">get</span><span class="special">());</span>
<span class="special">};</span>

<span class="comment">// Bind any user defined parameters to create a proper boost::afio::async_file_io_dispatcher_base::completion_t</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">completion_t</span><span class="special">&gt;</span> <span class="identifier">boundf</span><span class="special">=</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">completer</span><span class="special">,</span>
        <span class="comment">/* The standard parameters */</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">::</span><span class="identifier">_2</span><span class="special">,</span>
        <span class="comment">/* Any values for the user defined parameters. Remember ALWAYS to pass by value! */</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="string">"Hello world"</span><span class="special">));</span>

<span class="comment">// Schedule an asynchronous call of the completion with some bound set of arguments</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span> <span class="identifier">helloworld</span><span class="special">=</span>
    <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">completion</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span><span class="special">()</span> <span class="comment">/* no precondition */</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_op_flags</span><span class="special">::</span><span class="identifier">none</span><span class="special">,</span> <span class="identifier">boundf</span><span class="special">));</span>

<span class="comment">// Create a boost::future&lt;&gt; representing the ops passed to when_all()</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_handle</span><span class="special">&gt;&gt;&gt;</span> <span class="identifier">future</span>
    <span class="special">=</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">when_all</span><span class="special">(</span><span class="identifier">helloworld</span><span class="special">);</span>
<span class="comment">// ... and wait for it to complete</span>
<span class="identifier">future</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span>
</pre>
<p>
        Note how you have fair amount of flexibility of defining any input parameters
        you like so long as the standard duo of id and precondition are there. This
        is enabled basically through <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">&lt;&gt;</span></code> to prebind any custom parameters
        you may have to produce a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> instance with the aforementioned
        standard duo of parameters. As AFIO's completion implementation natively
        works with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code>,
        you effectively get custom parameter binds for free anyway.
      </p>
<p>
        The above shows a simple custom completion handler &#8212; as mentioned
        earlier, one can also do immediate completions, and this is an example of
        just that:
      </p>
<pre class="programlisting"><span class="comment">// Create a dispatcher instance</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">&gt;</span> <span class="identifier">dispatcher</span><span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">make_async_file_io_dispatcher</span><span class="special">();</span>

<span class="comment">// One thing direct programming of completion handlers can do which call() cannot is immediate</span>
<span class="comment">// completions. These run immediately after the precondition finishes by the thread worker</span>
<span class="comment">// which executed the precondition rather than being appended to the FIFO queue. This can</span>
<span class="comment">// be useful for ensuring data is still cache-local for example.</span>

<span class="comment">// Create the completion, using the standard form</span>
<span class="keyword">auto</span> <span class="identifier">completion</span><span class="special">=[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">&gt;</span> <span class="identifier">dispatcher</span><span class="special">,</span>
    <span class="comment">/* These are always the standard parameters */</span>
    <span class="identifier">size_t</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span> <span class="identifier">precondition</span><span class="special">)</span>
  <span class="comment">/* This is always the return type */</span>
  <span class="special">-&gt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_handle</span><span class="special">&gt;&gt;</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"I am completion"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

    <span class="comment">// Create some callable entity which will do the actual completion. It can be</span>
    <span class="comment">// anything you like, but you need a minimum of its integer id.</span>
    <span class="keyword">auto</span> <span class="identifier">completer</span><span class="special">=[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">&gt;</span> <span class="identifier">dispatcher</span><span class="special">,</span>
                      <span class="identifier">size_t</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span> <span class="identifier">op</span><span class="special">)</span> <span class="special">-&gt;</span> <span class="keyword">int</span>
    <span class="special">{</span>
        <span class="keyword">try</span>
        <span class="special">{</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"I am completer"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

            <span class="comment">// Do stuff, returning the handle you want passed onto dependencies.</span>
            <span class="comment">// Note that op.get() rethrows any exception in op. Normally you want this.</span>
            <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">complete_async_op</span><span class="special">(</span><span class="identifier">id</span><span class="special">,</span> <span class="identifier">op</span><span class="special">.</span><span class="identifier">get</span><span class="special">());</span>
        <span class="special">}</span>
        <span class="keyword">catch</span><span class="special">(...)</span>
        <span class="special">{</span>
            <span class="comment">// In non-deferred completions AFIO traps exceptions for you. Here, you must</span>
            <span class="comment">// do it by hand and tell AFIO about what exception state to return.</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">exception_ptr</span> <span class="identifier">e</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">current_exception</span><span class="special">());</span>
            <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">complete_async_op</span><span class="special">(</span><span class="identifier">id</span><span class="special">,</span> <span class="identifier">e</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">};</span>
    <span class="comment">// Bind the id and handle to completer, and enqueue for later asynchronous execution.</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">async</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span><span class="special">,</span> <span class="identifier">completer</span><span class="special">,</span> <span class="identifier">dispatcher</span><span class="special">,</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">precondition</span><span class="special">);</span>

    <span class="comment">// Indicate we are not done yet</span>
    <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span><span class="keyword">false</span><span class="special">,</span> <span class="identifier">precondition</span><span class="special">.</span><span class="identifier">get</span><span class="special">());</span>
<span class="special">};</span>

<span class="comment">// Bind any user defined parameters to create a proper boost::afio::async_file_io_dispatcher_base::completion_t</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">completion_t</span><span class="special">&gt;</span> <span class="identifier">boundf</span><span class="special">=</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">completion</span><span class="special">,</span> <span class="identifier">dispatcher</span><span class="special">,</span>
        <span class="comment">/* The standard parameters */</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">::</span><span class="identifier">_1</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">placeholders</span><span class="special">::</span><span class="identifier">_2</span><span class="special">);</span>

<span class="comment">// Schedule an asynchronous call of the completion</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span> <span class="identifier">op</span><span class="special">=</span>
    <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">completion</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span><span class="special">()</span> <span class="comment">/* no precondition */</span><span class="special">,</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span>
            <span class="comment">/* Complete boundf immediately after its precondition (in this
            case as there is no precondition that means right now before
            completion() returns) */</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_op_flags</span><span class="special">::</span><span class="identifier">immediate</span><span class="special">,</span>
            <span class="identifier">boundf</span><span class="special">));</span>

<span class="comment">// Create a boost::future&lt;&gt; representing the ops passed to when_all()</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_handle</span><span class="special">&gt;&gt;&gt;</span> <span class="identifier">future</span>
    <span class="special">=</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">when_all</span><span class="special">(</span><span class="identifier">op</span><span class="special">);</span>
<span class="comment">// ... and wait for it to complete</span>
<span class="identifier">future</span><span class="special">.</span><span class="identifier">wait</span><span class="special">();</span>
</pre>
<p>
        Note the new function for completing a deferred completion: <code class="computeroutput"><span class="identifier">complete_async_op</span><span class="special">()</span></code>,
        which can take a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception_ptr</span></code> if you want AFIO to return
        an errored state.
      </p>
<p>
        As of AFIO v1.2 all of the constraints which were imposed on immediate completions
        are eliminated, and deferred completions were completely eliminated as now
        all completions are always deferred. Therefore, as of v1.2, you can do anything
        you can do in a normally scheduled op in an immediately scheduled op. Nevertheless,
        you should be aware of the following when using any kind of completion handler:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            As far as AFIO is concerned, the precondition is completed and all knowledge
            of it deleted from AFIO's records by the time you see it in a completion
            handler (it is deleted as soon as possible to save on RAM footprint).
          </li>
<li class="listitem">
            Therefore adding completions to the precondition of the completion being
            executed simply schedules them immediately (or executes them immediately
            if they are immediate) which may not be what you intended.
          </li>
<li class="listitem">
            If you want to read in the handle output by the precondition for your
            own use, be aware that using the <code class="computeroutput"><span class="identifier">async_io_op</span><span class="special">::</span><span class="identifier">get</span><span class="special">()</span></code> function will by default rethrow any
            exception stored into the precondition op. This has a useful side effect
            if you always do the following at the top of your completion handler
            implementation:
            <p>
              <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">async_io_handle</span><span class="special">&gt;</span>
              <span class="identifier">h</span><span class="special">(</span><span class="identifier">op</span><span class="special">.</span><span class="identifier">get</span><span class="special">());</span></code>
            </p>
            <p>
              ... by immediately rethrowing any precondition exception before you
              execute any more code. You'll see this pattern very, very frequently
              throughout AFIO's source code and you are encouraged to do the same.
              If you really don't want to propage exceptions immediately then do:
            </p>
            <p>
              <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">async_io_handle</span><span class="special">&gt;</span>
              <span class="identifier">h</span><span class="special">(</span><span class="identifier">op</span><span class="special">.</span><span class="identifier">get</span><span class="special">(</span><span class="keyword">true</span><span class="special">));</span> <span class="comment">// Ignore any error state until later</span></code>
            </p>
            <p>
              This will place a default constructed (i.e. empty) shared pointer into
              h if there is an errored state, otherwise the correct handle. If you
              need to determine whether the precondition is a null handle or an errored
              state, you can always use <code class="computeroutput"><span class="identifier">get_exception_ptr</span><span class="special">()</span></code> on the shared future referred to
              by the h member variable of the precondition op.
            </p>
          </li>
</ul></div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a id="ftn.afio.advanced_topics.custom_completion_handler.f0" href="#afio.advanced_topics.custom_completion_handler.f0" class="para">13</a>] </sup>
          If you're willing to go even <span class="emphasis"><em>more</em></span> low level, AFIO's
          <code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span></code>
          class exposes as protected member functions the variadic templated function
          <code class="computeroutput"><span class="identifier">chain_async_op</span><span class="special">()</span></code>
          and a suite of specialised <code class="computeroutput"><span class="identifier">chain_async_ops</span><span class="special">()</span></code> helper overloads. Therefore if you subclass
          <code class="computeroutput"><span class="identifier">async_file_io_dispatcher_base</span></code>,
          you can enjoy the overhead of just one <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;&gt;</span></code> call.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../advanced_topics.html"><img src="../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../advanced_topics.html"><img src="../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../afio.html"><img src="../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../release_notes.html"><img src="../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
