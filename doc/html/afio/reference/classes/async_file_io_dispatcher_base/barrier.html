<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>barrier (batch)</title>
<link rel="stylesheet" href="../../../../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="up" href="../async_file_io_dispatcher_base.html" title="async_file_io_dispatcher_base">
<link rel="prev" href="truncate_2_single.html" title="truncate (single)">
<link rel="next" href="enumerate_1_batch.html" title="enumerate (batch)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="truncate_2_single.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../async_file_io_dispatcher_base.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../afio.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="enumerate_1_batch.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier"></a><a class="link" href="barrier.html" title="barrier (batch)">barrier
          (batch)</a>
</h5></div></div></div>
<p>
            <a class="indexterm" name="idp17373720"></a>
Schedule an asynchronous synchronisation of preceding operations.
          </p>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h0"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.description"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.description">Description</a>
          </h6>
<p>
            If you perform many asynchronous operations of unequal duration but wish
            to schedule one of more operations to occur only after <span class="bold"><strong>all</strong></span>
            of those operations have completed, this is the correct function to use.
            The returned batch of ops exactly match the input batch of ops (including
            their exception states), but they will only complete when the last of
            the input batch of ops completes.
          </p>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h1"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.synopsis"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.synopsis">Synopsis</a>
          </h6>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">async_io_op</span><span class="special">&gt;</span> <span class="identifier">async_file_io_dispatcher_base</span><span class="special">::</span><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span> <span class="identifier">async_io_op</span> <span class="special">&gt;</span> <span class="special">&amp;</span> <span class="identifier">ops</span><span class="special">)</span></pre>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h2"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.parameters"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.parameters">Parameters</a>
          </h6>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Type
                    </p>
                  </th>
<th>
                    <p>
                      Concept
                    </p>
                  </th>
<th>
                    <p>
                      Name
                    </p>
                  </th>
<th>
                    <p>
                      Description
                    </p>
                  </th>
</tr></thead>
<tbody><tr>
<td>
                    <p>
                      const std::vector&lt; async_io_op &gt; &amp;
                    </p>
                  </td>
<td>
                  </td>
<td>
                    <p>
                      ops
                    </p>
                  </td>
<td>
                    <p>
                      A batch of op handles.
                    </p>
                  </td>
</tr></tbody>
</table></div>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h3"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.returns"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.returns">Returns</a>
          </h6>
<p>
            A batch of op handles.
          </p>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h4"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.header"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.header">Header</a>
          </h6>
<p>
            <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">afio</span><span class="special">/</span><span class="identifier">afio</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
          </p>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h5"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.complexity"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.complexity">Complexity</a>
          </h6>
<p>
            Amortised O(N) to dispatch. Amortised O(N) to complete.
          </p>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h6"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.exception_model"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.exception_model">Exception
            Model</a>
          </h6>
<p>
            See detailed description above.
          </p>
<h6>
<a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.h7"></a>
            <span><a name="afio.reference.classes.async_file_io_dispatcher_base.barrier.example"></a></span><a class="link" href="barrier.html#afio.reference.classes.async_file_io_dispatcher_base.barrier.example">Example</a>
          </h6>
<pre class="programlisting"><span class="comment">// Assume that groups is 10,000 items long with item.first being randomly</span>
<span class="comment">// between 1 and 500. This example is adapted from the barrier() unit test.</span>
<span class="comment">//</span>
<span class="comment">// What we're going to do is this: for each item in groups, schedule item.first</span>
<span class="comment">// parallel ops and a barrier which completes only when the last of that</span>
<span class="comment">// parallel group completes. Chain the next group to only execute after the</span>
<span class="comment">// preceding group's barrier completes. Repeat until all groups have been executed.</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_file_io_dispatcher_base</span><span class="special">&gt;</span> <span class="identifier">dispatcher</span><span class="special">=</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">make_async_file_io_dispatcher</span><span class="special">();</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">size_t</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;&gt;</span> <span class="identifier">groups</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">atomic</span><span class="special">&lt;</span><span class="identifier">size_t</span><span class="special">&gt;</span> <span class="identifier">callcount</span><span class="special">[</span><span class="number">10000</span><span class="special">];</span>
<span class="identifier">memset</span><span class="special">(&amp;</span><span class="identifier">callcount</span><span class="special">,</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">callcount</span><span class="special">));</span>

<span class="comment">// This lambda is what each parallel op in each group will do: increment an atomic</span>
<span class="comment">// for that group.</span>
<span class="keyword">auto</span> <span class="identifier">inccount</span> <span class="special">=</span> <span class="special">[](</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">atomic</span><span class="special">&lt;</span><span class="identifier">size_t</span><span class="special">&gt;</span> <span class="special">*</span><span class="identifier">count</span><span class="special">){</span> <span class="special">(*</span><span class="identifier">count</span><span class="special">)++;</span> <span class="special">};</span>

<span class="comment">// This lambda is called after each barrier completes, and it checks that exactly</span>
<span class="comment">// the right number of inccount lambdas were executed.</span>
<span class="keyword">auto</span> <span class="identifier">verifybarrier</span> <span class="special">=</span> <span class="special">[](</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">atomic</span><span class="special">&lt;</span><span class="identifier">size_t</span><span class="special">&gt;</span> <span class="special">*</span><span class="identifier">count</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">shouldbe</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">if</span> <span class="special">(*</span><span class="identifier">count</span> <span class="special">!=</span> <span class="identifier">shouldbe</span><span class="special">)</span>
        <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"Count was not what it should have been!"</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// For each group, dispatch ops and a barrier for them</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span> <span class="identifier">next</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">isfirst</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
<span class="keyword">for</span><span class="special">(</span><span class="keyword">auto</span> <span class="special">&amp;</span><span class="identifier">run</span> <span class="special">:</span> <span class="identifier">groups</span><span class="special">)</span>
<span class="special">{</span>
    <span class="comment">// Create a vector of run.first size of bound inccount lambdas</span>
    <span class="comment">// This will be the batch issued for this group</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">()&gt;&gt;</span> <span class="identifier">thisgroupcalls</span><span class="special">(</span><span class="identifier">run</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">inccount</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">callcount</span><span class="special">[</span><span class="identifier">run</span><span class="special">.</span><span class="identifier">second</span><span class="special">]));</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span><span class="special">&gt;</span> <span class="identifier">thisgroupcallops</span><span class="special">;</span>
    <span class="comment">// If this is the first item, schedule without precondition</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">isfirst</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">thisgroupcallops</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">call</span><span class="special">(</span><span class="identifier">thisgroupcalls</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
        <span class="identifier">isfirst</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">else</span>
    <span class="special">{</span>
        <span class="comment">// Create a vector of run.first size of preconditions exactly</span>
        <span class="comment">// matching the number in this batch. Note that the precondition</span>
        <span class="comment">// for all of these is the preceding verify op</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">afio</span><span class="special">::</span><span class="identifier">async_io_op</span><span class="special">&gt;</span> <span class="identifier">dependency</span><span class="special">(</span><span class="identifier">run</span><span class="special">.</span><span class="identifier">first</span><span class="special">,</span> <span class="identifier">next</span><span class="special">);</span>
        <span class="identifier">thisgroupcallops</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">call</span><span class="special">(</span><span class="identifier">dependency</span><span class="special">,</span> <span class="identifier">thisgroupcalls</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="comment">// barrier() is very easy: its number of output ops exactly matches its input</span>
    <span class="comment">// but none of the output will complete until the last of the input completes</span>
    <span class="keyword">auto</span> <span class="identifier">thisgroupbarriered</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">barrier</span><span class="special">(</span><span class="identifier">thisgroupcallops</span><span class="special">);</span>
    <span class="comment">// Schedule a call of the verify lambda once barrier completes. Here we choose</span>
    <span class="comment">// the first item of the barrier's return, but in truth any of them are good.</span>
    <span class="keyword">auto</span> <span class="identifier">verify</span> <span class="special">=</span> <span class="identifier">dispatcher</span><span class="special">-&gt;</span><span class="identifier">call</span><span class="special">(</span><span class="identifier">thisgroupbarriered</span><span class="special">.</span><span class="identifier">front</span><span class="special">(),</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">()&gt;(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">verifybarrier</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">callcount</span><span class="special">[</span><span class="identifier">run</span><span class="special">.</span><span class="identifier">second</span><span class="special">],</span> <span class="identifier">run</span><span class="special">.</span><span class="identifier">first</span><span class="special">)));</span>
    <span class="comment">// Set the dependency for the next batch to be the just scheduled verify op</span>
    <span class="identifier">next</span> <span class="special">=</span> <span class="identifier">verify</span><span class="special">.</span><span class="identifier">second</span><span class="special">;</span>
<span class="special">}</span>
<span class="comment">// next was the last op scheduled, so waiting on it waits on everything</span>
<span class="identifier">when_all</span><span class="special">(</span><span class="identifier">next</span><span class="special">).</span><span class="identifier">wait</span><span class="special">();</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="truncate_2_single.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../async_file_io_dispatcher_base.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../afio.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="enumerate_1_batch.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
