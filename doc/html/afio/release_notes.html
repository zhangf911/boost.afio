<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Release Notes</title>
<link rel="stylesheet" href="../../../libs/afio/doc/html/myboostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="up" href="../afio.html" title="Chapter&#160;1.&#160;Boost.AFIO 1.30">
<link rel="prev" href="advanced_topics/custom_completion_handler.html" title="How to write your own custom AFIO completion handler">
<link rel="next" href="FAQ.html" title="Frequently Asked Questions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="advanced_topics/custom_completion_handler.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../afio.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../afio.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="FAQ.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="afio.release_notes"></a><a class="link" href="release_notes.html" title="Release Notes">Release Notes</a>
</h2></div></div></div>
<h4>
<a name="afio.release_notes.h0"></a>
      <span><a name="afio.release_notes.anticipated_forthcoming_features"></a></span><a class="link" href="release_notes.html#afio.release_notes.anticipated_forthcoming_features">Anticipated
      forthcoming features in future versions</a>
    </h4>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          The v1.4 engine will be rewritten yet again to use a new custom future
          implementation whereby async_io_op shall become afio::future&lt;T&gt;.
          This should let the API no longer return two sets of futures when returning
          results (async_io_op therefore matches afio::future&lt;void&gt;), plus
          make best use of the proposed concurrent_unordered_map by finally actually
          processing batches of operations as a batch, instead of one at a time.
        </li>
<li class="listitem">
          The v1.4 engine afio::future&lt;T&gt; ought to transparently support Boost.Fiber,
          this should let you program against AFIO using awaitable resumable functions
          which is much cleaner. A big hope is that the stochastic variance in op
          processing latency should be heavily reduced (currently a 300k cycle average,
          min 10k cycles).
        </li>
<li class="listitem">
          The v1.4 engine will finally make use of the API support for alternative
          async_io_dispatcher implementations, adding at least one for temp file
          support with special temp file semantics, and maybe others with transparent
          hashing and bit flip healing (see below).
        </li>
<li class="listitem">
          Finally, making good use of the new coroutine support the v1.4 engine should
          have an async fast batch hash engine which provides transparent hashing
          of all async reads and writes. Chances are good one can also choose to
          generate SECDED Error Correcting Codes as I have a test implementation
          here which can process ~500Mb/sec for an enormous (32784, 32768) Hamming
          code which lets you heal one bit flip per 4Kb page, ideal for working with
          very long lived storage.
        </li>
</ul></div>
<h6>
<a name="afio.release_notes.h1"></a>
      <span><a name="afio.release_notes.in_some_later_version_in_order"></a></span><a class="link" href="release_notes.html#afio.release_notes.in_some_later_version_in_order">In
      some later version, in order:</a>
    </h6>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Individual file change monitoring. This would be very useful for implementing
          distributed mutual exclusion algorithms to avoid spinning on file updates.
        </li>
<li class="listitem">
          Portable fast file locking which works across network shares, but can still
          utilise shared memory when possible.
        </li>
<li class="listitem">
          Extended attributes support. TripleGit could use this to avoid a second
          file handle open of metadata per graph object read. Unsure if NTFS is any
          faster opening EA though, need to test.
        </li>
<li class="listitem">
          async_io_dispatcher_base::read_partial() to read as much of a single buffer
          as possible, rather than only complete buffers.
        </li>
<li class="listitem">
          Fast, scalable portable directory contents change monitoring. It should
          be able to monitor a 1M entry directory experiencing 1% entry changes per
          second without using a shocking amount of RAM.
        </li>
<li class="listitem">
          ACL support
        </li>
<li class="listitem">
          Asynchronous file handle closing in ~async_io_handle() (currently if not
          explicitly closed, the async_io_handle destructor must synchronously close)
        </li>
</ul></div>
<h4>
<a name="afio.release_notes.h2"></a>
      <span><a name="afio.release_notes.boost_1_57_afio_v1_3x_unstable_b"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_57_afio_v1_3x_unstable_b">Boost
      1.57 AFIO v1.3x unstable branch</a>
    </h4>
<p>
      AFIO is now a Boost.BindLib based library. This has resulted in an enormous
      change set which is only barely summarised here:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          AFIO is now capable of:
          <div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                Being used standalone, or as a Boost module, or if you have inline
                namespace support in your compiler then both simultaneously in the
                same translation unit or in the same binary, including any combination
                of the following library dependency configurations (config macro
                and its default is shown):
              </li>
<li class="listitem">
                Using Boost.Atomic, Boost.Chrono and Boost.Thread OR the C++ 11 STL
                (BOOST_AFIO_USE_BOOST_THREAD=0).
              </li>
<li class="listitem">
                Using Boost.Filesystem OR the C++ 1z Filesystem TS (BOOST_AFIO_USE_BOOST_FILESYSTEM=1,
                except on VS2015 which provides Filesystem).
              </li>
<li class="listitem">
                Using Boost.ASIO OR standalone ASIO (ASIO_STANDALONE=0)
              </li>
</ul></div>
          <p>
            That makes eight different potential configurations, and all eight can
            coexist in the same translation unit, though you will find compilation
            time becomes enormous.
          </p>
        </li>
<li class="listitem">
          AFIO's unit test suite no longer requires Boost.Test, and can now alternatively
          use CATCH C++ (BOOST_AFIO_USE_BOOST_UNIT_TEST=0) via BindLib.
        </li>
<li class="listitem">
          Dropped support for these compiler versions due to insufficient C++ 11
          support:
          <div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                Anything before GCC 4.7, as these lack template alias support.
              </li>
<li class="listitem">
                Anything before VS2013, as these lack template alias support. I took
                the opportunity to clean out the VS2010 special code paths and all
                the variadic template emulation.
              </li>
</ul></div>
        </li>
<li class="listitem">
          symlink() now can create file symbolic links on Windows (it'll probably
          error out due to lack of privileges held by the user, but it can now at
          least try).
        </li>
<li class="listitem">
          Added sparse file support. AFIO now always creates sparse file where possible,
          and converts any files it opens for writing into a sparse file where possible.
          You can disable that behaviour using the NoSparse flag.
        </li>
<li class="listitem">
          stat_t now contains member flags indicating if a file entry is sparse and/or
          compressed.
        </li>
<li class="listitem">
          Added a new api zero() which can very efficiently zero ranges in a file
          by deallocating them on physical storage (<span class="quote">&#8220;<span class="quote">hole punching</span>&#8221;</span>).
        </li>
<li class="listitem">
          Added a new api extents() which lets you query which ranges in a file contain
          valid data.
        </li>
<li class="listitem">
          Added a new api statfs() which returns a statfs_t which lets you query
          the volume on which a file or directory lives. Again, thanks to using the
          NT kernel API directly the structure on Windows is almost as complete as
          on POSIX.
        </li>
<li class="listitem">
          Improved unit testing, especially unit testing of error handling, and indeed
          found that on Windows an invalid handle object generated by a failed open
          or an explicit close caused the next dependant operation to segfault. Also
          on Windows any errors generated during read() and write() were being lost
          and the dispatcher hanged instead of being reported (oops!).
        </li>
<li class="listitem">
          Added an extra section to the tutorial on how to implement an atomic log
          file using the new features in AFIO.
        </li>
<li class="listitem">
          Completely rewrote the async_data_op_req metaprogramming which assembles
          ASIO scatter gather buffers from types and containers supplied to read()
          and write(). The old system which had to work on VS2010 was basically a
          set of repetitive hardcoded template specialisation overloads for void
          *, T *, std::array, std::vector and std::basic_string. The new much more
          sophisticated metaprogramming (with an unfortunate corresponding increase
          in compilation times) now understands any STL like container (detected
          using SFINAE std::begin() and std::end()), including nested STL like containers,
          and will correctly generate ASIO scatter gather buffers from say something
          like a std::list&lt;std::list&lt;std::string&gt;&gt; but also correctly
          coalesce buffers for trivial types such as std::vector&lt;std::array&lt;trivial
          type, N&gt;&gt; where it spots that only one ASIO scatter gather buffer
          is needed. Const types were supported before in that only an asio::const_buffer
          could be constructed from the limited list of supported input types, but
          now the metaprogramming asks STL like containers if their values are const
          (e.g. unordered_set), and if so it will always generate an asio::const_buffer,
          which of course means that such STL like containers can only be used for
          writing only and not reading.
        </li>
</ul></div>
<h4>
<a name="afio.release_notes.h3"></a>
      <span><a name="afio.release_notes.boost_1_57_afio_v1_22_stable_bra"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_57_afio_v1_22_stable_bra">Boost
      1.57 AFIO v1.22 stable branch</a>
    </h4>
<p>
      Fixed buffer underflow when decoding Win32 error codes to strings. Thanks to
      ariccio for reporting this.
    </p>
<p>
      Relocated docs from ci.nedprod.com to http://boostgsoc13.github.io/boost.afio/
    </p>
<p>
      Updated the stale CI test dashboard copy in the DocBook edition.
    </p>
<h4>
<a name="afio.release_notes.h4"></a>
      <span><a name="afio.release_notes.boost_1_56_afio_v1_21_10th_aug_2"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_56_afio_v1_21_10th_aug_2">Boost
      1.56 AFIO v1.21 10th Aug 2014</a>
    </h4>
<p>
      Finished getting a ThreadSanitizer (tsan) + UndefinedBehaviorSanitizer (ubsan)
      pass running per-commit on Travis CI (&gt;= v1.2 was tsan clean, I just hadn't
      bothered getting a CI to verify it to be so per commit).
    </p>
<p>
      Fixed bug where --lto wasn't turning on the optimiser for LTO output. Sorry.
    </p>
<p>
      Added a benchmark testing for latency under concurrency loads.
    </p>
<p>
      Added a new FAQ entry on AFIO execution latencies.
    </p>
<p>
      Reorganised source code structure to fit modular Boost. AFIO is now a Boost
      v1.56 module just like any other. Obviously this will break source code compatibility
      with all preceding Boosts.
    </p>
<h4>
<a name="afio.release_notes.h5"></a>
      <span><a name="afio.release_notes.boost_1_55_afio_v1_21_23rd_mar_2"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_55_afio_v1_21_23rd_mar_2">Boost
      1.55 AFIO v1.21 23rd Mar 2014</a>
    </h4>
<p>
      Fixed a bug in the custom unit testing framework which was throwing away any
      exceptions being thrown by the tests (thanks to Paul Kirth for finding this
      and reporting it). Fixing this bug revealed that enumerate() with a glob on
      Windows has never worked properly and the exception thrown by MSVC's checked
      iterators was hiding the problem, so fixed that bug too.
    </p>
<p>
      Added async_io_dispatcher_base::post_op_filter() and async_io_dispatcher_base::post_readwrite_filter(),
      including documentation examples and integrating filters into the unit testing.
      post_readwrite_filter() ought to be particularly useful to those seeking deep
      ASIO integration. Thanks to Bjorn Reese for the long discussions leading up
      to this choice of improved ASIO support.
    </p>
<p>
      During updating the benchmarks below now I have regained access to my developer
      workstation, discovered a severe performance regression in the v1.2 engine
      of around 27% over the v1.1 engine. Steps taken:
    </p>
<p>
      1. The shared state in every async_io_op was a shared_ptr, now it is the underlying
      shared_future. Eliminated copies of shared_ptr, now we always use the shared_future
      in enqueued_task directly. This reduced regression to 18%.
    </p>
<p>
      2. Removed more code from inside the TSX locks. This reduced regression to
      16%.
    </p>
<p>
      3. Removed the second TSX lock from complete_async_op(). This eliminated the
      regression and actually added 2% to the v1.1 engine.
    </p>
<p>
      4. Removed the second TSX lock from chain_async_op(). This added a further
      10% over the v1.1 engine, so we are now 12% faster which is about right given
      the v1.2 engine removed 15% of code.
    </p>
<p>
      Added nested TSX transaction support.
    </p>
<p>
      The CI shows that clang 3.1 now produces segfaulting binaries with this release,
      so rather than debug clang, I simply dropped clang 3.1 support. AFIO now requires
      clang 3.2 or better.
    </p>
<h4>
<a name="afio.release_notes.h6"></a>
      <span><a name="afio.release_notes.boost_1_55_afio_v1_20_5th_feb_20"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_55_afio_v1_20_5th_feb_20">Boost
      1.55 AFIO v1.20 5th Feb 2014</a>
    </h4>
<p>
      This is a major refactor of AFIO's core op dispatch engine to trim it down
      by about 15%. Key breaking differences from the v1.1 series of AFIO are as
      follows:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
          Replaced all use of packaged_task with enqueued_task, a custom implementation
          which makes possible many performance improvements throughout the engine.
        </li>
<li class="listitem">
          thread_source::enqueue() now can take a preprepared enqueued_task.
        </li>
<li class="listitem">
          thread_source::enqueue() now always returns a shared_future instead of
          a future. This has had knock on effects throughout AFIO, so many futures
          are now shared_future.
        </li>
<li class="listitem">
          Completion handler spec has changed from:
<pre class="programlisting"><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">async_io_handle</span><span class="special">&gt;&gt;</span> <span class="special">(*)(</span><span class="identifier">size_t</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">async_io_handle</span><span class="special">&gt;</span> <span class="identifier">h</span><span class="special">,</span> <span class="identifier">exception_ptr</span> <span class="special">*</span><span class="identifier">e</span><span class="special">)</span>
</pre>
          <p>
            to:
          </p>
<pre class="programlisting"><span class="identifier">pair</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">shared_ptr</span><span class="special">&lt;</span><span class="identifier">async_io_handle</span><span class="special">&gt;&gt;</span> <span class="special">(*)(</span><span class="identifier">size_t</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">async_io_op</span> <span class="identifier">preceding</span><span class="special">)</span>
</pre>
          <p>
            This substantially improves performance, simplifies the implementation,
            and lets completion handlers more readily retrieve the error state of
            preceding operations and react appropriately.
          </p>
        </li>
<li class="listitem">
          All restrictions on immediate completions have been removed. You can now
          do anything in an immediate completion that you can do in a normal completion.
        </li>
<li class="listitem">
          async_io_op::h now always refers to a correct future i.e. the future is
          no longer lazily allocated.
        </li>
<li class="listitem">
          Now that op futures are always correct, when_all(ops) has been drastically
          simplified to an implementation which literally assembles the futures into
          a list and passes them to boost::wait_for_all().
        </li>
<li class="listitem">
          Added when_any(ops).
        </li>
</ul></div>
<h4>
<a name="afio.release_notes.h7"></a>
      <span><a name="afio.release_notes.boost_1_55_afio_v1_11"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_55_afio_v1_11">Boost
      1.55 AFIO v1.11</a>
    </h4>
<p>
      Added --fast-build to test Jamfile to preserve my sanity attempting to work
      with AFIO on an Intel Atom 220 netbook.
    </p>
<p>
      Fixed failure to auto-const an async_data_op_req&lt;boost::asio::mutable_buffer&gt;
      when used for writing. Thanks to Bjorn Reese for reporting this.
    </p>
<p>
      Replaced use of std::runtime_error with std::invalid_argument where that makes
      sense. Thanks to Bjorn Reese for reporting this.
    </p>
<p>
      Replaced throwing of std::ios_base::failure with std::system_error. Thanks
      to Bjorn Reese for suggesting and submitting a patch for this.
    </p>
<p>
      async_io_dispatcher_base::enumerate() did not take a metadata_flags, and it
      was supposed to. Thanks to Bjorn Reese for reporting this.
    </p>
<p>
      Added a unit compilation test to ensure that implicit construction from a single
      arg to the op convenience classes works as intended.
    </p>
<p>
      Significantly optimised build system and added in precompiled headers support.
      Combined with --fast-build this provides an 8x build time improvement.
    </p>
<p>
      boost::afio::stat_t::st_type() is now a boost::filesystem::file_type instead
      of replicating the POSIX file type codes. Thanks to Bjorn Reese for suggesting
      this.
    </p>
<p>
      boost::afio::stat_t::st_mode() is now st_perms(). Also disabled unused fields
      in stat_t on Windows. Thanks to Bjorn Reese for suggesting this.
    </p>
<h4>
<a name="afio.release_notes.h8"></a>
      <span><a name="afio.release_notes.boost_1_55_afio_v1_1_1st_nov_201"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_55_afio_v1_1_1st_nov_201">Boost
      1.55 AFIO v1.1 1st Nov 2013</a>
    </h4>
<p>
      Immediate completions no longer hold the opslock, which meant the opslock could
      be changed from a recursive mutex to a spinlock. The new, more parallelised,
      behaviour illuminated a number of new race conditions in when_all() which have
      been fixed.
    </p>
<p>
      Completely gutted dispatch engine and replaced with a new, almost entirely
      wait free implementation based on throwing atomics at the problem. If it weren't
      for the spin lock around the central ops hash table, AFIO would now be an entirely
      wait free design.
    </p>
<p>
      In order to do something about that spin lock, replaced all locking in AFIO
      (apart from the directory file handle cache) with memory transactions instead.
      This does CPUID at runtime and will use Intel's TSX-NI memory transaction implementation
      if available, if not it falls back to a spin lock based emulation. On memory
      transaction capable CPUs, AFIO is now almost entirely wait free, apart from
      when it has to fetch memory from the kernel.
    </p>
<p>
      Made AFIO usable as headers only.
    </p>
<h4>
<a name="afio.release_notes.h9"></a>
      <span><a name="afio.release_notes.boost_1_55_afio_v1_0_27th_sep_20"></a></span><a class="link" href="release_notes.html#afio.release_notes.boost_1_55_afio_v1_0_27th_sep_20">Boost
      1.55 AFIO v1.0 27th Sep 2013</a>
    </h4>
<p>
      First release for end of Google Summer of Code 2013.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013-2015 Niall Douglas
      and Paul Kirth<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="advanced_topics/custom_completion_handler.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../afio.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../afio.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="FAQ.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
