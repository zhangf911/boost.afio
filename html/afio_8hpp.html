<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a batch asynchronous file i/o implementation based on Boost.ASIO.  
<a href="#details">More...</a></p>

<p><a href="afio_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classenqueued__task_3_01_r_07_08_4.html">enqueued_task&lt; R()&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classenqueued__task_3_01void_07_08_4.html">enqueued_task&lt; void()&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__source.html">thread_source</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for a source of thread workers.  <a href="classthread__source.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstd__thread__pool.html">std_thread_pool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A very simple thread pool based on std::thread or boost::thread.  <a href="classstd__thread__pool.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>std_thread_pool::worker</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstat__t.html">stat_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata about a directory entry.  <a href="structstat__t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html">directory_entry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for an entry in a directory with lazily filled metadata.  <a href="classdirectory__entry.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdirectory__entry__hash.html">directory_entry_hash</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A hasher for <a class="el" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>, hashing inode and birth time (if available on this platform).  <a href="structdirectory__entry__hash.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasync__io__handle.html">async_io_handle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class encapsulating a platform-specific file handle.  <a href="classasync__io__handle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__io__op.html">async_io_op</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to an asynchronous operation.  <a href="structasync__io__op.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__path__op__req.html">async_path_op_req</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of path and flags, with optional precondition.  <a href="structasync__path__op__req.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01const_01_t_01_4.html">async_data_op_req&lt; const T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a single `const T *`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01const_01_t_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01void_01_4.html">async_data_op_req&lt; void &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `void *`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01void_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01const_01void_01_4.html">async_data_op_req&lt; const void &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `const void *`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01const_01void_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html">async_data_op_req&lt; std::vector&lt; T, A &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `std::vector&lt;T, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html">async_data_op_req&lt; const std::vector&lt; T, A &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `const std::vector&lt;T, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html">async_data_op_req&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `std::array&lt;T, N&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html">async_data_op_req&lt; const std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `const std::array&lt;T, N&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html">async_data_op_req&lt; std::vector&lt; asio::mutable_buffer, A &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `std::vector&lt;asio::mutable_buffer, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html">async_data_op_req&lt; std::vector&lt; asio::const_buffer, A &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `std::vector&lt;asio::const_buffer, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html">async_data_op_req&lt; std::array&lt; asio::mutable_buffer, N &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `std::array&lt;asio::mutable_buffer, N&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html">async_data_op_req&lt; std::array&lt; asio::const_buffer, N &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `std::array&lt;asio::const_buffer, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html">async_data_op_req&lt; std::basic_string&lt; C, T, A &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `std::basic_string&lt;C, T, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html">async_data_op_req&lt; const std::basic_string&lt; C, T, A &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `const std::basic_string&lt;C, T, A&gt;`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html">async_data_op_req&lt; asio::mutable_buffer &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for reading into a `asio::mutable_buffer`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html">async_data_op_req&lt; asio::const_buffer &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, data and where for writing from a `asio::const_buffer`. Data <b>MUST</b> stay around until the operation completes.  <a href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__enumerate__op__req.html">async_enumerate_op_req</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata to prefetch.  <a href="structasync__enumerate__op__req.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577">BOOST_AFIO_VALIDATE_INPUTS</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate inputs at the point of instantiation.  <a href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">BOOST_AFIO_HEADERS_ONLY</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is compiled as headers only. Defaults to 1.  <a href="#a7d6cb43e029a76765081fb3a2f47187d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">BOOST_AFIO_USE_BOOST_THREAD</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against Boost.Thread or the C++ 11 STL thread. Defaults to 0.  <a href="#a183b5c98a87ff28a56ea3bfdbe141ee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">BOOST_AFIO_USE_BOOST_FILESYSTEM</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against Boost.Filesystem or the C++ 1z Filesystem TS. Defaults to 1 unless on VS2015 which provides a full Filesystem TS implementation.  <a href="#ab5974d84a78dbcf8b072fca370f1291d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">ASIO_STANDALONE</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if AFIO is bound against standalone ASIO or Boost.ASIO. Defaults to undefined, and therefore Boost.ASIO.  <a href="#a5b90f4adb6bc09ca319c35c3448ee67a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD</b>(type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac794ed8c3e9fc1a99bd54d5b993d2b6c"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD" ref="ac794ed8c3e9fc1a99bd54d5b993d2b6c" args="(field)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD</b>(field)&#160;&#160;&#160;fieldtype st_##field(std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt; dirh=std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()) { if(!(have_metadata&amp;metadata_flags::field)) { _int_fetch(metadata_flags::field, dirh); } return stat.st_##field; }</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db">file_flags</a> { <br/>
&#160;&#160;<a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252">None</a> = 0, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba809abe96853e69894bbf8e5730b31348">Read</a> = 1, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa56670174817e3fed92bfd8182d7c0d1">Write</a> = 2, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba3c4d2d19c91b345c33a83ca9f551f4e1">ReadWrite</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba71f30510b076569dd2830e348fb77a13">Append</a> = 4, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba4877d9d67c11656d88fc82cfeb94a4f3">Truncate</a> = 8, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba93479401ae71e13bd81626eb0b6c2d37">Create</a> = 16, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbafd41a51c46068f24398d21e5e8d23d16">CreateOnlyIfNotExist</a> = 32, 
<br/>
&#160;&#160;<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa26ef493b962366c21fef788da134721">WillBeSequentiallyAccessed</a> = 128, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba5ad1750347c8e7ce9513f1edb3dd3766">WillBeRandomlyAccessed</a> = 256, 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba6085ffcc368053b7563ee66109aba163">FastDirectoryEnumeration</a> = (1&lt;&lt;10), 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba837053fb9e27a38d2a153f5c85436644">UniqueDirectoryHandle</a> = (1&lt;&lt;11), 
<br/>
&#160;&#160;<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b">OSDirect</a> = (1&lt;&lt;16), 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa0ba263c207e29e2d1d6823d4dc7790b">OSMMap</a> = (1&lt;&lt;17), 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa3cc9b55b4157e3b0c799f941f21c001">AlwaysSync</a> = (1&lt;&lt;24), 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba58ef332941f8d3160a208d81a8d60f3f">SyncOnClose</a> = (1&lt;&lt;25), 
<br/>
&#160;&#160;<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba8f3aad3eb5f15e3dd74b03a781d3add2">EnforceDependencyWriteOrder</a> = (1&lt;&lt;26), 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3">int_opening_link</a> = (1&lt;&lt;29), 
<a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d">int_opening_dir</a> = (1&lt;&lt;30)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise file and directory open flags.  <a href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194">async_op_flags</a> { <a class="el" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0">none</a> = 0, 
<a class="el" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b">immediate</a> = 1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise async_op_flags flags.  <a href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> { <br/>
&#160;&#160;<a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252">None</a> = 0, 
<b>dev</b> = 1&lt;&lt;0, 
<b>ino</b> = 1&lt;&lt;1, 
<b>type</b> = 1&lt;&lt;2, 
<br/>
&#160;&#160;<b>perms</b> = 1&lt;&lt;3, 
<b>nlink</b> = 1&lt;&lt;4, 
<b>uid</b> = 1&lt;&lt;5, 
<b>gid</b> = 1&lt;&lt;6, 
<br/>
&#160;&#160;<b>rdev</b> = 1&lt;&lt;7, 
<b>atim</b> = 1&lt;&lt;8, 
<b>mtim</b> = 1&lt;&lt;9, 
<b>ctim</b> = 1&lt;&lt;10, 
<br/>
&#160;&#160;<b>size</b> = 1&lt;&lt;11, 
<b>allocated</b> = 1&lt;&lt;12, 
<b>blocks</b> = 1&lt;&lt;13, 
<b>blksize</b> = 1&lt;&lt;14, 
<br/>
&#160;&#160;<b>flags</b> = 1&lt;&lt;15, 
<b>gen</b> = 1&lt;&lt;16, 
<b>birthtim</b> = 1&lt;&lt;17, 
<a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fea54991d225c58ce0af43461d4e9a82312">All</a> = (size_t)-1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitflags for availability of metadata from `struct stat_t`.  <a href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93458e2822fc3073cd7cd31e94760d93"></a><!-- doxytag: member="afio.hpp::BOOST_BINDLIB_NAMESPACE_BEGIN" ref="a93458e2822fc3073cd7cd31e94760d93" args="(BOOST_AFIO_V1) typedef unsigned long long off_t" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_BINDLIB_NAMESPACE_BEGIN</b> (BOOST_AFIO_V1) typedef unsigned long long off_t</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classstd__thread__pool.html">std_thread_pool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca">process_threadpool</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process threadpool.  <a href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; async_file_io_dispatcher_base &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher.html#ga60af4394d09808d966a31a80fe9142eb">make_async_file_io_dispatcher</a> (std::shared_ptr&lt; <a class="el" href="classthread__source.html">thread_source</a> &gt; threadpool=<a class="el" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca">process_threadpool</a>(), <a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db">file_flags</a> flagsforce=<a class="el" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252">file_flags::None</a>, <a class="el" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db">file_flags</a> flagsmask=<a class="el" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252">file_flags::None</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instatiates the best available async_file_io_dispatcher implementation for this system.  <a href="group__async__file__io__dispatcher.html#ga60af4394d09808d966a31a80fe9142eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab26eb2e2bae885db696a11a8fae88eb1"></a><!-- doxytag: member="afio.hpp::when_all" ref="ab26eb2e2bae885db696a11a8fae88eb1" args="(std::nothrow_t _, Iterator first, Iterator last)" -->
Iterator::value_type::type&#160;</td><td class="memItemRight" valign="bottom"><b>when_all</b> (std::nothrow_t _, Iterator first, Iterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; false, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635">when_any</a> (std::nothrow_t _, Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga461b0e5f0a135982cac72648a1689e83">when_all</a> (std::nothrow_t _, std::vector&lt; <a class="el" href="structasync__io__op.html">async_io_op</a> &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#ga461b0e5f0a135982cac72648a1689e83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#gae51d3626cd8b9d2c5fe1d3b55c451fbd">when_any</a> (std::nothrow_t _, std::vector&lt; <a class="el" href="structasync__io__op.html">async_io_op</a> &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Does not propagate exception states.  <a href="group__when__all__ops.html#gae51d3626cd8b9d2c5fe1d3b55c451fbd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; true, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#gaaa1c16812271841ff671cfe7f231cb0b">when_all</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#gaaa1c16812271841ff671cfe7f231cb0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_async_op<br class="typebreak"/>
&lt; false, typename <br class="typebreak"/>
Iterator::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga5da03663689177b4c470ce149c87361d">when_any</a> (Iterator first, Iterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#ga5da03663689177b4c470ce149c87361d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga536ffef275e197aa15d35a3a4dd3a9bf">when_all</a> (std::vector&lt; <a class="el" href="structasync__io__op.html">async_io_op</a> &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when all the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#ga536ffef275e197aa15d35a3a4dd3a9bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga73eaeec972558c72429fbd5042307036">when_any</a> (std::vector&lt; <a class="el" href="structasync__io__op.html">async_io_op</a> &gt; ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when any the supplied ops complete. Propagates exception states.  <a href="group__when__all__ops.html#ga73eaeec972558c72429fbd5042307036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#gaff9f004d3897d9bf83261e45a050c252">when_all</a> (std::nothrow_t _, <a class="el" href="structasync__io__op.html">async_io_op</a> op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when the supplied op completes. Does not propagate exception states.  <a href="group__when__all__ops.html#gaff9f004d3897d9bf83261e45a050c252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">future&lt; std::vector<br class="typebreak"/>
&lt; std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__when__all__ops.html#ga7e235ffd635c6b38fa0c416c872ae044">when_all</a> (<a class="el" href="structasync__io__op.html">async_io_op</a> op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result when the supplied op completes. Propagates exception states.  <a href="group__when__all__ops.html#ga7e235ffd635c6b38fa0c416c872ae044"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">async_data_op_req&lt; typename <br class="typebreak"/>
std::remove_pointer&lt; typename <br class="typebreak"/>
std::decay&lt; T &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e">make_async_data_op_req</a> (<a class="el" href="structasync__io__op.html">async_io_op</a> _precondition, T &amp;&amp;v, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a async_data_op_req, letting the compiler deduce the template specialisation to use.  <a href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">async_data_op_req&lt; typename <br class="typebreak"/>
std::remove_pointer&lt; typename <br class="typebreak"/>
std::decay&lt; T &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__make__async__data__op__req.html#ga7a472d3abdf6c990c3475b8c120863dc">make_async_data_op_req</a> (<a class="el" href="structasync__io__op.html">async_io_op</a> _precondition, T &amp;&amp;v, size_t _length, off_t _where)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience instantiator of a async_data_op_req, letting the compiler deduce the template specialisation to use.  <a href="group__make__async__data__op__req.html#ga7a472d3abdf6c990c3475b8c120863dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeda7e99c9aaa7388ee878546daf72f2"></a><!-- doxytag: member="afio.hpp::BOOST_BINDLIB_NAMESPACE_END" ref="abeda7e99c9aaa7388ee878546daf72f2" args="(BOOST_AFIO_V1) 1 std" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_BINDLIB_NAMESPACE_END</b> (BOOST_AFIO_V1) 1 std</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Provides a batch asynchronous file i/o implementation based on Boost.ASIO. </p>

<p>Definition in file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7d6cb43e029a76765081fb3a2f47187d"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_HEADERS_ONLY" ref="a7d6cb43e029a76765081fb3a2f47187d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">BOOST_AFIO_HEADERS_ONLY</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is compiled as headers only. Defaults to 1. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00081">81</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a183b5c98a87ff28a56ea3bfdbe141ee9"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_USE_BOOST_THREAD" ref="a183b5c98a87ff28a56ea3bfdbe141ee9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">BOOST_AFIO_USE_BOOST_THREAD</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against Boost.Thread or the C++ 11 STL thread. Defaults to 0. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00082">82</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5974d84a78dbcf8b072fca370f1291d"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_USE_BOOST_FILESYSTEM" ref="ab5974d84a78dbcf8b072fca370f1291d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">BOOST_AFIO_USE_BOOST_FILESYSTEM</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against Boost.Filesystem or the C++ 1z Filesystem TS. Defaults to 1 unless on VS2015 which provides a full Filesystem TS implementation. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00083">83</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b90f4adb6bc09ca319c35c3448ee67a"></a><!-- doxytag: member="afio.hpp::ASIO_STANDALONE" ref="a5b90f4adb6bc09ca319c35c3448ee67a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">ASIO_STANDALONE</a>&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines if AFIO is bound against standalone ASIO or Boost.ASIO. Defaults to undefined, and therefore Boost.ASIO. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00084">84</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a933046d7a31248aa271a978579ee8977"></a><!-- doxytag: member="afio.hpp::BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD" ref="a933046d7a31248aa271a978579ee8977" args="(type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">inline</span> BOOST_CONSTEXPR type operator&amp;(type a, type b) \
{ \
    return <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a) &amp; static_cast&lt;size_t&gt;(b)); \
} \
inline BOOST_CONSTEXPR type operator|(type a, type b) \
{ \
    return <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a) | static_cast&lt;size_t&gt;(b)); \
} \
inline BOOST_CONSTEXPR type operator~(type a) \
{ \
    return <span class="keyword">static_cast&lt;</span>type<span class="keyword">&gt;</span>(~static_cast&lt;<span class="keywordtype">size_t</span>&gt;(a)); \
} \
inline BOOST_CONSTEXPR <span class="keywordtype">bool</span> operator!(type a) \
{ \
    return 0==<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(a); \
}
</pre></div>
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00344">344</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
