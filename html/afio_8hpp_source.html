<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="afio_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* async_file_io</span>
<a name="l00002"></a>00002 <span class="comment">Provides a threadpool and asynchronous file i/o infrastructure based on Boost.ASIO, Boost.Iostreams and filesystem</span>
<a name="l00003"></a>00003 <span class="comment">(C) 2013-2014 Niall Douglas http://www.nedprod.com/</span>
<a name="l00004"></a>00004 <span class="comment">File Created: Mar 2013</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">Boost Software License - Version 1.0 - August 17th, 2003</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">Permission is hereby granted, free of charge, to any person or organization</span>
<a name="l00010"></a>00010 <span class="comment">obtaining a copy of the software and accompanying documentation covered by</span>
<a name="l00011"></a>00011 <span class="comment">this license (the &quot;Software&quot;) to use, reproduce, display, distribute,</span>
<a name="l00012"></a>00012 <span class="comment">execute, and transmit the Software, and to prepare derivative works of the</span>
<a name="l00013"></a>00013 <span class="comment">Software, and to permit third-parties to whom the Software is furnished to</span>
<a name="l00014"></a>00014 <span class="comment">do so, all subject to the following:</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">The copyright notices in the Software and this entire statement, including</span>
<a name="l00017"></a>00017 <span class="comment">the above license grant, this restriction and the following disclaimer,</span>
<a name="l00018"></a>00018 <span class="comment">must be included in all copies of the Software, in whole or in part, and</span>
<a name="l00019"></a>00019 <span class="comment">all derivative works of the Software, unless such copies or derivative</span>
<a name="l00020"></a>00020 <span class="comment">works are solely in the form of machine-executable object code generated by</span>
<a name="l00021"></a>00021 <span class="comment">a source language processor.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00024"></a>00024 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00025"></a>00025 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT</span>
<a name="l00026"></a>00026 <span class="comment">SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE</span>
<a name="l00027"></a>00027 <span class="comment">FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,</span>
<a name="l00028"></a>00028 <span class="comment">ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<a name="l00029"></a>00029 <span class="comment">DEALINGS IN THE SOFTWARE.</span>
<a name="l00030"></a>00030 <span class="comment">*/</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;config.hpp&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#ifdef BOOST_AFIO_NEED_DEFINE</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;detail/Undoer.hpp&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;detail/ErrorHandling.hpp&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;detail/Utility.hpp&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;type_traits&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;exception&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Boost.ASIO needs std::min and std::max</span>
<a name="l00043"></a>00043 
<a name="l00052"></a>00052 <span class="preprocessor">#ifndef BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00054"></a><a class="code" href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577">00054</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_VALIDATE_INPUTS 1</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_VALIDATE_INPUTS 0</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#ifdef BOOST_MSVC</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(push)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable: 4251) // type needs to have dll-interface to be used by clients of class</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00080"></a>00080 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00081"></a><a class="code" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">00081</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_HEADERS_ONLY 1</span>
<a name="l00082"></a><a class="code" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">00082</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_USE_BOOST_THREAD 0</span>
<a name="l00083"></a><a class="code" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">00083</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_USE_BOOST_FILESYSTEM 1</span>
<a name="l00084"></a><a class="code" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">00084</a> <span class="preprocessor"></span><span class="preprocessor">#define ASIO_STANDALONE 0</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 BOOST_AFIO_V1_NAMESPACE_BEGIN
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">// This isn&#39;t consistent on MSVC so hard code it</span>
<a name="l00090"></a>00090 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> off_t;
<a name="l00091"></a>00091 
<a name="l00093"></a>00093 <span class="keyword">namespace </span>detail
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">class </span>enqueued_task_impl
<a name="l00096"></a>00096     {
<a name="l00097"></a>00097     <span class="keyword">protected</span>:
<a name="l00098"></a>00098         <span class="keyword">struct </span>Private
<a name="l00099"></a>00099         {
<a name="l00100"></a>00100             std::function&lt;R()&gt; task;
<a name="l00101"></a>00101             promise&lt;R&gt; r;
<a name="l00102"></a>00102             shared_future&lt;R&gt; f;
<a name="l00103"></a>00103             <span class="keywordtype">bool</span> autoset;
<a name="l00104"></a>00104             atomic&lt;int&gt; done;
<a name="l00105"></a>00105             Private(std::function&lt;R()&gt; _task) : task(std::move(_task)), f(r.get_future().share()), autoset(<span class="keyword">true</span>), done(0) { }
<a name="l00106"></a>00106         };
<a name="l00107"></a>00107         std::shared_ptr&lt;Private&gt; p;
<a name="l00108"></a>00108         <span class="keywordtype">void</span> validate()<span class="keyword"> const </span>{ assert(p); <span class="comment">/*if(!p) abort();*/</span> }
<a name="l00109"></a>00109     <span class="keyword">public</span>:
<a name="l00111"></a>00111         enqueued_task_impl(std::function&lt;R()&gt; _task=std::function&lt;R()&gt;()) : p(std::make_shared&lt;Private&gt;(std::move(_task))) { }
<a name="l00113"></a>00113         <span class="keywordtype">bool</span> valid() <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW{ <span class="keywordflow">return</span> p.get()!=<span class="keyword">nullptr</span>; }
<a name="l00115"></a>00115         <span class="keywordtype">void</span> swap(enqueued_task_impl &amp;o) BOOST_NOEXCEPT_OR_NOTHROW{ p.swap(o.p); }
<a name="l00117"></a>00117         <span class="keywordtype">void</span> reset() { p.reset(); }
<a name="l00119"></a>00119         <span class="keywordtype">void</span> set_task(std::function&lt;R()&gt; _task) { p-&gt;task=std::move(_task); }
<a name="l00121"></a>00121         <span class="keyword">const</span> shared_future&lt;R&gt; &amp;get_future()<span class="keyword"> const </span>{ validate(); <span class="keywordflow">return</span> p-&gt;f; }
<a name="l00123"></a>00123         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> set_future_value(T v)
<a name="l00124"></a>00124         {
<a name="l00125"></a>00125             <span class="keywordtype">int</span> _=0;
<a name="l00126"></a>00126             validate();
<a name="l00127"></a>00127             <span class="keywordflow">if</span>(!p-&gt;done.compare_exchange_strong(_, 1))
<a name="l00128"></a>00128                 <span class="keywordflow">return</span>;
<a name="l00129"></a>00129             p-&gt;r.set_value(std::move(v));
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         <span class="keywordtype">void</span> set_future_value()
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133             <span class="keywordtype">int</span> _=0;
<a name="l00134"></a>00134             validate();
<a name="l00135"></a>00135             <span class="keywordflow">if</span>(!p-&gt;done.compare_exchange_strong(_, 1))
<a name="l00136"></a>00136                 <span class="keywordflow">return</span>;
<a name="l00137"></a>00137             p-&gt;r.set_value();
<a name="l00138"></a>00138         }
<a name="l00140"></a>00140         <span class="keywordtype">void</span> set_future_exception(exception_ptr e)
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142             <span class="keywordtype">int</span> _=0;
<a name="l00143"></a>00143             validate();
<a name="l00144"></a>00144             <span class="keywordflow">if</span>(!p-&gt;done.compare_exchange_strong(_, 1))
<a name="l00145"></a>00145                 <span class="keywordflow">return</span>;
<a name="l00146"></a>00146             p-&gt;r.set_exception(e);
<a name="l00147"></a>00147         }
<a name="l00149"></a>00149         <span class="keywordtype">void</span> disable_auto_set_future(<span class="keywordtype">bool</span> v=<span class="keyword">true</span>) { validate(); p-&gt;autoset=!v; }
<a name="l00150"></a>00150     };
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00153"></a><a class="code" href="classenqueued__task.html">00153</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">class </span><a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task</a>;
<a name="l00164"></a>00164 <span class="comment">// Can&#39;t have args in callable type as that segfaults VS2010</span>
<a name="l00165"></a><a class="code" href="classenqueued__task_3_01_r_07_08_4.html">00165</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">class </span><a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task</a>&lt;R()&gt; : <span class="keyword">public</span> detail::enqueued_task_impl&lt;R&gt;
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167     <span class="keyword">typedef</span> detail::enqueued_task_impl&lt;R&gt; Base;
<a name="l00168"></a>00168 <span class="keyword">public</span>:
<a name="l00170"></a><a class="code" href="classenqueued__task_3_01_r_07_08_4.html#a0fd457bc45b0c909efb1728b3aa4fe6f">00170</a>     <a class="code" href="classenqueued__task_3_01_r_07_08_4.html#a0fd457bc45b0c909efb1728b3aa4fe6f" title="Default constructor.">enqueued_task</a>(std::function&lt;R()&gt; _task=std::function&lt;R()&gt;()) : Base(std::move(_task)) { }
<a name="l00172"></a><a class="code" href="classenqueued__task_3_01_r_07_08_4.html#a7baccc036c5a35bdc3eed93294385e1e">00172</a>     <span class="keywordtype">void</span> operator()()
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174         <span class="keyword">auto</span> _p(Base::p);
<a name="l00175"></a>00175         Base::validate();
<a name="l00176"></a>00176         <span class="keywordflow">if</span>(!_p-&gt;task) abort();
<a name="l00177"></a>00177         <span class="keywordflow">try</span>
<a name="l00178"></a>00178         {
<a name="l00179"></a>00179             <span class="keyword">auto</span> v(_p-&gt;task());
<a name="l00180"></a>00180             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done) Base::set_future_value(v);
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182         <span class="keywordflow">catch</span>(...)
<a name="l00183"></a>00183         {
<a name="l00184"></a>00184             <span class="keywordflow">if</span>(_p-&gt;done)
<a name="l00185"></a>00185             {
<a name="l00186"></a>00186               std::cerr &lt;&lt; detail::output_exception_info &lt;&lt; <span class="stringliteral">&quot; thrown up to enqueued_task&lt;&gt; after future set.&quot;</span> &lt;&lt; std::endl;
<a name="l00187"></a>00187               BOOST_AFIO_THROW_FATAL(std::runtime_error(<span class="stringliteral">&quot;Exception thrown up to enqueued_task&lt;&gt; after future set.&quot;</span>));
<a name="l00188"></a>00188             }
<a name="l00189"></a>00189             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done) 
<a name="l00190"></a>00190             {
<a name="l00191"></a>00191                 <span class="keyword">auto</span> e(current_exception());
<a name="l00192"></a>00192                 Base::set_future_exception(e);
<a name="l00193"></a>00193             }
<a name="l00194"></a>00194         }
<a name="l00195"></a>00195         <span class="comment">// Free any bound parameters in task to save memory</span>
<a name="l00196"></a>00196         _p-&gt;task=std::function&lt;R()&gt;();
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198 };
<a name="l00199"></a><a class="code" href="classenqueued__task_3_01void_07_08_4.html">00199</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span><a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task</a>&lt;void()&gt; : <span class="keyword">public</span> detail::enqueued_task_impl&lt;void&gt;
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     <span class="keyword">typedef</span> detail::enqueued_task_impl&lt;void&gt; Base;
<a name="l00202"></a>00202 <span class="keyword">public</span>:
<a name="l00204"></a><a class="code" href="classenqueued__task_3_01void_07_08_4.html#afc7f622b214974cf02a3f592e6abd138">00204</a>     <a class="code" href="classenqueued__task_3_01void_07_08_4.html#afc7f622b214974cf02a3f592e6abd138" title="Default constructor.">enqueued_task</a>(std::function&lt;<span class="keywordtype">void</span>()&gt; _task=std::function&lt;<span class="keywordtype">void</span>()&gt;()) : Base(std::move(_task)) { }
<a name="l00206"></a><a class="code" href="classenqueued__task_3_01void_07_08_4.html#a9943506555ea046e28f4d631af337ea8">00206</a>     <span class="keywordtype">void</span> operator()()
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208         <span class="keyword">auto</span> _p(Base::p);
<a name="l00209"></a>00209         Base::validate();
<a name="l00210"></a>00210         <span class="keywordflow">if</span>(!_p-&gt;task) abort();
<a name="l00211"></a>00211         <span class="keywordflow">try</span>
<a name="l00212"></a>00212         {
<a name="l00213"></a>00213             _p-&gt;task();
<a name="l00214"></a>00214             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done) Base::set_future_value();
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216         <span class="keywordflow">catch</span>(...)
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218             <span class="keywordflow">if</span>(_p-&gt;done)
<a name="l00219"></a>00219             {
<a name="l00220"></a>00220               std::cerr &lt;&lt; detail::output_exception_info &lt;&lt; <span class="stringliteral">&quot; thrown up to enqueued_task&lt;&gt; after future set.&quot;</span> &lt;&lt; std::endl;
<a name="l00221"></a>00221               BOOST_AFIO_THROW_FATAL(std::runtime_error(<span class="stringliteral">&quot;Exception thrown up to enqueued_task&lt;&gt; after future set.&quot;</span>));
<a name="l00222"></a>00222             }
<a name="l00223"></a>00223             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done)
<a name="l00224"></a>00224             {
<a name="l00225"></a>00225                 <span class="keyword">auto</span> e(current_exception());
<a name="l00226"></a>00226                 Base::set_future_exception(e);
<a name="l00227"></a>00227             }
<a name="l00228"></a>00228         }
<a name="l00229"></a>00229         <span class="comment">// Free any bound parameters in task to save memory</span>
<a name="l00230"></a>00230         _p-&gt;task=std::function&lt;void()&gt;();
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232 };
<a name="l00240"></a><a class="code" href="classthread__source.html">00240</a> <span class="keyword">class </span><a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> : <span class="keyword">public</span> std::enable_shared_from_this&lt;thread_source&gt;
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242 <span class="keyword">protected</span>:
<a name="l00243"></a>00243     asio::io_service &amp;service;
<a name="l00244"></a>00244     <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a>(asio::io_service &amp;_service) : service(_service) { }
<a name="l00245"></a>00245     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~<a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a>() { }
<a name="l00246"></a>00246     <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> &amp;) = <span class="keyword">delete</span>;
<a name="l00247"></a>00247 <span class="keyword">public</span>:
<a name="l00249"></a><a class="code" href="classthread__source.html#a12ea3803826545dad75911f45f911fb0">00249</a>     asio::io_service &amp;<a class="code" href="classthread__source.html#a12ea3803826545dad75911f45f911fb0" title="Returns the underlying io_service.">io_service</a>() { <span class="keywordflow">return</span> service; }
<a name="l00251"></a><a class="code" href="classthread__source.html#a6a51649d8eef305a22225e1985b5c69a">00251</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keywordtype">void</span> <a class="code" href="classthread__source.html#a6a51649d8eef305a22225e1985b5c69a" title="Sends a task to the thread pool for execution.">enqueue</a>(<a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task&lt;R&gt;</a> task)
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253         service.post(task);
<a name="l00254"></a>00254     }
<a name="l00256"></a><a class="code" href="classthread__source.html#aaaa9cabaf1ebc6be74301b207518b1e1">00256</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; shared_future&lt;typename std::result_of&lt;F()&gt;::type&gt; <a class="code" href="classthread__source.html#a6a51649d8eef305a22225e1985b5c69a" title="Sends a task to the thread pool for execution.">enqueue</a>(F f)
<a name="l00257"></a>00257     {
<a name="l00258"></a>00258         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;F()&gt;::type R;
<a name="l00259"></a>00259         <a class="code" href="classenqueued__task_3_01_r_07_08_4.html">enqueued_task&lt;R()&gt;</a> out(std::move(f));
<a name="l00260"></a>00260         <span class="keyword">auto</span> ret(out.get_future());
<a name="l00261"></a>00261         service.post(out);
<a name="l00262"></a>00262         <span class="keywordflow">return</span> std::move(ret);
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264 };
<a name="l00265"></a>00265 
<a name="l00271"></a><a class="code" href="classstd__thread__pool.html">00271</a> <span class="keyword">class </span><a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a> : <span class="keyword">public</span> <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> {
<a name="l00272"></a>00272     <span class="keyword">class </span>worker
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274         <a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a> *pool;
<a name="l00275"></a>00275     <span class="keyword">public</span>:
<a name="l00276"></a>00276         <span class="keyword">explicit</span> worker(<a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a> *p) : pool(p) { }
<a name="l00277"></a>00277         <span class="keywordtype">void</span> operator()()
<a name="l00278"></a>00278         {
<a name="l00279"></a>00279             detail::set_threadname(<span class="stringliteral">&quot;boost::afio::std_thread_pool worker&quot;</span>);
<a name="l00280"></a>00280             <span class="keywordflow">try</span>
<a name="l00281"></a>00281             {
<a name="l00282"></a>00282                 pool-&gt;service.run();
<a name="l00283"></a>00283             }
<a name="l00284"></a>00284             <span class="keywordflow">catch</span>(...)
<a name="l00285"></a>00285             {
<a name="l00286"></a>00286                 std::cerr &lt;&lt; <span class="stringliteral">&quot;WARNING: ASIO exits via &quot;</span> &lt;&lt; detail::output_exception_info &lt;&lt; <span class="stringliteral">&quot; which shouldn&#39;t happen.&quot;</span> &lt;&lt; std::endl;
<a name="l00287"></a>00287             }
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289     };
<a name="l00290"></a>00290     <span class="keyword">friend</span> <span class="keyword">class </span>worker;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     asio::io_service service;
<a name="l00293"></a>00293     std::unique_ptr&lt;asio::io_service::work&gt; working;
<a name="l00294"></a>00294     std::vector&lt; std::unique_ptr&lt;thread&gt; &gt; workers;
<a name="l00295"></a>00295 <span class="keyword">public</span>:
<a name="l00299"></a><a class="code" href="classstd__thread__pool.html#ae6b19bc3e4bc336d2d64e85ac03b1608">00299</a>     <span class="keyword">explicit</span> <a class="code" href="classstd__thread__pool.html#ae6b19bc3e4bc336d2d64e85ac03b1608" title="Constructs a thread pool of no workers.">std_thread_pool</a>(<span class="keywordtype">size_t</span> no) : <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a>(service), working(detail::make_unique&lt;asio::<a class="code" href="classthread__source.html#a12ea3803826545dad75911f45f911fb0" title="Returns the underlying io_service.">io_service</a>::work&gt;(service))
<a name="l00300"></a>00300     {
<a name="l00301"></a>00301         <a class="code" href="classstd__thread__pool.html#a41e63ac0720d88c4995457bbfc652bf4" title="Adds more workers to the thread pool.">add_workers</a>(no);
<a name="l00302"></a>00302     }
<a name="l00304"></a><a class="code" href="classstd__thread__pool.html#a41e63ac0720d88c4995457bbfc652bf4">00304</a>     <span class="keywordtype">void</span> <a class="code" href="classstd__thread__pool.html#a41e63ac0720d88c4995457bbfc652bf4" title="Adds more workers to the thread pool.">add_workers</a>(<span class="keywordtype">size_t</span> no)
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306         workers.reserve(workers.size()+no);
<a name="l00307"></a>00307         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n=0; n&lt;no; n++)
<a name="l00308"></a>00308             workers.push_back(detail::make_unique&lt;thread&gt;(worker(<span class="keyword">this</span>)));
<a name="l00309"></a>00309     }
<a name="l00311"></a><a class="code" href="classstd__thread__pool.html#aa191fb9c0df971e2136bf977f220fb0b">00311</a>     <span class="keywordtype">void</span> <a class="code" href="classstd__thread__pool.html#aa191fb9c0df971e2136bf977f220fb0b" title="Destroys the thread pool, waiting for worker threads to exit beforehand.">destroy</a>()
<a name="l00312"></a>00312     {
<a name="l00313"></a>00313         <span class="keywordflow">if</span>(!service.stopped())
<a name="l00314"></a>00314         {
<a name="l00315"></a>00315             <span class="comment">// Tell the threads there is no more work to do</span>
<a name="l00316"></a>00316             working.reset();
<a name="l00317"></a>00317             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i: workers) { i-&gt;join(); }
<a name="l00318"></a>00318             workers.clear();
<a name="l00319"></a>00319             <span class="comment">// For some reason ASIO occasionally thinks there is still more work to do</span>
<a name="l00320"></a>00320             <span class="keywordflow">if</span>(!service.stopped())
<a name="l00321"></a>00321                 service.run();
<a name="l00322"></a>00322             service.stop();
<a name="l00323"></a>00323             service.reset();
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325     }
<a name="l00326"></a>00326     ~<a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a>()
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328         <a class="code" href="classstd__thread__pool.html#aa191fb9c0df971e2136bf977f220fb0b" title="Destroys the thread pool, waiting for worker threads to exit beforehand.">destroy</a>();
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330 };
<a name="l00336"></a>00336 BOOST_AFIO_HEADERS_ONLY_FUNC_SPEC std::shared_ptr&lt;std_thread_pool&gt; <a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>();
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">class </span>async_file_io_dispatcher_base;
<a name="l00339"></a>00339 <span class="keyword">struct </span><a class="code" href="structasync__io__op.html" title="A reference to an asynchronous operation.">async_io_op</a>;
<a name="l00340"></a>00340 <span class="keyword">struct </span><a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a>;
<a name="l00341"></a>00341 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_data_op_req;
<a name="l00342"></a>00342 <span class="keyword">struct </span><a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="preprocessor">#define BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(type) \</span>
<a name="l00345"></a>00345 <span class="preprocessor">inline BOOST_CONSTEXPR type operator&amp;(type a, type b) \</span>
<a name="l00346"></a>00346 <span class="preprocessor">{ \</span>
<a name="l00347"></a>00347 <span class="preprocessor">    return static_cast&lt;type&gt;(static_cast&lt;size_t&gt;(a) &amp; static_cast&lt;size_t&gt;(b)); \</span>
<a name="l00348"></a>00348 <span class="preprocessor">} \</span>
<a name="l00349"></a>00349 <span class="preprocessor">inline BOOST_CONSTEXPR type operator|(type a, type b) \</span>
<a name="l00350"></a>00350 <span class="preprocessor">{ \</span>
<a name="l00351"></a>00351 <span class="preprocessor">    return static_cast&lt;type&gt;(static_cast&lt;size_t&gt;(a) | static_cast&lt;size_t&gt;(b)); \</span>
<a name="l00352"></a>00352 <span class="preprocessor">} \</span>
<a name="l00353"></a>00353 <span class="preprocessor">inline BOOST_CONSTEXPR type operator~(type a) \</span>
<a name="l00354"></a>00354 <span class="preprocessor">{ \</span>
<a name="l00355"></a>00355 <span class="preprocessor">    return static_cast&lt;type&gt;(~static_cast&lt;size_t&gt;(a)); \</span>
<a name="l00356"></a>00356 <span class="preprocessor">} \</span>
<a name="l00357"></a>00357 <span class="preprocessor">inline BOOST_CONSTEXPR bool operator!(type a) \</span>
<a name="l00358"></a>00358 <span class="preprocessor">{ \</span>
<a name="l00359"></a>00359 <span class="preprocessor">    return 0==static_cast&lt;size_t&gt;(a); \</span>
<a name="l00360"></a>00360 <span class="preprocessor">}</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00368"></a>00368 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00369"></a><a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db">00369</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a>
<a name="l00370"></a>00370 <span class="preprocessor">#else</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> : size_t
<a name="l00372"></a>00372 <span class="preprocessor">#endif</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>{
<a name="l00374"></a><a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252">00374</a>     <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>=0,             
<a name="l00375"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba809abe96853e69894bbf8e5730b31348">00375</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba809abe96853e69894bbf8e5730b31348" title="Read access.">Read</a>=1,             
<a name="l00376"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa56670174817e3fed92bfd8182d7c0d1">00376</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa56670174817e3fed92bfd8182d7c0d1" title="Write access.">Write</a>=2,            
<a name="l00377"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba3c4d2d19c91b345c33a83ca9f551f4e1">00377</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba3c4d2d19c91b345c33a83ca9f551f4e1" title="Read and write access.">ReadWrite</a>=3,        
<a name="l00378"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba71f30510b076569dd2830e348fb77a13">00378</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba71f30510b076569dd2830e348fb77a13" title="Append only.">Append</a>=4,           
<a name="l00379"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba4877d9d67c11656d88fc82cfeb94a4f3">00379</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba4877d9d67c11656d88fc82cfeb94a4f3" title="Truncate existing file to zero.">Truncate</a>=8,         
<a name="l00380"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba93479401ae71e13bd81626eb0b6c2d37">00380</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba93479401ae71e13bd81626eb0b6c2d37" title="Open and create if doesn&#39;t exist. Always creates sparse files if possible.">Create</a>=16,          
<a name="l00381"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbafd41a51c46068f24398d21e5e8d23d16">00381</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbafd41a51c46068f24398d21e5e8d23d16" title="Create and open only if doesn&#39;t exist.">CreateOnlyIfNotExist</a>=32, 
<a name="l00382"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaaafe04801c8d2d887be1a626b924c0be">00382</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaaafe04801c8d2d887be1a626b924c0be" title="Create a compressed file, needs to be combined with one of the other create flags. Only succeeds if supported by the underlying filing system.">CreateCompressed</a>=64,     
<a name="l00383"></a>00383 
<a name="l00384"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa26ef493b962366c21fef788da134721">00384</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa26ef493b962366c21fef788da134721" title="Will be exclusively either read or written sequentially. If you&#39;re exclusively writing sequentially...">WillBeSequentiallyAccessed</a>=128, 
<a name="l00385"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba5ad1750347c8e7ce9513f1edb3dd3766">00385</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba5ad1750347c8e7ce9513f1edb3dd3766" title="Will be randomly accessed, so don&#39;t bother with read-ahead. If you&#39;re using this, strongly consider t...">WillBeRandomlyAccessed</a>=256, 
<a name="l00386"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba676b9cbbb9391959f0dcd1427a125d2e">00386</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba676b9cbbb9391959f0dcd1427a125d2e" title="Don&#39;t create sparse files. May be ignored by some filing systems (e.g. ext4).">NoSparse</a>=512,       
<a name="l00387"></a>00387 
<a name="l00388"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba6085ffcc368053b7563ee66109aba163">00388</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba6085ffcc368053b7563ee66109aba163" title="Hold a file handle open to the containing directory of each open file for fast directory enumeration...">FastDirectoryEnumeration</a>=(1&lt;&lt;10), 
<a name="l00389"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba837053fb9e27a38d2a153f5c85436644">00389</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba837053fb9e27a38d2a153f5c85436644" title="Return a unique directory handle rather than a shared directory handle.">UniqueDirectoryHandle</a>=(1&lt;&lt;11), 
<a name="l00390"></a>00390 
<a name="l00391"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b">00391</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b" title="Bypass the OS file buffers (only really useful for writing large files, or a lot of random reads and ...">OSDirect</a>=(1&lt;&lt;16),   
<a name="l00392"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa0ba263c207e29e2d1d6823d4dc7790b">00392</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa0ba263c207e29e2d1d6823d4dc7790b" title="Memory map files (for reads only).">OSMMap</a>=(1&lt;&lt;17),     
<a name="l00393"></a>00393 
<a name="l00394"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa3cc9b55b4157e3b0c799f941f21c001">00394</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa3cc9b55b4157e3b0c799f941f21c001" title="Ask the OS to not complete until the data is on the physical storage. Best used only with OSDirect...">AlwaysSync</a>=(1&lt;&lt;24),     
<a name="l00395"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba58ef332941f8d3160a208d81a8d60f3f">00395</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba58ef332941f8d3160a208d81a8d60f3f" title="Automatically initiate an asynchronous flush just before file close, and fuse both operations so both...">SyncOnClose</a>=(1&lt;&lt;25),    
<a name="l00396"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba8f3aad3eb5f15e3dd74b03a781d3add2">00396</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba8f3aad3eb5f15e3dd74b03a781d3add2" title="Ensure that data writes to files reach physical storage in the same order as the op dependencies clos...">EnforceDependencyWriteOrder</a>=(1&lt;&lt;26), 
<a name="l00397"></a>00397 
<a name="l00398"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3">00398</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3" title="Internal use only. Don&#39;t use.">int_opening_link</a>=(1&lt;&lt;29), 
<a name="l00399"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d">00399</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d" title="Internal use only. Don&#39;t use.">int_opening_dir</a>=(1&lt;&lt;30) 
<a name="l00400"></a>00400 };
<a name="l00401"></a>00401 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a>)
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 
<a name="l00407"></a>00407 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00408"></a><a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194">00408</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>
<a name="l00409"></a>00409 <span class="preprocessor">#else</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> : size_t
<a name="l00411"></a>00411 <span class="preprocessor">#endif</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>{
<a name="l00413"></a><a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0">00413</a>     <a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0" title="No flags set.">none</a>=0,                 
<a name="l00414"></a><a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b">00414</a>     <a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b" title="Call chained completion immediately instead of scheduling for later. Make SURE your completion can no...">immediate</a>=1             
<a name="l00415"></a>00415 };
<a name="l00416"></a>00416 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>)
<a name="l00417"></a>00417 
<a name="l00418"></a>00418 namespace detail {
<a name="l00419"></a>00419     <span class="keyword">struct </span>async_io_handle_posix;
<a name="l00420"></a>00420     <span class="keyword">struct </span>async_io_handle_windows;
<a name="l00421"></a>00421     <span class="keyword">struct </span>async_file_io_dispatcher_base_p;
<a name="l00422"></a>00422     <span class="keyword">class </span>async_file_io_dispatcher_compat;
<a name="l00423"></a>00423     <span class="keyword">class </span>async_file_io_dispatcher_windows;
<a name="l00424"></a>00424     <span class="keyword">class </span>async_file_io_dispatcher_linux;
<a name="l00425"></a>00425     <span class="keyword">class </span>async_file_io_dispatcher_qnx;
<a name="l00426"></a>00426     <span class="keyword">struct </span>immediate_async_ops;
<a name="l00427"></a>00427     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> for_writing&gt; <span class="keyword">class </span>async_data_op_req_impl;
<a name="l00428"></a>00428 
<a name="l00432"></a>00432 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>    <span class="keyword">enum</span> OpType
<a name="l00434"></a>00434 <span class="preprocessor">#else</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span>    <span class="keyword">enum class</span> OpType
<a name="l00436"></a>00436 #endif
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438         Unknown,
<a name="l00439"></a>00439         UserCompletion,
<a name="l00440"></a>00440         dir,
<a name="l00441"></a>00441         rmdir,
<a name="l00442"></a>00442         file,
<a name="l00443"></a>00443         rmfile,
<a name="l00444"></a>00444         symlink,
<a name="l00445"></a>00445         rmsymlink,
<a name="l00446"></a>00446         sync,
<a name="l00447"></a>00447         close,
<a name="l00448"></a>00448         read,
<a name="l00449"></a>00449         write,
<a name="l00450"></a>00450         truncate,
<a name="l00451"></a>00451         barrier,
<a name="l00452"></a>00452         enumerate,
<a name="l00453"></a>00453         adopt,
<a name="l00454"></a>00454         zero,
<a name="l00455"></a>00455         extents,
<a name="l00456"></a>00456         statfs,
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         Last
<a name="l00459"></a>00459     };
<a name="l00460"></a>00460     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *optypes[]={
<a name="l00461"></a>00461         <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l00462"></a>00462         <span class="stringliteral">&quot;UserCompletion&quot;</span>,
<a name="l00463"></a>00463         <span class="stringliteral">&quot;dir&quot;</span>,
<a name="l00464"></a>00464         <span class="stringliteral">&quot;rmdir&quot;</span>,
<a name="l00465"></a>00465         <span class="stringliteral">&quot;file&quot;</span>,
<a name="l00466"></a>00466         <span class="stringliteral">&quot;rmfile&quot;</span>,
<a name="l00467"></a>00467         <span class="stringliteral">&quot;symlink&quot;</span>,
<a name="l00468"></a>00468         <span class="stringliteral">&quot;rmsymlink&quot;</span>,
<a name="l00469"></a>00469         <span class="stringliteral">&quot;sync&quot;</span>,
<a name="l00470"></a>00470         <span class="stringliteral">&quot;close&quot;</span>,
<a name="l00471"></a>00471         <span class="stringliteral">&quot;read&quot;</span>,
<a name="l00472"></a>00472         <span class="stringliteral">&quot;write&quot;</span>,
<a name="l00473"></a>00473         <span class="stringliteral">&quot;truncate&quot;</span>,
<a name="l00474"></a>00474         <span class="stringliteral">&quot;barrier&quot;</span>,
<a name="l00475"></a>00475         <span class="stringliteral">&quot;enumerate&quot;</span>,
<a name="l00476"></a>00476         <span class="stringliteral">&quot;adopt&quot;</span>,
<a name="l00477"></a>00477         <span class="stringliteral">&quot;zero&quot;</span>,
<a name="l00478"></a>00478         <span class="stringliteral">&quot;extents&quot;</span>,
<a name="l00479"></a>00479         <span class="stringliteral">&quot;statfs&quot;</span>
<a name="l00480"></a>00480     };
<a name="l00481"></a>00481     static_assert(static_cast&lt;size_t&gt;(OpType::Last)==<span class="keyword">sizeof</span>(optypes)/<span class="keyword">sizeof</span>(*optypes), <span class="stringliteral">&quot;You forgot to fix up the strings matching OpType&quot;</span>);
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="keyword">class </span><a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>;
<a name="l00485"></a>00485 
<a name="l00490"></a>00490 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00491"></a><a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">00491</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>
<a name="l00492"></a>00492 <span class="preprocessor">#else</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> : size_t
<a name="l00494"></a>00494 <span class="preprocessor">#endif</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>{
<a name="l00496"></a>00496     <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>=0,
<a name="l00497"></a>00497     dev=1&lt;&lt;0,
<a name="l00498"></a>00498     ino=1&lt;&lt;1,
<a name="l00499"></a>00499     type=1&lt;&lt;2,
<a name="l00500"></a>00500     perms=1&lt;&lt;3,
<a name="l00501"></a>00501     nlink=1&lt;&lt;4,
<a name="l00502"></a>00502     uid=1&lt;&lt;5,
<a name="l00503"></a>00503     gid=1&lt;&lt;6,
<a name="l00504"></a>00504     rdev=1&lt;&lt;7,
<a name="l00505"></a>00505     atim=1&lt;&lt;8,
<a name="l00506"></a>00506     mtim=1&lt;&lt;9,
<a name="l00507"></a>00507     ctim=1&lt;&lt;10,
<a name="l00508"></a>00508     size=1&lt;&lt;11,
<a name="l00509"></a>00509     allocated=1&lt;&lt;12,
<a name="l00510"></a>00510     blocks=1&lt;&lt;13,
<a name="l00511"></a>00511     blksize=1&lt;&lt;14,
<a name="l00512"></a>00512     flags=1&lt;&lt;15,
<a name="l00513"></a>00513     gen=1&lt;&lt;16,
<a name="l00514"></a>00514     birthtim=1&lt;&lt;17,
<a name="l00515"></a>00515     sparse=1&lt;&lt;24,
<a name="l00516"></a>00516     compressed=1&lt;&lt;25,
<a name="l00517"></a><a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4ea911a49b7967ef10985d331841303b75f">00517</a>     <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4ea911a49b7967ef10985d331841303b75f" title="Return the maximum possible metadata.">All</a>=(size_t)-1       
<a name="l00518"></a>00518 };
<a name="l00519"></a>00519 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>)
<a name="l00539"></a><a class="code" href="structstat__t.html">00539</a> struct <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a>
<a name="l00540"></a>00540 {
<a name="l00541"></a>00541 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00542"></a><a class="code" href="structstat__t.html#a7487cc455af320b602f8d334a15a1c3a">00542</a> <span class="preprocessor"></span>    uint64_t        <a class="code" href="structstat__t.html#a7487cc455af320b602f8d334a15a1c3a">st_dev</a>;                       
<a name="l00543"></a>00543 <span class="preprocessor">#endif</span>
<a name="l00544"></a><a class="code" href="structstat__t.html#af53eaec5ef5bf1b290f2dbb94af599c8">00544</a> <span class="preprocessor"></span>    uint64_t        <a class="code" href="structstat__t.html#af53eaec5ef5bf1b290f2dbb94af599c8">st_ino</a>;                       
<a name="l00545"></a><a class="code" href="structstat__t.html#a55e15f3a42407c84aacc348017ca8ab6">00545</a>     filesystem::file_type <a class="code" href="structstat__t.html#a55e15f3a42407c84aacc348017ca8ab6">st_type</a>;                
<a name="l00546"></a>00546 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00547"></a>00547 <span class="preprocessor"></span><span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span>    uint16_t        st_perms;
<a name="l00549"></a>00549 <span class="preprocessor">#else</span>
<a name="l00550"></a><a class="code" href="structstat__t.html#abf305545fb9145073630d52c8a6003bc">00550</a> <span class="preprocessor"></span>    filesystem::perms <a class="code" href="structstat__t.html#abf305545fb9145073630d52c8a6003bc">st_perms</a>;                   
<a name="l00551"></a>00551 <span class="preprocessor">#endif</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00553"></a><a class="code" href="structstat__t.html#a19fed1af49a87be2ad39e3e1ddf4cde2">00553</a> <span class="preprocessor"></span>    int16_t         <a class="code" href="structstat__t.html#a19fed1af49a87be2ad39e3e1ddf4cde2">st_nlink</a>;                     
<a name="l00554"></a>00554 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00555"></a><a class="code" href="structstat__t.html#a0dafe518808f57a98f45361d42c9fe1f">00555</a> <span class="preprocessor"></span>    int16_t         <a class="code" href="structstat__t.html#a0dafe518808f57a98f45361d42c9fe1f">st_uid</a>;                       
<a name="l00556"></a><a class="code" href="structstat__t.html#ac928ac17d09faca0745d78e2eaceb13d">00556</a>     int16_t         <a class="code" href="structstat__t.html#ac928ac17d09faca0745d78e2eaceb13d">st_gid</a>;                       
<a name="l00557"></a><a class="code" href="structstat__t.html#a900c604b7b01f3b7a3dc3753c23ca41c">00557</a>     dev_t           <a class="code" href="structstat__t.html#a900c604b7b01f3b7a3dc3753c23ca41c">st_rdev</a>;                      
<a name="l00558"></a>00558 <span class="preprocessor">#endif</span>
<a name="l00559"></a><a class="code" href="structstat__t.html#aa78500f915a48ddf7a30eef9b5129d02">00559</a> <span class="preprocessor"></span>    chrono::system_clock::time_point <a class="code" href="structstat__t.html#aa78500f915a48ddf7a30eef9b5129d02">st_atim</a>;     
<a name="l00560"></a><a class="code" href="structstat__t.html#afe057e9458ea89ec8934f89c81300c8d">00560</a>     chrono::system_clock::time_point <a class="code" href="structstat__t.html#afe057e9458ea89ec8934f89c81300c8d">st_mtim</a>;     
<a name="l00561"></a><a class="code" href="structstat__t.html#a680581c4f03e2caccdbdfe21b8fc0929">00561</a>     chrono::system_clock::time_point <a class="code" href="structstat__t.html#a680581c4f03e2caccdbdfe21b8fc0929">st_ctim</a>;     
<a name="l00562"></a><a class="code" href="structstat__t.html#a7ebcf73d7edf079832744627f070665d">00562</a>     off_t           <a class="code" href="structstat__t.html#a7ebcf73d7edf079832744627f070665d">st_size</a>;                      
<a name="l00563"></a><a class="code" href="structstat__t.html#a0348936b7cadfe816e0105bcc256dd29">00563</a>     off_t           <a class="code" href="structstat__t.html#a0348936b7cadfe816e0105bcc256dd29">st_allocated</a>;                 
<a name="l00564"></a><a class="code" href="structstat__t.html#a1239310ac61bbdc1eda835321876a718">00564</a>     off_t           <a class="code" href="structstat__t.html#a1239310ac61bbdc1eda835321876a718">st_blocks</a>;                    
<a name="l00565"></a><a class="code" href="structstat__t.html#aa530698a20aa20fedfe0c205d0bcc674">00565</a>     uint16_t        <a class="code" href="structstat__t.html#aa530698a20aa20fedfe0c205d0bcc674">st_blksize</a>;                   
<a name="l00566"></a><a class="code" href="structstat__t.html#a796bc31527577465b0dd3c9fbc771961">00566</a>     uint32_t        <a class="code" href="structstat__t.html#a796bc31527577465b0dd3c9fbc771961">st_flags</a>;                     
<a name="l00567"></a><a class="code" href="structstat__t.html#a2524d9bce9db23cd67fb16df52e4abc0">00567</a>     uint32_t        <a class="code" href="structstat__t.html#a2524d9bce9db23cd67fb16df52e4abc0">st_gen</a>;                       
<a name="l00568"></a><a class="code" href="structstat__t.html#a1ebba916806061ad29be6b39f0268f9b">00568</a>     chrono::system_clock::time_point <a class="code" href="structstat__t.html#a1ebba916806061ad29be6b39f0268f9b">st_birthtim</a>; 
<a name="l00570"></a><a class="code" href="structstat__t.html#aa6370e9b502218538f954aa984160fc4">00570</a>     <span class="keywordtype">unsigned</span>        st_sparse : 1;                
<a name="l00571"></a><a class="code" href="structstat__t.html#a8f3b78e7beaceb2b1f54d9ad61f3d365">00571</a>     <span class="keywordtype">unsigned</span>        st_compressed : 1;            
<a name="l00573"></a>00573 
<a name="l00574"></a><a class="code" href="structstat__t.html#a2765906190447535fa13532c8844a15e">00574</a>     <a class="code" href="structstat__t.html#a2765906190447535fa13532c8844a15e" title="Constructs a UNINITIALIZED instance i.e. full of random garbage.">stat_t</a>() { }
<a name="l00576"></a><a class="code" href="structstat__t.html#a8775018b5d9221d1da0e6e2c72e45da3">00576</a>     stat_t(std::nullptr_t) :
<a name="l00577"></a>00577 #ifndef WIN32
<a name="l00578"></a>00578         st_dev(0),
<a name="l00579"></a>00579 #endif
<a name="l00580"></a>00580         st_ino(0),
<a name="l00581"></a>00581 #ifdef BOOST_AFIO_USE_LEGACY_FILESYSTEM_SEMANTICS
<a name="l00582"></a>00582         st_type(filesystem::file_type::type_unknown),
<a name="l00583"></a>00583 #else
<a name="l00584"></a>00584         st_type(filesystem::file_type::unknown),
<a name="l00585"></a>00585 #endif
<a name="l00586"></a>00586 #ifndef WIN32
<a name="l00587"></a>00587         st_perms(0),
<a name="l00588"></a>00588 #endif
<a name="l00589"></a>00589         st_nlink(0),
<a name="l00590"></a>00590 #ifndef WIN32
<a name="l00591"></a>00591         st_uid(0), st_gid(0), st_rdev(0),
<a name="l00592"></a>00592 #endif
<a name="l00593"></a>00593         st_size(0), st_allocated(0), st_blocks(0), st_blksize(0), st_flags(0), st_gen(0), st_sparse(0), st_compressed(0) { }
<a name="l00594"></a>00594 };
<a name="l00595"></a>00595 
<a name="l00600"></a>00600 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00601"></a><a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e">00601</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e" title="Bitflags for availability of metadata from `struct statfs_t`.">fs_metadata_flags</a>
<a name="l00602"></a>00602 <span class="preprocessor">#else</span>
<a name="l00603"></a>00603 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e" title="Bitflags for availability of metadata from `struct statfs_t`.">fs_metadata_flags</a> : size_t
<a name="l00604"></a>00604 <span class="preprocessor">#endif</span>
<a name="l00605"></a>00605 <span class="preprocessor"></span>{
<a name="l00606"></a>00606     <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>=0,
<a name="l00607"></a>00607     flags=1&lt;&lt;1,
<a name="l00608"></a>00608     bsize=1&lt;&lt;2,
<a name="l00609"></a>00609     iosize=1&lt;&lt;3,
<a name="l00610"></a>00610     blocks=1&lt;&lt;4,
<a name="l00611"></a>00611     bfree=1&lt;&lt;5,
<a name="l00612"></a>00612     bavail=1&lt;&lt;6,
<a name="l00613"></a>00613     files=1&lt;&lt;7,
<a name="l00614"></a>00614     ffree=1&lt;&lt;8,
<a name="l00615"></a>00615     namemax=1&lt;&lt;9,
<a name="l00616"></a>00616     owner=1&lt;&lt;10,
<a name="l00617"></a>00617     fsid=1&lt;&lt;11,
<a name="l00618"></a>00618     fstypename=1&lt;&lt;12,
<a name="l00619"></a>00619     mntfromname=1&lt;&lt;13,
<a name="l00620"></a>00620     mntonname=1&lt;&lt;14,
<a name="l00621"></a>00621     <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4ea911a49b7967ef10985d331841303b75f" title="Return the maximum possible metadata.">All</a>=(size_t)-1       
<a name="l00622"></a>00622 };
<a name="l00623"></a>00623 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e" title="Bitflags for availability of metadata from `struct statfs_t`.">fs_metadata_flags</a>)
<a name="l00627"></a><a class="code" href="structstatfs__t.html">00627</a> struct <a class="code" href="structstatfs__t.html" title="Metadata about a filing system. Unsupported entries are -1.">statfs_t</a>
<a name="l00628"></a>00628 {
<a name="l00629"></a>00629      <span class="keyword">struct</span>
<a name="l00630"></a>00630      {
<a name="l00631"></a><a class="code" href="structstatfs__t.html#a2a31bb0f0da0782cf247b6fd7d3cafca">00631</a>         uint32_t rdonly : 1;          
<a name="l00632"></a><a class="code" href="structstatfs__t.html#a1b0b6e924279930095c3299783ca0a75">00632</a>         uint32_t noexec : 1;          
<a name="l00633"></a><a class="code" href="structstatfs__t.html#a3e9effdf59e46feb2a0eb84be716c259">00633</a>         uint32_t nosuid : 1;          
<a name="l00634"></a><a class="code" href="structstatfs__t.html#af19624974016a756b62bbe502e84d2ac">00634</a>         uint32_t acls : 1;            
<a name="l00635"></a><a class="code" href="structstatfs__t.html#a92a803183380020fae0ae9bacccd0e48">00635</a>         uint32_t xattr : 1;           
<a name="l00636"></a><a class="code" href="structstatfs__t.html#a2e348f3384a0d984a92a6a7ffe6448c2">00636</a>         uint32_t compression : 1;     
<a name="l00637"></a><a class="code" href="structstatfs__t.html#a9ef58579672c4315e31dcaf299f35844">00637</a>         uint32_t extents : 1;         
<a name="l00638"></a><a class="code" href="structstatfs__t.html#a0cc8f58d47fd8249096e9fc48409f62b">00638</a>         uint32_t filecompression : 1; 
<a name="l00639"></a>00639      } f_flags;                           
<a name="l00640"></a><a class="code" href="structstatfs__t.html#aee9fadff9b0713740f14a1927a8704d6">00640</a>      uint64_t <a class="code" href="structstatfs__t.html#aee9fadff9b0713740f14a1927a8704d6">f_bsize</a>;                    
<a name="l00641"></a><a class="code" href="structstatfs__t.html#a3abc51f00039339f335c2796945ed6ae">00641</a>      uint64_t <a class="code" href="structstatfs__t.html#a3abc51f00039339f335c2796945ed6ae">f_iosize</a>;                   
<a name="l00642"></a><a class="code" href="structstatfs__t.html#a4ef590760748dc56a40e4e962b63880a">00642</a>      uint64_t <a class="code" href="structstatfs__t.html#a4ef590760748dc56a40e4e962b63880a">f_blocks</a>;                   
<a name="l00643"></a><a class="code" href="structstatfs__t.html#a5b03fea5813c767fdc5d1c60a8d18aa1">00643</a>      uint64_t <a class="code" href="structstatfs__t.html#a5b03fea5813c767fdc5d1c60a8d18aa1">f_bfree</a>;                    
<a name="l00644"></a><a class="code" href="structstatfs__t.html#a14101c07041f716fbb26b7142577500d">00644</a>      uint64_t <a class="code" href="structstatfs__t.html#a14101c07041f716fbb26b7142577500d">f_bavail</a>;                   
<a name="l00645"></a><a class="code" href="structstatfs__t.html#ac9806012f3fd15beacb95713795dda22">00645</a>      uint64_t <a class="code" href="structstatfs__t.html#ac9806012f3fd15beacb95713795dda22">f_files</a>;                    
<a name="l00646"></a><a class="code" href="structstatfs__t.html#a8746a8f4ec947f1e3c293a7ac7d90d17">00646</a>      uint64_t <a class="code" href="structstatfs__t.html#a8746a8f4ec947f1e3c293a7ac7d90d17">f_ffree</a>;                    
<a name="l00647"></a><a class="code" href="structstatfs__t.html#a3ffdfb9de5ecba363ffbfcc4a90a7721">00647</a>      uint32_t <a class="code" href="structstatfs__t.html#a3ffdfb9de5ecba363ffbfcc4a90a7721">f_namemax</a>;                  
<a name="l00648"></a>00648 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00649"></a><a class="code" href="structstatfs__t.html#a73b0d6df39f7a3ac05788353f51b0609">00649</a> <span class="preprocessor"></span>     int16_t  <a class="code" href="structstatfs__t.html#a73b0d6df39f7a3ac05788353f51b0609">f_owner</a>;                    
<a name="l00650"></a>00650 <span class="preprocessor">#endif</span>
<a name="l00651"></a><a class="code" href="structstatfs__t.html#aff72e9225ad8dbbf0b9f5de539ca8686">00651</a> <span class="preprocessor"></span>     uint64_t f_fsid[2];                  
<a name="l00652"></a><a class="code" href="structstatfs__t.html#ad59f897f47efd1c8a705d1a607023e16">00652</a>      std::string <a class="code" href="structstatfs__t.html#ad59f897f47efd1c8a705d1a607023e16">f_fstypename</a>;            
<a name="l00653"></a><a class="code" href="structstatfs__t.html#aa76d5399752e1ad357775666c5537096">00653</a>      std::string <a class="code" href="structstatfs__t.html#aa76d5399752e1ad357775666c5537096">f_mntfromname</a>;           
<a name="l00654"></a><a class="code" href="structstatfs__t.html#a2f2cf2c80b716736a827d2fda20a48c1">00654</a>      filesystem::path <a class="code" href="structstatfs__t.html#a2f2cf2c80b716736a827d2fda20a48c1">f_mntonname</a>;        
<a name="l00655"></a>00655      statfs_t()
<a name="l00656"></a>00656      {
<a name="l00657"></a>00657        <span class="keywordtype">size_t</span> frontbytes=((<span class="keywordtype">char</span> *) &amp;f_fstypename)-((<span class="keywordtype">char</span> *) <span class="keyword">this</span>);
<a name="l00658"></a>00658        memset(<span class="keyword">this</span>, 0xff, frontbytes);
<a name="l00659"></a>00659        memset(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(f_flags));
<a name="l00660"></a>00660      }
<a name="l00661"></a>00661 };
<a name="l00662"></a>00662 
<a name="l00668"></a><a class="code" href="classdirectory__entry.html">00668</a> <span class="keyword">class </span>BOOST_AFIO_DECL <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_compat;
<a name="l00671"></a>00671     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_windows;
<a name="l00672"></a>00672     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_linux;
<a name="l00673"></a>00673     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_qnx;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675     filesystem::path leafname;
<a name="l00676"></a>00676     <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> stat;
<a name="l00677"></a>00677     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> have_metadata;
<a name="l00678"></a>00678     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> _int_fetch(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted, std::shared_ptr&lt;async_io_handle&gt; dirh);
<a name="l00679"></a>00679 <span class="keyword">public</span>:
<a name="l00681"></a><a class="code" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958">00681</a>     <a class="code" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958" title="Default constructor.">directory_entry</a>() : stat(nullptr), have_metadata(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>::<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>) { }
<a name="l00683"></a><a class="code" href="classdirectory__entry.html#a9f9450830547a63eb719ca01b37c4325">00683</a>     <a class="code" href="classdirectory__entry.html#a9f9450830547a63eb719ca01b37c4325" title="Default constructor.">directory_entry</a>(filesystem::path _leafname, <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> __stat, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _have_metadata) : leafname(_leafname), stat(__stat), have_metadata(_have_metadata) { }
<a name="l00684"></a>00684     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;) = <span class="keywordflow">default</span>;
<a name="l00685"></a>00685     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;) = <span class="keywordflow">default</span>;
<a name="l00686"></a>00686     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>(<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;&amp;o) : leafname(std::move(o.leafname)), stat(std::move(o.stat)), have_metadata(std::move(o.have_metadata)) { }
<a name="l00687"></a>00687     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;operator=(<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;&amp;o)
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689         leafname=std::move(o.leafname);
<a name="l00690"></a>00690         stat=std::move(o.stat);
<a name="l00691"></a>00691         have_metadata=std::move(o.have_metadata);
<a name="l00692"></a>00692         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname == rhs.leafname; }
<a name="l00696"></a>00696     <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname != rhs.leafname; }
<a name="l00697"></a>00697     <span class="keywordtype">bool</span> operator&lt; (<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &lt; rhs.leafname; }
<a name="l00698"></a>00698     <span class="keywordtype">bool</span> operator&lt;=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &lt;= rhs.leafname; }
<a name="l00699"></a>00699     <span class="keywordtype">bool</span> operator&gt; (<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &gt; rhs.leafname; }
<a name="l00700"></a>00700     <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &gt;= rhs.leafname; }
<a name="l00702"></a><a class="code" href="classdirectory__entry.html#a99c7aa29c44148401588fb680ab44334">00702</a>     filesystem::path <a class="code" href="classdirectory__entry.html#a99c7aa29c44148401588fb680ab44334">name</a>() const BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname; }
<a name="l00704"></a><a class="code" href="classdirectory__entry.html#a67bdc31854318138ba9c34d8469f6b1c">00704</a>     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> <a class="code" href="classdirectory__entry.html#a67bdc31854318138ba9c34d8469f6b1c">metadata_ready</a>() const BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> have_metadata; }
<a name="l00710"></a><a class="code" href="classdirectory__entry.html#a3ad8cabe9b14690a2f0eb7776d556458">00710</a>     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> fetch_metadata(std::shared_ptr&lt;async_io_handle&gt; dirh, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted)
<a name="l00711"></a>00711     {
<a name="l00712"></a>00712         <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> tofetch;
<a name="l00713"></a>00713         wanted=wanted&amp;metadata_supported();
<a name="l00714"></a>00714         tofetch=wanted&amp;~have_metadata;
<a name="l00715"></a>00715         <span class="keywordflow">if</span>(!!tofetch) _int_fetch(tofetch, dirh);
<a name="l00716"></a>00716         <span class="keywordflow">return</span> have_metadata;
<a name="l00717"></a>00717     }
<a name="l00723"></a><a class="code" href="classdirectory__entry.html#a82c821341533ccd6e7a6841f0df62362">00723</a>     <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> fetch_lstat(std::shared_ptr&lt;async_io_handle&gt; dirh, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted=<a class="code" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3" title="A bitfield of what metadata is fast on this platform. This doesn&#39;t mean all is available for every fi...">directory_entry::metadata_fastpath</a>())
<a name="l00724"></a>00724     {
<a name="l00725"></a>00725         fetch_metadata(dirh, wanted);
<a name="l00726"></a>00726         <span class="keywordflow">return</span> stat;
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(field) \</span>
<a name="l00730"></a>00730 <span class="preprocessor">decltype(stat_t().st_##field) st_##field() const { if(!(have_metadata&amp;metadata_flags::field)) { BOOST_AFIO_THROW(std::runtime_error(&quot;Field st_&quot; #field &quot; not present.&quot;)); } return stat.st_##field; } \</span>
<a name="l00731"></a>00731 <span class="preprocessor">decltype(stat_t().st_##field) st_##field(std::shared_ptr&lt;async_io_handle&gt; dirh) { if(!(have_metadata&amp;metadata_flags::field)) { _int_fetch(metadata_flags::field, dirh); } return stat.st_##field; }</span>
<a name="l00732"></a>00732 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(field) \</span>
<a name="l00734"></a>00734 <span class="preprocessor">fieldtype st_##field(std::shared_ptr&lt;async_io_handle&gt; dirh=std::shared_ptr&lt;async_io_handle&gt;()) { if(!(have_metadata&amp;metadata_flags::field)) { _int_fetch(metadata_flags::field, dirh); } return stat.st_##field; }</span>
<a name="l00735"></a>00735 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span><span class="preprocessor">#ifndef WIN32</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span>
<a name="l00738"></a><a class="code" href="classdirectory__entry.html#ab9fe9a795efa2479cde43919af0d4289">00738</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(dev)
<a name="l00739"></a>00739 <span class="preprocessor">#endif</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>
<a name="l00741"></a><a class="code" href="classdirectory__entry.html#aa668bf3b3f0e2825244214ab6fdb7b70">00741</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(ino)
<a name="l00743"></a><a class="code" href="classdirectory__entry.html#a04f94fc6f5b03fba8afd4b82866211a3">00743</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(type)
<a name="l00744"></a>00744 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00745"></a>00745 <span class="preprocessor"></span>
<a name="l00746"></a><a class="code" href="classdirectory__entry.html#a4e302e731c846a58c2f767a83c68f14e">00746</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(perms)
<a name="l00747"></a>00747 <span class="preprocessor">#endif</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span>
<a name="l00749"></a><a class="code" href="classdirectory__entry.html#a014d472a4bff85d7a182756e3c0f9824">00749</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(nlink)
<a name="l00750"></a>00750 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00751"></a>00751 <span class="preprocessor"></span>
<a name="l00752"></a><a class="code" href="classdirectory__entry.html#aef4bb48fb46e6c78dc1ad2aeda4681a9">00752</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(uid)
<a name="l00754"></a><a class="code" href="classdirectory__entry.html#a30cf008e632ad3c0590d5d5433b11d52">00754</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(gid)
<a name="l00756"></a><a class="code" href="classdirectory__entry.html#a1eb27dc286a7614ab5b06c08b4dba60e">00756</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(rdev)
<a name="l00757"></a>00757 <span class="preprocessor">#endif</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span>
<a name="l00759"></a><a class="code" href="classdirectory__entry.html#abdd2752820b4f89ca615a6ab93ce3a06">00759</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(atim)
<a name="l00761"></a><a class="code" href="classdirectory__entry.html#a15c133f6acd511e518fcf213711b24e8">00761</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(mtim)
<a name="l00763"></a><a class="code" href="classdirectory__entry.html#a92de110c65ccc52b2f009c1d17e2c428">00763</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(ctim)
<a name="l00765"></a><a class="code" href="classdirectory__entry.html#ac7928966ebc20bc4e2b73321c8d3cf2b">00765</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(size)
<a name="l00767"></a><a class="code" href="classdirectory__entry.html#aaa7dfff87e368bb138676c2f8e194314">00767</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(allocated)
<a name="l00769"></a><a class="code" href="classdirectory__entry.html#a931b760be9308d5a20161713f63e2529">00769</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(blocks)
<a name="l00771"></a><a class="code" href="classdirectory__entry.html#a43ff38c6d1d1da845db602411ec3b3fb">00771</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(blksize)
<a name="l00773"></a><a class="code" href="classdirectory__entry.html#a5a1961a9215593f7f11ace287afa4001">00773</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(flags)
<a name="l00775"></a><a class="code" href="classdirectory__entry.html#a5bea44318235f6e0937d9e68dcc66aea">00775</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(gen)
<a name="l00777"></a><a class="code" href="classdirectory__entry.html#a98a8615a9123218b9aeaa195b7179486">00777</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(birthtim)
<a name="l00778"></a>00778 
<a name="l00780"></a>00780     static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> metadata_supported() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l00782"></a>00782     static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> metadata_fastpath() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l00784"></a>00784     static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> compatibility_maximum() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l00785"></a>00785 };
<a name="l00786"></a>00786 
<a name="l00789"></a><a class="code" href="structdirectory__entry__hash.html">00789</a> struct <a class="code" href="structdirectory__entry__hash.html" title="A hasher for directory_entry, hashing inode and birth time (if available on this platform).">directory_entry_hash</a>
<a name="l00790"></a>00790 {
<a name="l00791"></a>00791 <span class="keyword">public</span>:
<a name="l00792"></a>00792     <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;p)<span class="keyword"> const</span>
<a name="l00793"></a>00793 <span class="keyword">    </span>{
<a name="l00794"></a>00794         <span class="keywordtype">size_t</span> seed = (size_t) 0x9ddfea08eb382d69ULL;
<a name="l00795"></a>00795         detail::hash_combine(seed, p.<a class="code" href="classdirectory__entry.html#aa668bf3b3f0e2825244214ab6fdb7b70" title="Returns st_ino.">st_ino</a>());
<a name="l00796"></a>00796         <span class="keywordflow">if</span>(!!(<a class="code" href="classdirectory__entry.html#ac111d690ae103454c2c48c873b37ba77" title="A bitfield of what metadata is available on this platform. This doesn&#39;t mean all is available for eve...">directory_entry::metadata_supported</a>() &amp; metadata_flags::birthtim))
<a name="l00797"></a>00797             detail::hash_combine(seed, p.<a class="code" href="classdirectory__entry.html#a98a8615a9123218b9aeaa195b7179486" title="Returns st_birthtim.">st_birthtim</a>().time_since_epoch().count());
<a name="l00798"></a>00798         <span class="keywordflow">return</span> seed;
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800 };
<a name="l00801"></a>00801 
<a name="l00804"></a><a class="code" href="classasync__io__handle.html">00804</a> <span class="keyword">class </span><a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> : <span class="keyword">public</span> std::enable_shared_from_this&lt;async_io_handle&gt;
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806     <span class="keyword">friend</span> <span class="keyword">class </span>async_file_io_dispatcher_base;
<a name="l00807"></a>00807     <span class="keyword">friend</span> <span class="keyword">struct </span>async_io_handle_posix;
<a name="l00808"></a>00808     <span class="keyword">friend</span> <span class="keyword">struct </span>async_io_handle_windows;
<a name="l00809"></a>00809     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_compat;
<a name="l00810"></a>00810     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_windows;
<a name="l00811"></a>00811     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_linux;
<a name="l00812"></a>00812     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_qnx;
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     async_file_io_dispatcher_base *_parent;
<a name="l00815"></a>00815     std::shared_ptr&lt;async_io_handle&gt; dirh;
<a name="l00816"></a>00816     chrono::system_clock::time_point _opened;
<a name="l00817"></a>00817     filesystem::path _path; <span class="comment">// guaranteed canonical</span>
<a name="l00818"></a>00818     <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags;
<a name="l00819"></a>00819 <span class="keyword">protected</span>:
<a name="l00820"></a>00820     atomic&lt;off_t&gt; bytesread, byteswritten, byteswrittenatlastfsync;
<a name="l00821"></a>00821     <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>(async_file_io_dispatcher_base *parent, std::shared_ptr&lt;async_io_handle&gt; _dirh, <span class="keyword">const</span> filesystem::path &amp;path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flags) : _parent(parent), dirh(std::move(_dirh)), _opened(chrono::system_clock::now()), _path(path), _flags(flags), bytesread(0), byteswritten(0), byteswrittenatlastfsync(0) { }
<a name="l00822"></a>00822     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <span class="keywordtype">void</span> close() BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00823"></a>00823 <span class="keyword">public</span>:
<a name="l00824"></a>00824     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>() { }
<a name="l00826"></a><a class="code" href="classasync__io__handle.html#aac13ab5def49a2405995ff6d11032076">00826</a>     async_file_io_dispatcher_base *<a class="code" href="classasync__io__handle.html#aac13ab5def49a2405995ff6d11032076" title="Returns the parent of this io handle.">parent</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _parent; }
<a name="l00828"></a><a class="code" href="classasync__io__handle.html#ae8574073fc1b0a67bcd46ddf9e9ae873">00828</a>     std::shared_ptr&lt;async_io_handle&gt; <a class="code" href="classasync__io__handle.html#ae8574073fc1b0a67bcd46ddf9e9ae873" title="Returns a handle to the directory containing this handle. Only works if `file_flagsFastDirectoryEnume...">container</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dirh; }
<a name="l00830"></a>00830     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <span class="keywordtype">void</span> *native_handle() const BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00832"></a><a class="code" href="classasync__io__handle.html#a89dd90d83b0c5902c561e4463abd97d5">00832</a>     const chrono::system_clock::time_point &amp;opened()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _opened; }
<a name="l00834"></a><a class="code" href="classasync__io__handle.html#ac797c31edac57f4a972d8bb3c0305cab">00834</a>     <span class="keyword">const</span> filesystem::path &amp;<a class="code" href="classasync__io__handle.html#ac797c31edac57f4a972d8bb3c0305cab" title="Returns the path of this io handle.">path</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _path; }
<a name="l00836"></a><a class="code" href="classasync__io__handle.html#aea1a9240f90cfa6ac551df5dcc546898">00836</a>     <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> <a class="code" href="classasync__io__handle.html#aea1a9240f90cfa6ac551df5dcc546898" title="Returns the final flags used when this handle was opened.">flags</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _flags; }
<a name="l00838"></a><a class="code" href="classasync__io__handle.html#a0f7d6ffefd528ee85aa217bc8d80baca">00838</a>     <span class="keywordtype">bool</span> <a class="code" href="classasync__io__handle.html#a0f7d6ffefd528ee85aa217bc8d80baca" title="True if this handle was opened as a file.">opened_as_file</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d" title="Internal use only. Don&#39;t use.">file_flags::int_opening_dir</a>) &amp;&amp; !(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3" title="Internal use only. Don&#39;t use.">file_flags::int_opening_link</a>); }
<a name="l00840"></a><a class="code" href="classasync__io__handle.html#a0a5d04f3f3ff7eefabed1d6af4fe8c52">00840</a>     <span class="keywordtype">bool</span> <a class="code" href="classasync__io__handle.html#a0a5d04f3f3ff7eefabed1d6af4fe8c52" title="True if this handle was opened as a directory.">opened_as_dir</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !!(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d" title="Internal use only. Don&#39;t use.">file_flags::int_opening_dir</a>); }
<a name="l00842"></a><a class="code" href="classasync__io__handle.html#a259cca5d1e6a40b77bf33e433bcae863">00842</a>     <span class="keywordtype">bool</span> <a class="code" href="classasync__io__handle.html#a259cca5d1e6a40b77bf33e433bcae863" title="True if this handle was opened as a symlink.">opened_as_symlink</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !!(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3" title="Internal use only. Don&#39;t use.">file_flags::int_opening_link</a>); }
<a name="l00844"></a><a class="code" href="classasync__io__handle.html#ac632d5739145e2139b4af93220c324f4">00844</a>     off_t <a class="code" href="classasync__io__handle.html#ac632d5739145e2139b4af93220c324f4" title="Returns how many bytes have been read since this handle was opened.">read_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bytesread; }
<a name="l00846"></a><a class="code" href="classasync__io__handle.html#a0320961d4e319ecd5a297b2e21da2cfb">00846</a>     off_t <a class="code" href="classasync__io__handle.html#a0320961d4e319ecd5a297b2e21da2cfb" title="Returns how many bytes have been written since this handle was opened.">write_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> byteswritten; }
<a name="l00848"></a><a class="code" href="classasync__io__handle.html#a096a1f09f761f5f04634b02586b4251e">00848</a>     off_t <a class="code" href="classasync__io__handle.html#a096a1f09f761f5f04634b02586b4251e" title="Returns how many bytes have been written since this handle was last fsynced.">write_count_since_fsync</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> byteswritten-byteswrittenatlastfsync; }
<a name="l00850"></a>00850     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> direntry(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted=<a class="code" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3" title="A bitfield of what metadata is fast on this platform. This doesn&#39;t mean all is available for every fi...">directory_entry::metadata_fastpath</a>()) const BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00852"></a><a class="code" href="classasync__io__handle.html#a87d756f9f38ee299dc404398576237f4">00852</a>     <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> lstat(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted=<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>::metadata_fastpath())<span class="keyword"> const</span>
<a name="l00853"></a>00853 <span class="keyword">    </span>{
<a name="l00854"></a>00854         <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> de(direntry(wanted));
<a name="l00855"></a>00855         <span class="keywordflow">return</span> de.<a class="code" href="classdirectory__entry.html#a82c821341533ccd6e7a6841f0df62362" title="Returns a copy of the internal `stat_t` structure. This is a blocking call if wanted metadata is not ...">fetch_lstat</a>(std::shared_ptr&lt;async_io_handle&gt;() <span class="comment">/* actually unneeded */</span>, wanted);
<a name="l00856"></a>00856     }
<a name="l00858"></a>00858     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC filesystem::path target() const BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00860"></a>00860     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <span class="keywordtype">void</span> *try_mapfile() BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00861"></a>00861 };
<a name="l00862"></a>00862 
<a name="l00868"></a><a class="code" href="structasync__io__op.html">00868</a> struct <a class="code" href="structasync__io__op.html" title="A reference to an asynchronous operation.">async_io_op</a>
<a name="l00869"></a>00869 {
<a name="l00870"></a><a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19">00870</a>     async_file_io_dispatcher_base *<a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19" title="The parent dispatcher.">parent</a>;              
<a name="l00871"></a><a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df">00871</a>     <span class="keywordtype">size_t</span> <a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df" title="A unique id for this operation.">id</a>;                                          
<a name="l00872"></a>00872     shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; h;  
<a name="l00873"></a>00873 
<a name="l00875"></a>00875     async_io_op() : parent(nullptr), id(0), h(shared_future&lt;std::shared_ptr&lt;<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>&gt;&gt;()) { }
<a name="l00877"></a>00877 <span class="preprocessor">#if 0 // used to find where std::move() isn&#39;t being used, and should be</span>
<a name="l00878"></a>00878 <span class="preprocessor"></span>    <span class="comment">//async_io_op(const async_io_op &amp;o);</span>
<a name="l00879"></a>00879 <span class="preprocessor">#else</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>    async_io_op(<span class="keyword">const</span> async_io_op &amp;o) : parent(o.parent), id(o.id), h(o.h) { }
<a name="l00881"></a>00881 <span class="preprocessor">#endif</span>
<a name="l00882"></a>00882 <span class="preprocessor"></span>
<a name="l00883"></a>00883     async_io_op(async_io_op &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : parent(std::move(o.parent)), <span class="keywordtype">id</span>(std::move(o.<span class="keywordtype">id</span>)), h(std::move(o.h)) { }
<a name="l00891"></a>00891     async_io_op(async_file_io_dispatcher_base *_parent, <span class="keywordtype">size_t</span> _id, shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; _handle, <span class="keywordtype">bool</span> check_handle=<span class="keyword">true</span>, <span class="keywordtype">bool</span> validate=<span class="keyword">true</span>) : parent(_parent), id(_id), h(std::move(_handle)) { <span class="keywordflow">if</span>(validate) _validate(check_handle); }
<a name="l00896"></a>00896     async_io_op(async_file_io_dispatcher_base *_parent, <span class="keywordtype">size_t</span> _id) : parent(_parent), id(_id), h(shared_future&lt;std::shared_ptr&lt;<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>&gt;&gt;()) { }
<a name="l00898"></a>00898     async_io_op &amp;operator=(<span class="keyword">const</span> async_io_op &amp;o) { parent=o.<a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19" title="The parent dispatcher.">parent</a>; <span class="keywordtype">id</span>=o.<a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df" title="A unique id for this operation.">id</a>; h=o.h; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00900"></a>00900     async_io_op &amp;operator=(async_io_op &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW{ parent=std::move(o.parent); <span class="keywordtype">id</span>=std::move(o.id); h=std::move(o.h); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00902"></a>00902     std::shared_ptr&lt;async_io_handle&gt; <span class="keyword">get</span>(<span class="keywordtype">bool</span> return_null_if_errored=<span class="keyword">false</span>) <span class="keyword">const</span>
<a name="l00903"></a>00903     {
<a name="l00904"></a>00904         <span class="keywordflow">if</span>(!parent &amp;&amp; !<span class="keywordtype">id</span>)
<a name="l00905"></a>00905             <span class="keywordflow">return</span> std::shared_ptr&lt;async_io_handle&gt;();
<a name="l00906"></a>00906         <span class="comment">// std::shared_future in older libstdc++ does not have a const get().</span>
<a name="l00907"></a>00907         <span class="keywordflow">if</span>(!return_null_if_errored)
<a name="l00908"></a>00908             <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>async_io_op *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;h.get();
<a name="l00909"></a>00909         <span class="keyword">auto</span> e=get_exception_ptr(h);
<a name="l00910"></a>00910         <span class="keywordflow">return</span> e ? std::shared_ptr&lt;async_io_handle&gt;() : const_cast&lt;async_io_op *&gt;(<span class="keyword">this</span>)-&gt;h.get();
<a name="l00911"></a>00911     }
<a name="l00913"></a>00913     <span class="keyword">const</span> <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> &amp;operator *()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">get</span>(); }
<a name="l00915"></a>00915     <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> &amp;operator *() { <span class="keywordflow">return</span> *<span class="keyword">get</span>(); }
<a name="l00917"></a>00917     <span class="keyword">const</span> <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> *operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">get</span>().<span class="keyword">get</span>(); }
<a name="l00919"></a>00919     <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> *operator-&gt;() { <span class="keywordflow">return</span> <span class="keyword">get</span>().<span class="keyword">get</span>(); }
<a name="l00921"></a>00921     <span class="keywordtype">bool</span> validate(<span class="keywordtype">bool</span> check_handle=<span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00922"></a>00922 <span class="keyword">    </span>{
<a name="l00923"></a>00923         <span class="keywordflow">if</span>(!parent || !<span class="keywordtype">id</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00924"></a>00924         <span class="comment">// If h is valid and ready and contains an exception, throw it now</span>
<a name="l00925"></a>00925         <span class="keywordflow">if</span>(h.valid() &amp;&amp; is_ready(h))
<a name="l00926"></a>00926         {
<a name="l00927"></a>00927             <span class="keywordflow">if</span>(check_handle)
<a name="l00928"></a>00928                 <span class="keywordflow">if</span>(!<span class="keyword">const_cast&lt;</span>shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;<span class="keyword">&gt;</span> &amp;&gt;(h).get().get())
<a name="l00929"></a>00929                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00930"></a>00930         }
<a name="l00931"></a>00931         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933 <span class="keyword">private</span>:
<a name="l00934"></a>00934     <span class="keywordtype">void</span> _validate(<span class="keywordtype">bool</span> check_handle=<span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00935"></a>00935 <span class="keyword">    </span>{
<a name="l00936"></a>00936 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l00937"></a>00937 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!validate(check_handle))
<a name="l00938"></a>00938             BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l00939"></a>00939 <span class="preprocessor">#endif</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span>    }
<a name="l00941"></a>00941 };
<a name="l00942"></a>00942 
<a name="l00943"></a>00943 <span class="comment">// This is a result_of filter to work around the weird mix of brittle decltype(), SFINAE incapable</span>
<a name="l00944"></a>00944 <span class="comment">// std::result_of and variadic template overload resolution rules in VS2013. Works on other compilers</span>
<a name="l00945"></a>00945 <span class="comment">// too of course, it simply prefilters out the call() overloads not matching the variadic overload.</span>
<a name="l00946"></a>00946 <span class="keyword">namespace </span>detail
<a name="l00947"></a>00947 {
<a name="l00948"></a>00948 <span class="preprocessor">#if 0</span>
<a name="l00949"></a>00949 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround;
<a name="l00950"></a>00950     <span class="comment">// Match callable</span>
<a name="l00951"></a>00951     <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class</span>... OArgs, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;R (*)(OArgs...), Args...&gt;
<a name="l00952"></a>00952     {
<a name="l00953"></a>00953         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;R(*)(Args...)&gt;::type type;
<a name="l00954"></a>00954     };
<a name="l00955"></a>00955     <span class="comment">// Match callable</span>
<a name="l00956"></a>00956     <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class </span>T, <span class="keyword">class</span>... OArgs, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;R (T::*)(OArgs...) const, Args...&gt;
<a name="l00957"></a>00957     {
<a name="l00958"></a>00958         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;R (T::*)(Args...) <span class="keyword">const</span>&gt;::type type;
<a name="l00959"></a>00959     };
<a name="l00960"></a>00960     <span class="comment">// Match callable</span>
<a name="l00961"></a>00961     <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class </span>T, <span class="keyword">class</span>... OArgs, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;R (T::*const)(OArgs...) const, Args...&gt;
<a name="l00962"></a>00962     {
<a name="l00963"></a>00963         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;R (T::*<span class="keyword">const</span>)(Args...) <span class="keyword">const</span>&gt;::type type;
<a name="l00964"></a>00964     };
<a name="l00965"></a>00965 <span class="preprocessor">#else</span>
<a name="l00966"></a>00966 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l00967"></a>00967 <span class="comment">    call(const std::vector&lt;async_io_op&gt; &amp;ops             , const std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables              );</span>
<a name="l00968"></a>00968 <span class="comment">    call(const std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables                                                                );</span>
<a name="l00969"></a>00969 <span class="comment">    call(const async_io_op &amp;req                          , std::function&lt;R()&gt; callback                                   );</span>
<a name="l00970"></a>00970 <span class="comment">    call(const async_io_op &amp;req                          , C callback                                      , Args... args);</span>
<a name="l00971"></a>00971 <span class="comment">    */</span>
<a name="l00972"></a>00972     <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround
<a name="l00973"></a>00973     {
<a name="l00974"></a>00974         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type type;
<a name="l00975"></a>00975     };
<a name="l00976"></a>00976     <span class="comment">// Disable C being a const std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables</span>
<a name="l00977"></a>00977     <span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;std::vector&lt;T&gt;, Args...&gt;;
<a name="l00978"></a>00978 <span class="preprocessor">#endif</span>
<a name="l00979"></a>00979 <span class="preprocessor"></span>}
<a name="l00980"></a>00980 
<a name="l00998"></a>00998 class BOOST_AFIO_DECL async_file_io_dispatcher_base : <span class="keyword">public</span> std::enable_shared_from_this&lt;async_file_io_dispatcher_base&gt;
<a name="l00999"></a>00999 {
<a name="l01000"></a>01000     <span class="comment">//friend BOOST_AFIO_DECL std::shared_ptr&lt;async_file_io_dispatcher_base&gt; async_file_io_dispatcher(thread_source &amp;threadpool=process_threadpool(), file_flags flagsforce=file_flags::None, file_flags flagsmask=file_flags::None);</span>
<a name="l01001"></a>01001     <span class="keyword">friend</span> <span class="keyword">struct </span>detail::async_io_handle_posix;
<a name="l01002"></a>01002     <span class="keyword">friend</span> <span class="keyword">struct </span>detail::async_io_handle_windows;
<a name="l01003"></a>01003     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_compat;
<a name="l01004"></a>01004     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_windows;
<a name="l01005"></a>01005     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_linux;
<a name="l01006"></a>01006     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_qnx;
<a name="l01007"></a>01007 
<a name="l01008"></a>01008     detail::async_file_io_dispatcher_base_p *p;
<a name="l01009"></a>01009     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> int_add_io_handle(<span class="keywordtype">void</span> *key, std::shared_ptr&lt;async_io_handle&gt; h);
<a name="l01010"></a>01010     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> int_del_io_handle(<span class="keywordtype">void</span> *key);
<a name="l01011"></a>01011     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_io_op int_op_from_scheduled_id(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;
<a name="l01012"></a>01012 <span class="keyword">protected</span>:
<a name="l01013"></a>01013     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_file_io_dispatcher_base(std::shared_ptr&lt;thread_source&gt; threadpool, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsforce, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsmask);
<a name="l01014"></a>01014     std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; doadopt(<span class="keywordtype">size_t</span>, async_io_op, std::shared_ptr&lt;async_io_handle&gt; h)
<a name="l01015"></a>01015     {
<a name="l01016"></a>01016         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, h);
<a name="l01017"></a>01017     }
<a name="l01018"></a>01018 <span class="keyword">public</span>:
<a name="l01020"></a>01020     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~async_file_io_dispatcher_base();
<a name="l01021"></a>01021 
<a name="l01023"></a>01023     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::shared_ptr&lt;thread_source&gt; threadsource() <span class="keyword">const</span>;
<a name="l01025"></a>01025     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> fileflags(<a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flags) <span class="keyword">const</span>;
<a name="l01027"></a>01027     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> wait_queue_depth() <span class="keyword">const</span>;
<a name="l01029"></a>01029     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> fd_count() <span class="keyword">const</span>;
<a name="l01036"></a>01036     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_io_op op_from_scheduled_id(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;
<a name="l01037"></a>01037 
<a name="l01039"></a>01039     <span class="keyword">typedef</span> <span class="keywordtype">void</span> filter_t(detail::OpType, async_io_op &amp;);
<a name="l01041"></a>01041     <span class="keyword">typedef</span> <span class="keywordtype">void</span> filter_readwrite_t(detail::OpType, <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> *, <span class="keyword">const</span> detail::async_data_op_req_impl&lt;true&gt; &amp;, off_t, <span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>, <span class="keyword">const</span> asio::error_code &amp;, <span class="keywordtype">size_t</span>);
<a name="l01048"></a>01048     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> post_op_filter_clear();
<a name="l01063"></a>01063     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> post_op_filter(std::vector&lt;std::pair&lt;detail::OpType, std::function&lt;async_file_io_dispatcher_base::filter_t&gt;&gt;&gt; filters);
<a name="l01081"></a>01081     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> post_readwrite_filter(std::vector&lt;std::pair&lt;detail::OpType, std::function&lt;async_file_io_dispatcher_base::filter_readwrite_t&gt;&gt;&gt; filters);
<a name="l01082"></a>01082 
<a name="l01084"></a>01084     <span class="keyword">typedef</span> std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; completion_returntype;
<a name="l01086"></a>01086     <span class="keyword">typedef</span> completion_returntype completion_t(<span class="keywordtype">size_t</span>, async_io_op);
<a name="l01087"></a>01087 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01088"></a>01088 <span class="preprocessor"></span><span class="preprocessor">#if defined(BOOST_AFIO_ENABLE_BENCHMARKING_COMPLETION) || BOOST_AFIO_HEADERS_ONLY==0 // Only really used for benchmarking</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span>    BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; completion(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt;&gt; &amp;callbacks);
<a name="l01090"></a>01090     <span class="keyword">inline</span> async_io_op completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt; &amp;callback);
<a name="l01091"></a>01091 <span class="preprocessor">#endif</span>
<a name="l01092"></a>01092 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01093"></a>01093 <span class="preprocessor"></span>
<a name="l01104"></a>01104     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; completion(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::pair&lt;<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt;&gt; &amp;callbacks);
<a name="l01116"></a>01116     <span class="keyword">inline</span> async_io_op completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt; &amp;callback);
<a name="l01117"></a>01117 
<a name="l01133"></a>01133     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; call(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables);
<a name="l01149"></a>01149     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; call(<span class="keyword">const</span> std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables) { <span class="keywordflow">return</span> call(std::vector&lt;async_io_op&gt;(), callables); }
<a name="l01166"></a>01166     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;R&gt;, async_io_op&gt; call(<span class="keyword">const</span> async_io_op &amp;req, std::function&lt;R()&gt; callback);
<a name="l01167"></a>01167 
<a name="l01168"></a>01168     
<a name="l01169"></a>01169     
<a name="l01170"></a>01170          
<a name="l01191"></a>01191 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01192"></a>01192 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> detail::vs2013_variadic_overload_resolution_workaround&lt;C, Args...&gt;::type&gt;, async_io_op&gt; call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args);
<a name="l01193"></a>01193 <span class="preprocessor">#else</span>
<a name="l01194"></a>01194 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type&gt;, async_io_op&gt; call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args);
<a name="l01195"></a>01195 <span class="preprocessor">#endif</span>
<a name="l01196"></a>01196 <span class="preprocessor"></span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198 
<a name="l01213"></a>01213     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; adopt(<span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; &amp;hs);
<a name="l01228"></a>01228     <span class="keyword">inline</span> async_io_op adopt(std::shared_ptr&lt;async_io_handle&gt; h);
<a name="l01242"></a>01242     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; dir(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01256"></a>01256     <span class="keyword">inline</span> async_io_op dir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01267"></a>01267     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; rmdir(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01278"></a>01278     <span class="keyword">inline</span> async_io_op rmdir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01292"></a>01292     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; file(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01306"></a>01306     <span class="keyword">inline</span> async_io_op file(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01317"></a>01317     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; rmfile(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01328"></a>01328     <span class="keyword">inline</span> async_io_op rmfile(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01345"></a>01345     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; symlink(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01362"></a>01362     <span class="keyword">inline</span> async_io_op symlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01373"></a>01373     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; rmsymlink(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01384"></a>01384     <span class="keyword">inline</span> async_io_op rmsymlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01395"></a>01395     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; sync(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01406"></a>01406     <span class="keyword">inline</span> async_io_op sync(<span class="keyword">const</span> async_io_op &amp;req);
<a name="l01428"></a>01428     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; zero(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt; &amp;ranges) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01450"></a>01450     inline async_io_op zero(const async_io_op &amp;req, const std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt; &amp;ranges);
<a name="l01461"></a>01461     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; close(const std::vector&lt;async_io_op&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01472"></a>01472     inline async_io_op close(const async_io_op &amp;req);
<a name="l01473"></a>01473 
<a name="l01487"></a>01487 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>    BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; read(<span class="keyword">const</span> std::vector&lt;detail::async_data_op_req_impl&lt;false&gt;&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01489"></a>01489     template&lt;class T&gt; inline std::vector&lt;async_io_op&gt; read(const std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops);
<a name="l01490"></a>01490 <span class="preprocessor">#else</span>
<a name="l01491"></a>01491 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; read(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01492"></a>01492 <span class="preprocessor">#endif</span>
<a name="l01493"></a>01493 <span class="preprocessor"></span>
<a name="l01506"></a>01506 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01507"></a>01507 <span class="preprocessor"></span>    <span class="keyword">inline</span> async_io_op read(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;false&gt; &amp;req);
<a name="l01508"></a>01508 <span class="preprocessor">#else</span>
<a name="l01509"></a>01509 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_io_op read(<span class="keyword">const</span> async_data_op_req&lt;T&gt; &amp;req);
<a name="l01510"></a>01510 <span class="preprocessor">#endif</span>
<a name="l01511"></a>01511 <span class="preprocessor"></span>
<a name="l01524"></a>01524 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01525"></a>01525 <span class="preprocessor"></span>    BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; write(<span class="keyword">const</span> std::vector&lt;detail::async_data_op_req_impl&lt;true&gt;&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01526"></a>01526     template&lt;class T&gt; inline std::vector&lt;async_io_op&gt; write(const std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops);
<a name="l01527"></a>01527 <span class="preprocessor">#else</span>
<a name="l01528"></a>01528 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; write(<span class="keyword">const</span> std::vector&lt;<a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html" title="A convenience bundle of precondition, data and where for writing from a single `const T *`...">async_data_op_req&lt;const T&gt;</a>&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01529"></a>01529 <span class="preprocessor">#endif</span>
<a name="l01530"></a>01530 <span class="preprocessor"></span>
<a name="l01543"></a>01543 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01544"></a>01544 <span class="preprocessor"></span>    <span class="keyword">inline</span> async_io_op write(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;true&gt; &amp;req);
<a name="l01545"></a>01545 <span class="preprocessor">#else</span>
<a name="l01546"></a>01546 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_io_op write(<span class="keyword">const</span> <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html" title="A convenience bundle of precondition, data and where for writing from a single `const T *`...">async_data_op_req&lt;const T&gt;</a> &amp;req);
<a name="l01547"></a>01547 <span class="preprocessor">#endif</span>
<a name="l01548"></a>01548 <span class="preprocessor"></span>
<a name="l01560"></a>01560     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; truncate(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;off_t&gt; &amp;sizes) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01572"></a>01572     <span class="keyword">inline</span> async_io_op truncate(<span class="keyword">const</span> async_io_op &amp;op, off_t newsize);
<a name="l01593"></a>01593     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::pair&lt;std::vector&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; enumerate(<span class="keyword">const</span> std::vector&lt;async_enumerate_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01614"></a>01614     <span class="keyword">inline</span> std::pair&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;, async_io_op&gt; enumerate(<span class="keyword">const</span> <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a> &amp;req);
<a name="l01628"></a>01628     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::pair&lt;std::vector&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; extents(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01642"></a>01642     <span class="keyword">inline</span> std::pair&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt;, async_io_op&gt; extents(<span class="keyword">const</span> async_io_op &amp;op);
<a name="l01653"></a>01653     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::pair&lt;std::vector&lt;future&lt;statfs_t&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; statfs(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;fs_metadata_flags&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01664"></a>01664     <span class="keyword">inline</span> std::pair&lt;future&lt;statfs_t&gt;, async_io_op&gt; statfs(<span class="keyword">const</span> async_io_op &amp;op, <span class="keyword">const</span> <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e" title="Bitflags for availability of metadata from `struct statfs_t`.">fs_metadata_flags</a> &amp;req);
<a name="l01665"></a>01665 
<a name="l01685"></a>01685     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; barrier(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops);
<a name="l01686"></a>01686 
<a name="l01694"></a>01694     <span class="keyword">static</span> BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> page_size() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l01695"></a>01695 
<a name="l01703"></a>01703     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> complete_async_op(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, std::shared_ptr&lt;<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>&gt; h, exception_ptr e=exception_ptr());
<a name="l01711"></a>01711     <span class="keywordtype">void</span> complete_async_op(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, exception_ptr e) { complete_async_op(<span class="keywordtype">id</span>, std::shared_ptr&lt;async_io_handle&gt;(), e); }
<a name="l01712"></a>01712 <span class="keyword">protected</span>:
<a name="l01713"></a>01713     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC completion_returntype invoke_user_completion_fast(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, completion_t *callback);
<a name="l01714"></a>01714     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC completion_returntype invoke_user_completion_slow(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, std::function&lt;completion_t&gt; callback);
<a name="l01715"></a>01715     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;preconditions, <span class="keyword">const</span> std::vector&lt;T&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, T));
<a name="l01716"></a>01716     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;T&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, T));
<a name="l01717"></a>01717     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, async_io_op));
<a name="l01718"></a>01718     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a>));
<a name="l01719"></a>01719     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keywordtype">bool</span> iswrite&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;detail::async_data_op_req_impl&lt;iswrite&gt;&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, detail::async_data_op_req_impl&lt;iswrite&gt;));
<a name="l01720"></a>01720     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::pair&lt;std::vector&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_enumerate_op_req&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>, std::shared_ptr&lt;promise&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;&gt;));
<a name="l01721"></a>01721     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::pair&lt;std::vector&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, std::shared_ptr&lt;promise&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt;&gt; ret));
<a name="l01722"></a>01722     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::pair&lt;std::vector&lt;future&lt;statfs_t&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;container, <span class="keyword">const</span> std::vector&lt;fs_metadata_flags&gt; &amp;req, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e" title="Bitflags for availability of metadata from `struct statfs_t`.">fs_metadata_flags</a>, std::shared_ptr&lt;promise&lt;statfs_t&gt;&gt; ret));
<a name="l01723"></a>01723     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_file_io_dispatcher_base::completion_returntype dobarrier(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, T);
<a name="l01724"></a>01724 
<a name="l01725"></a>01725     
<a name="l01726"></a>01726     <span class="keyword">template</span>&lt;<span class="keyword">class </span>F, <span class="keyword">class</span>... Args&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::shared_ptr&lt;async_io_handle&gt; invoke_async_op_completions(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, Args...), Args... args);
<a name="l01727"></a>01727     <span class="keyword">template</span>&lt;<span class="keyword">class </span>F, <span class="keyword">class</span>... Args&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_io_op chain_async_op(detail::immediate_async_ops &amp;immediates, <span class="keywordtype">int</span> optype, <span class="keyword">const</span> async_io_op &amp;precondition, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, Args...), Args... args);
<a name="l01728"></a>01728 };
<a name="l01745"></a>01745 BOOST_AFIO_HEADERS_ONLY_FUNC_SPEC std::shared_ptr&lt;async_file_io_dispatcher_base&gt; <a class="code" href="group__async__file__io__dispatcher.html#ga60af4394d09808d966a31a80fe9142eb" title="Instatiates the best available async_file_io_dispatcher implementation for this system.">make_async_file_io_dispatcher</a>(std::shared_ptr&lt;thread_source&gt; threadpool=<a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>(), <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsforce=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsmask=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>);
<a name="l01746"></a>01746 
<a name="l01747"></a>01747 <span class="keyword">namespace </span>detail
<a name="l01748"></a>01748 {
<a name="l01749"></a>01749     <span class="keyword">struct </span>when_all_state : std::enable_shared_from_this&lt;when_all_state&gt;
<a name="l01750"></a>01750     {
<a name="l01751"></a>01751         promise&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; out;
<a name="l01752"></a>01752         std::vector&lt;shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; in;
<a name="l01753"></a>01753     };
<a name="l01754"></a>01754     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> when_all_ops_do(std::shared_ptr&lt;when_all_state&gt; state)
<a name="l01755"></a>01755     {
<a name="l01756"></a>01756         <span class="comment">// If we&#39;re on Boost.Thread, coalesce all wait ops into a single</span>
<a name="l01757"></a>01757 <span class="preprocessor">#if BOOST_AFIO_USE_BOOST_THREAD</span>
<a name="l01758"></a>01758 <span class="preprocessor"></span>        boost::wait_for_all(state-&gt;in.begin(), state-&gt;in.end());
<a name="l01759"></a>01759 <span class="preprocessor">#endif</span>
<a name="l01760"></a>01760 <span class="preprocessor"></span>        std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; ret;
<a name="l01761"></a>01761         ret.reserve(state-&gt;in.size());
<a name="l01762"></a>01762         <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i: state-&gt;in)
<a name="l01763"></a>01763         {
<a name="l01764"></a>01764             <span class="keyword">auto</span> e(get_exception_ptr(i));
<a name="l01765"></a>01765             <span class="keywordflow">if</span>(e)
<a name="l01766"></a>01766             {
<a name="l01767"></a>01767                 <span class="keywordflow">if</span>(rethrow)
<a name="l01768"></a>01768                 {
<a name="l01769"></a>01769                     state-&gt;out.set_exception(e);
<a name="l01770"></a>01770                     <span class="keywordflow">return</span>;
<a name="l01771"></a>01771                 }
<a name="l01772"></a>01772                 ret.push_back(std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01773"></a>01773             }
<a name="l01774"></a>01774             <span class="keywordflow">else</span>
<a name="l01775"></a>01775                 ret.push_back(i.get());
<a name="l01776"></a>01776         }
<a name="l01777"></a>01777         state-&gt;out.set_value(ret);
<a name="l01778"></a>01778     }
<a name="l01779"></a>01779     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow, <span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all_ops(Iterator first, Iterator last)
<a name="l01780"></a>01780     {
<a name="l01781"></a>01781         <span class="keyword">auto</span> state=std::make_shared&lt;when_all_state&gt;();
<a name="l01782"></a>01782         state-&gt;in.reserve(std::distance(first, last));
<a name="l01783"></a>01783         <span class="keywordflow">for</span>(; first!=last; ++first)
<a name="l01784"></a>01784             state-&gt;in.push_back(first-&gt;h);
<a name="l01785"></a>01785         <span class="keyword">auto</span> ret=state-&gt;out.get_future();
<a name="l01786"></a>01786         <a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>()-&gt;enqueue([BOOST_AFIO_LAMBDA_MOVE_CAPTURE(state)] { when_all_ops_do&lt;rethrow&gt;(std::move(state)); });
<a name="l01787"></a>01787         <span class="keywordflow">return</span> std::move(ret);
<a name="l01788"></a>01788     }
<a name="l01789"></a>01789     <span class="keyword">struct </span>when_any_state : std::enable_shared_from_this&lt;when_any_state&gt;
<a name="l01790"></a>01790     {
<a name="l01791"></a>01791         atomic&lt;size_t&gt; count;
<a name="l01792"></a>01792         promise&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; out;
<a name="l01793"></a>01793         std::vector&lt;shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; in;
<a name="l01794"></a>01794         when_any_state() : count(0) { }
<a name="l01795"></a>01795     };
<a name="l01796"></a>01796 <span class="preprocessor">#if BOOST_AFIO_USE_BOOST_THREAD</span>
<a name="l01797"></a>01797 <span class="preprocessor"></span>    <span class="comment">// Boost.Thread has wait_for_any() which lets us be more efficient here and wait directly on the futures</span>
<a name="l01798"></a>01798     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> when_any_ops_do(std::shared_ptr&lt;when_any_state&gt; state)
<a name="l01799"></a>01799     {
<a name="l01800"></a>01800         <span class="keyword">auto</span> &amp;i=*boost::wait_for_any(state-&gt;in.begin(), state-&gt;in.end());
<a name="l01801"></a>01801         <span class="keyword">auto</span> e(get_exception_ptr(i));
<a name="l01802"></a>01802         <span class="keywordflow">if</span>(e)
<a name="l01803"></a>01803         {
<a name="l01804"></a>01804             <span class="keywordflow">if</span>(rethrow)
<a name="l01805"></a>01805             {
<a name="l01806"></a>01806                 state-&gt;out.set_exception(e);
<a name="l01807"></a>01807                 <span class="keywordflow">return</span>;
<a name="l01808"></a>01808             }
<a name="l01809"></a>01809             state-&gt;out.set_value(std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01810"></a>01810         }
<a name="l01811"></a>01811         <span class="keywordflow">else</span>
<a name="l01812"></a>01812             state-&gt;out.set_value(i.get());
<a name="l01813"></a>01813     }
<a name="l01814"></a>01814     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow, <span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; when_any_ops(Iterator first, Iterator last)
<a name="l01815"></a>01815     {
<a name="l01816"></a>01816         <span class="keyword">auto</span> state=std::make_shared&lt;when_any_state&gt;();
<a name="l01817"></a>01817         state-&gt;in.reserve(std::distance(first, last));
<a name="l01818"></a>01818         <span class="keywordflow">for</span>(; first!=last; ++first)
<a name="l01819"></a>01819             state-&gt;in.push_back(first-&gt;h);
<a name="l01820"></a>01820         <span class="keyword">auto</span> ret=state-&gt;out.get_future();
<a name="l01821"></a>01821         <a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>()-&gt;enqueue([BOOST_AFIO_LAMBDA_MOVE_CAPTURE(state)]{ when_any_ops_do&lt;rethrow&gt;(std::move(state)); });
<a name="l01822"></a>01822         <span class="keywordflow">return</span> std::move(ret);
<a name="l01823"></a>01823     }
<a name="l01824"></a>01824 <span class="preprocessor">#else</span>
<a name="l01825"></a>01825 <span class="preprocessor"></span>    <span class="comment">// Without wait_for_any, schedule a completion onto every op and the first to fire wins</span>
<a name="l01826"></a>01826     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow&gt; <span class="keyword">inline</span> std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; when_any_ops_do(std::shared_ptr&lt;when_any_state&gt; state, <span class="keywordtype">size_t</span> idx, <span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h)
<a name="l01827"></a>01827     {
<a name="l01828"></a>01828         <span class="keyword">auto</span> &amp;i=state-&gt;in[idx];
<a name="l01829"></a>01829         <span class="keywordflow">if</span>(0==state-&gt;count.fetch_add(1, memory_order_relaxed))  <span class="comment">// Will be zero exactly once</span>
<a name="l01830"></a>01830         {
<a name="l01831"></a>01831             <span class="keyword">auto</span> e(get_exception_ptr(i));
<a name="l01832"></a>01832             <span class="keywordflow">if</span>(e)
<a name="l01833"></a>01833             {
<a name="l01834"></a>01834                 <span class="keywordflow">if</span>(rethrow)
<a name="l01835"></a>01835                 {
<a name="l01836"></a>01836                     state-&gt;out.set_exception(e);
<a name="l01837"></a>01837                     <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01838"></a>01838                 }
<a name="l01839"></a>01839                 state-&gt;out.set_value(std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01840"></a>01840             }
<a name="l01841"></a>01841             <span class="keywordflow">else</span>
<a name="l01842"></a>01842                 state-&gt;out.set_value(i.get());
<a name="l01843"></a>01843         }
<a name="l01844"></a>01844         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01845"></a>01845     }
<a name="l01846"></a>01846     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow, <span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; when_any_ops(Iterator first, Iterator last)
<a name="l01847"></a>01847     {
<a name="l01848"></a>01848         <span class="keyword">auto</span> state=std::make_shared&lt;when_any_state&gt;();
<a name="l01849"></a>01849         <span class="keyword">auto</span> dispatcher=first-&gt;parent;
<a name="l01850"></a>01850         std::vector&lt;async_io_op&gt; ops(first, last);
<a name="l01851"></a>01851         state-&gt;in.reserve(ops.size());
<a name="l01852"></a>01852         <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;op : ops)
<a name="l01853"></a>01853             state-&gt;in.push_back(op.h);
<a name="l01854"></a>01854         <span class="keyword">auto</span> ret=state-&gt;out.get_future();
<a name="l01855"></a>01855         <span class="keyword">typedef</span> std::function&lt;typename async_file_io_dispatcher_base::completion_t&gt; ft;
<a name="l01856"></a>01856         std::vector&lt;std::pair&lt;async_op_flags, ft&gt;&gt; completions;
<a name="l01857"></a>01857         completions.reserve(ops.size());
<a name="l01858"></a>01858         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n=0; n&lt;ops.size(); n++)
<a name="l01859"></a>01859           completions.push_back(std::make_pair(<a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b" title="Call chained completion immediately instead of scheduling for later. Make SURE your completion can no...">async_op_flags::immediate</a>, std::bind(&amp;when_any_ops_do&lt;rethrow&gt;, state, n, std::placeholders::_1, std::placeholders::_2)));
<a name="l01860"></a>01860         dispatcher-&gt;completion(ops, completions);
<a name="l01861"></a>01861         <span class="keywordflow">return</span> std::move(ret);
<a name="l01862"></a>01862     }
<a name="l01863"></a>01863 <span class="preprocessor">#endif</span>
<a name="l01864"></a>01864 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_all&gt; <span class="keyword">struct </span>select_when_ops_return_type
<a name="l01865"></a>01865     {
<a name="l01866"></a>01866         <span class="keyword">typedef</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; type; <span class="comment">// when_all()</span>
<a name="l01867"></a>01867     };
<a name="l01868"></a>01868     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>select_when_ops_return_type&lt;false&gt;
<a name="l01869"></a>01869     {
<a name="l01870"></a>01870         <span class="keyword">typedef</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; type; <span class="comment">// when_any()</span>
<a name="l01871"></a>01871     };
<a name="l01872"></a>01872     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_all, <span class="keyword">class</span> T&gt; <span class="keyword">struct </span>enable_if_async_op
<a name="l01873"></a>01873     {
<a name="l01874"></a>01874         <span class="comment">//static_assert(std::is_same&lt;T, T&gt;::value, &quot;Not an iterator of async_io_op&quot;);</span>
<a name="l01875"></a>01875     };
<a name="l01876"></a>01876     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_all&gt; <span class="keyword">struct </span>enable_if_async_op&lt;is_all, async_io_op&gt;
<a name="l01877"></a>01877     {
<a name="l01878"></a>01878         <span class="keyword">typedef</span> <span class="keyword">typename</span> select_when_ops_return_type&lt;is_all&gt;::type type;
<a name="l01879"></a>01879     };
<a name="l01880"></a>01880 }
<a name="l01881"></a>01881 
<a name="l01894"></a>01894 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;true, typename Iterator::value_type&gt;::type when_all(std::nothrow_t _, Iterator first, Iterator last)
<a name="l01895"></a>01895 {
<a name="l01896"></a>01896     <span class="keywordflow">if</span>(first==last)
<a name="l01897"></a>01897         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01898"></a>01898     <span class="keywordflow">return</span> detail::when_all_ops&lt;false&gt;(first, last);
<a name="l01899"></a>01899 }
<a name="l01912"></a><a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635">01912</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;false, typename Iterator::value_type&gt;::type <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(std::nothrow_t _, Iterator first, Iterator last)
<a name="l01913"></a>01913 {
<a name="l01914"></a>01914     <span class="keywordflow">if</span>(first==last)
<a name="l01915"></a>01915         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01916"></a>01916     <span class="keywordflow">return</span> detail::when_any_ops&lt;false&gt;(first, last);
<a name="l01917"></a>01917 }
<a name="l01928"></a><a class="code" href="group__when__all__ops.html#ga461b0e5f0a135982cac72648a1689e83">01928</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(std::nothrow_t _, std::vector&lt;async_io_op&gt; ops)
<a name="l01929"></a>01929 {
<a name="l01930"></a>01930     <span class="keywordflow">if</span>(ops.empty())
<a name="l01931"></a>01931         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01932"></a>01932     <span class="keywordflow">return</span> detail::when_all_ops&lt;false&gt;(ops.begin(), ops.end());
<a name="l01933"></a>01933 }
<a name="l01944"></a><a class="code" href="group__when__all__ops.html#gae51d3626cd8b9d2c5fe1d3b55c451fbd">01944</a> <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(std::nothrow_t _, std::vector&lt;async_io_op&gt; ops)
<a name="l01945"></a>01945 {
<a name="l01946"></a>01946     <span class="keywordflow">if</span>(ops.empty())
<a name="l01947"></a>01947         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01948"></a>01948     <span class="keywordflow">return</span> detail::when_any_ops&lt;false&gt;(ops.begin(), ops.end());
<a name="l01949"></a>01949 }
<a name="l01961"></a><a class="code" href="group__when__all__ops.html#gaaa1c16812271841ff671cfe7f231cb0b">01961</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;true, typename Iterator::value_type&gt;::type when_all(Iterator first, Iterator last)
<a name="l01962"></a>01962 {
<a name="l01963"></a>01963     <span class="keywordflow">if</span>(first==last)
<a name="l01964"></a>01964         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01965"></a>01965     <span class="keywordflow">return</span> detail::when_all_ops&lt;true&gt;(first, last);
<a name="l01966"></a>01966 }
<a name="l01978"></a><a class="code" href="group__when__all__ops.html#ga5da03663689177b4c470ce149c87361d">01978</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;false, typename Iterator::value_type&gt;::type <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(Iterator first, Iterator last)
<a name="l01979"></a>01979 {
<a name="l01980"></a>01980     <span class="keywordflow">if</span>(first==last)
<a name="l01981"></a>01981         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01982"></a>01982     <span class="keywordflow">return</span> detail::when_any_ops&lt;true&gt;(first, last);
<a name="l01983"></a>01983 }
<a name="l01993"></a><a class="code" href="group__when__all__ops.html#ga536ffef275e197aa15d35a3a4dd3a9bf">01993</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(std::vector&lt;async_io_op&gt; ops)
<a name="l01994"></a>01994 {
<a name="l01995"></a>01995     <span class="keywordflow">if</span>(ops.empty())
<a name="l01996"></a>01996         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01997"></a>01997     <span class="keywordflow">return</span> detail::when_all_ops&lt;true&gt;(ops.begin(), ops.end());
<a name="l01998"></a>01998 }
<a name="l02008"></a><a class="code" href="group__when__all__ops.html#ga73eaeec972558c72429fbd5042307036">02008</a> <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(std::vector&lt;async_io_op&gt; ops)
<a name="l02009"></a>02009 {
<a name="l02010"></a>02010     <span class="keywordflow">if</span>(ops.empty())
<a name="l02011"></a>02011         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l02012"></a>02012     <span class="keywordflow">return</span> detail::when_any_ops&lt;true&gt;(ops.begin(), ops.end());
<a name="l02013"></a>02013 }
<a name="l02024"></a><a class="code" href="group__when__all__ops.html#gaff9f004d3897d9bf83261e45a050c252">02024</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(std::nothrow_t _, async_io_op op)
<a name="l02025"></a>02025 {
<a name="l02026"></a>02026     std::vector&lt;async_io_op&gt; ops(1, op);
<a name="l02027"></a>02027     <span class="keywordflow">return</span> when_all(_, ops);
<a name="l02028"></a>02028 }
<a name="l02038"></a><a class="code" href="group__when__all__ops.html#ga7e235ffd635c6b38fa0c416c872ae044">02038</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(async_io_op op)
<a name="l02039"></a>02039 {
<a name="l02040"></a>02040     std::vector&lt;async_io_op&gt; ops(1, op);
<a name="l02041"></a>02041     <span class="keywordflow">return</span> when_all(ops);
<a name="l02042"></a>02042 }
<a name="l02043"></a>02043 
<a name="l02047"></a><a class="code" href="structasync__path__op__req.html">02047</a> <span class="keyword">struct </span><a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a>
<a name="l02048"></a>02048 {
<a name="l02049"></a><a class="code" href="structasync__path__op__req.html#ac95903f23add8d81993d0aa857ebf4e0">02049</a>     filesystem::path <a class="code" href="structasync__path__op__req.html#ac95903f23add8d81993d0aa857ebf4e0" title="The filing system path to be used for this operation.">path</a>; 
<a name="l02050"></a><a class="code" href="structasync__path__op__req.html#a3051dba59ddb18a5f8a8e023f65b8801">02050</a>     <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> <a class="code" href="structasync__path__op__req.html#a3051dba59ddb18a5f8a8e023f65b8801" title="The flags to be used for this operation (note they can be overriden by flags passed during dispatcher...">flags</a>;           
<a name="l02051"></a><a class="code" href="structasync__path__op__req.html#a3851b041fa3c59aa67c375457ac37f2e">02051</a>     async_io_op <a class="code" href="structasync__path__op__req.html#a3851b041fa3c59aa67c375457ac37f2e">precondition</a>;   
<a name="l02052"></a>02052 
<a name="l02053"></a><a class="code" href="structasync__path__op__req.html#a01733eeb8f8c26f5b5e57cdd5b1542c4">02053</a>     <a class="code" href="structasync__path__op__req.html#a01733eeb8f8c26f5b5e57cdd5b1542c4" title="Default constructor.">async_path_op_req</a>() : flags(<a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a>::<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>) { }
<a name="l02061"></a><a class="code" href="structasync__path__op__req.html#a5746c1fb8b51a69f9a24eb7ea695c56f">02061</a>     <a class="code" href="structasync__path__op__req.html#a5746c1fb8b51a69f9a24eb7ea695c56f" title="Constructs an instance.">async_path_op_req</a>(filesystem::path _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(_path), flags(_flags) { <span class="keywordflow">if</span>(!path.is_absolute()) BOOST_AFIO_THROW(std::runtime_error(<span class="stringliteral">&quot;Non-absolute path&quot;</span>)); }
<a name="l02070"></a><a class="code" href="structasync__path__op__req.html#a18121b00a21954c9feae6070f9606528">02070</a>     <a class="code" href="structasync__path__op__req.html#a18121b00a21954c9feae6070f9606528" title="Constructs an instance.">async_path_op_req</a>(async_io_op _precondition, filesystem::path _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(_path), flags(_flags), precondition(std::move(_precondition)) { _validate(); <span class="keywordflow">if</span>(!path.is_absolute()) BOOST_AFIO_THROW(std::runtime_error(<span class="stringliteral">&quot;Non-absolute path&quot;</span>)); }
<a name="l02075"></a><a class="code" href="structasync__path__op__req.html#a03660fe32ffad9db2f2c9864ca21d37b">02075</a>     <a class="code" href="structasync__path__op__req.html#a03660fe32ffad9db2f2c9864ca21d37b" title="Constructs an instance.">async_path_op_req</a>(std::string _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags) { _validate(); }
<a name="l02081"></a><a class="code" href="structasync__path__op__req.html#aa8253bc55cb7108c5083671cb377a2d9">02081</a>     <a class="code" href="structasync__path__op__req.html#aa8253bc55cb7108c5083671cb377a2d9" title="Constructs an instance.">async_path_op_req</a>(async_io_op _precondition, std::string _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags), precondition(std::move(_precondition)) { _validate(); }
<a name="l02086"></a><a class="code" href="structasync__path__op__req.html#a80ed3677a2fb31bf82155f6d6519799a">02086</a>     <a class="code" href="structasync__path__op__req.html#a80ed3677a2fb31bf82155f6d6519799a" title="Constructs an instance.">async_path_op_req</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *_path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags) { _validate(); }
<a name="l02092"></a><a class="code" href="structasync__path__op__req.html#ae78240228df17dc8f805384b53ead54d">02092</a>     <a class="code" href="structasync__path__op__req.html#ae78240228df17dc8f805384b53ead54d" title="Constructs an instance.">async_path_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> <span class="keywordtype">char</span> *_path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags), precondition(std::move(_precondition)) { _validate(); }
<a name="l02094"></a><a class="code" href="structasync__path__op__req.html#abc282e406dc24df47df1938872558f2b">02094</a>     <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l02095"></a>02095 <span class="keyword">    </span>{
<a name="l02096"></a>02096         <span class="keywordflow">if</span>(path.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02097"></a>02097         <span class="keywordflow">return</span> !precondition.<a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df" title="A unique id for this operation.">id</a> || precondition.validate();
<a name="l02098"></a>02098     }
<a name="l02099"></a>02099 <span class="keyword">private</span>:
<a name="l02100"></a>02100     <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l02101"></a>02101 <span class="keyword">    </span>{
<a name="l02102"></a>02102 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l02103"></a>02103 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!validate())
<a name="l02104"></a>02104             BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l02105"></a>02105 <span class="preprocessor">#endif</span>
<a name="l02106"></a>02106 <span class="preprocessor"></span>    }
<a name="l02107"></a>02107 };
<a name="l02108"></a>02108 
<a name="l02109"></a>02109 <span class="keyword">namespace </span>detail
<a name="l02110"></a>02110 {
<a name="l02112"></a>02112     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> for_writing&gt; <span class="keyword">class </span>async_data_op_req_impl;
<a name="l02113"></a>02113     <span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>async_data_op_req_impl&lt;false&gt;
<a name="l02114"></a>02114     {
<a name="l02115"></a>02115     <span class="keyword">public</span>:
<a name="l02117"></a>02117         async_io_op precondition;
<a name="l02119"></a>02119         std::vector&lt;asio::mutable_buffer&gt; buffers;
<a name="l02121"></a>02121         off_t where;
<a name="l02123"></a>02123         async_data_op_req_impl() { }
<a name="l02125"></a>02125         async_data_op_req_impl(<span class="keyword">const</span> async_data_op_req_impl &amp;o) : precondition(o.precondition), buffers(o.buffers), where(o.where) { }
<a name="l02127"></a>02127         async_data_op_req_impl(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : precondition(std::move(o.precondition)), buffers(std::move(o.buffers)), where(std::move(o.where)) { }
<a name="l02129"></a>02129         async_data_op_req_impl &amp;operator=(<span class="keyword">const</span> async_data_op_req_impl &amp;o) { precondition=o.precondition; buffers=o.buffers; where=o.where; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02131"></a>02131         async_data_op_req_impl &amp;operator=(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { precondition=std::move(o.precondition); buffers=std::move(o.buffers); where=std::move(o.where); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02133"></a>02133         async_data_op_req_impl(async_io_op _precondition, <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : precondition(std::move(_precondition)), where(_where) { buffers.reserve(1); buffers.push_back(asio::mutable_buffer(v, _length)); _validate(); }
<a name="l02135"></a>02135         async_data_op_req_impl(async_io_op _precondition, std::vector&lt;asio::mutable_buffer&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::move(_buffers)), where(_where) { _validate(); }
<a name="l02137"></a>02137         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req_impl(async_io_op _precondition, std::array&lt;asio::mutable_buffer, N&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::make_move_iterator(_buffers.begin()), std::make_move_iterator(_buffers.end())), where(_where) { _validate(); }
<a name="l02139"></a>02139         async_data_op_req_impl(async_io_op _precondition, asio::mutable_buffer _buffer, off_t _where) : precondition(std::move(_precondition)), buffers(1, std::move(_buffer)), where(_where) { _validate(); }
<a name="l02141"></a>02141         <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l02142"></a>02142 <span class="keyword">        </span>{
<a name="l02143"></a>02143             <span class="keywordflow">if</span>(!precondition.validate()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02144"></a>02144             <span class="keywordflow">if</span>(buffers.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02145"></a>02145             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;b: buffers)
<a name="l02146"></a>02146             {
<a name="l02147"></a>02147                 <span class="keywordflow">if</span>(!asio::buffer_cast&lt;const void *&gt;(b) || !asio::buffer_size(b)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02148"></a>02148                 <span class="keywordflow">if</span>(!!(precondition.<a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19" title="The parent dispatcher.">parent</a>-&gt;fileflags(<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>)&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b" title="Bypass the OS file buffers (only really useful for writing large files, or a lot of random reads and ...">file_flags::OSDirect</a>))
<a name="l02149"></a>02149                 {
<a name="l02150"></a>02150                     <span class="keywordflow">if</span>(((<span class="keywordtype">size_t</span>) asio::buffer_cast&lt;<span class="keyword">const</span> <span class="keywordtype">void</span> *&gt;(b) &amp; 4095) || (asio::buffer_size(b) &amp; 4095)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02151"></a>02151                 }
<a name="l02152"></a>02152             }
<a name="l02153"></a>02153             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02154"></a>02154         }
<a name="l02155"></a>02155     <span class="keyword">private</span>:
<a name="l02156"></a>02156         <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l02157"></a>02157 <span class="keyword">        </span>{
<a name="l02158"></a>02158 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l02159"></a>02159 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!validate())
<a name="l02160"></a>02160                 BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l02161"></a>02161 <span class="preprocessor">#endif</span>
<a name="l02162"></a>02162 <span class="preprocessor"></span>        }
<a name="l02163"></a>02163     };
<a name="l02164"></a>02164     <span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>async_data_op_req_impl&lt;true&gt;
<a name="l02165"></a>02165     {
<a name="l02166"></a>02166     <span class="keyword">public</span>:
<a name="l02168"></a>02168         async_io_op precondition;
<a name="l02170"></a>02170         std::vector&lt;asio::const_buffer&gt; buffers;
<a name="l02172"></a>02172         off_t where;
<a name="l02174"></a>02174         async_data_op_req_impl() { }
<a name="l02176"></a>02176         async_data_op_req_impl(<span class="keyword">const</span> async_data_op_req_impl &amp;o) : precondition(o.precondition), buffers(o.buffers), where(o.where) { }
<a name="l02178"></a>02178         async_data_op_req_impl(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : precondition(std::move(o.precondition)), buffers(std::move(o.buffers)), where(std::move(o.where)) { }
<a name="l02180"></a>02180         async_data_op_req_impl(<span class="keyword">const</span> async_data_op_req_impl&lt;false&gt; &amp;o) : precondition(o.precondition), where(o.where) { buffers.reserve(o.buffers.capacity()); <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i: o.buffers){ buffers.push_back(i); } }
<a name="l02182"></a>02182         async_data_op_req_impl(async_data_op_req_impl&lt;false&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : precondition(std::move(o.precondition)), where(std::move(o.where)) { buffers.reserve(o.buffers.capacity()); <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;i: o.buffers){ buffers.push_back(std::move(i)); } }
<a name="l02184"></a>02184         async_data_op_req_impl &amp;operator=(<span class="keyword">const</span> async_data_op_req_impl &amp;o) { precondition=o.precondition; buffers=o.buffers; where=o.where; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02186"></a>02186         async_data_op_req_impl &amp;operator=(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { precondition=std::move(o.precondition); buffers=std::move(o.buffers); where=std::move(o.where); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02188"></a>02188         async_data_op_req_impl(async_io_op _precondition, <span class="keyword">const</span> <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : precondition(std::move(_precondition)), where(_where) { buffers.reserve(1); buffers.push_back(asio::const_buffer(v, _length)); _validate(); }
<a name="l02190"></a>02190         async_data_op_req_impl(async_io_op _precondition, std::vector&lt;asio::const_buffer&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::move(_buffers)), where(_where) { _validate(); }
<a name="l02192"></a>02192         async_data_op_req_impl(async_io_op _precondition, std::vector&lt;asio::mutable_buffer&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), where(_where)
<a name="l02193"></a>02193         {
<a name="l02194"></a>02194             buffers.reserve(_buffers.capacity());
<a name="l02195"></a>02195             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;i: _buffers)
<a name="l02196"></a>02196                 buffers.push_back(std::move(i));
<a name="l02197"></a>02197             _validate();
<a name="l02198"></a>02198         }
<a name="l02200"></a>02200         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req_impl(async_io_op _precondition, std::array&lt;asio::const_buffer, N&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::make_move_iterator(_buffers.begin()), std::make_move_iterator(_buffers.end())), where(_where) { _validate(); }
<a name="l02202"></a>02202         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req_impl(async_io_op _precondition, std::array&lt;asio::mutable_buffer, N&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), where(_where)
<a name="l02203"></a>02203         {
<a name="l02204"></a>02204             buffers.reserve(_buffers.size());
<a name="l02205"></a>02205             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;i: _buffers)
<a name="l02206"></a>02206                 buffers.push_back(std::move(i));
<a name="l02207"></a>02207             _validate();
<a name="l02208"></a>02208         }
<a name="l02210"></a>02210         async_data_op_req_impl(async_io_op _precondition, asio::const_buffer _buffer, off_t _where) : precondition(std::move(_precondition)), buffers(1, std::move(_buffer)), where(_where) { _validate(); }
<a name="l02212"></a>02212         <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l02213"></a>02213 <span class="keyword">        </span>{
<a name="l02214"></a>02214             <span class="keywordflow">if</span>(!precondition.validate()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02215"></a>02215             <span class="keywordflow">if</span>(buffers.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02216"></a>02216             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;b: buffers)
<a name="l02217"></a>02217             {
<a name="l02218"></a>02218                 <span class="keywordflow">if</span>(!asio::buffer_cast&lt;const void *&gt;(b) || !asio::buffer_size(b)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02219"></a>02219                 <span class="keywordflow">if</span>(!!(precondition.parent-&gt;fileflags(<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>)&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b" title="Bypass the OS file buffers (only really useful for writing large files, or a lot of random reads and ...">file_flags::OSDirect</a>))
<a name="l02220"></a>02220                 {
<a name="l02221"></a>02221                     <span class="keywordflow">if</span>(((<span class="keywordtype">size_t</span>) asio::buffer_cast&lt;<span class="keyword">const</span> <span class="keywordtype">void</span> *&gt;(b) &amp; 4095) || (asio::buffer_size(b) &amp; 4095)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02222"></a>02222                 }
<a name="l02223"></a>02223             }
<a name="l02224"></a>02224             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02225"></a>02225         }
<a name="l02226"></a>02226     <span class="keyword">private</span>:
<a name="l02227"></a>02227         <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l02228"></a>02228 <span class="keyword">        </span>{
<a name="l02229"></a>02229 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l02230"></a>02230 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!validate())
<a name="l02231"></a>02231                 BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l02232"></a>02232 <span class="preprocessor">#endif</span>
<a name="l02233"></a>02233 <span class="preprocessor"></span>        }
<a name="l02234"></a>02234     };
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02242"></a>02242 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_data_op_req : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02243"></a>02243 {
<a name="l02244"></a>02244 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02245"></a>02245 <span class="preprocessor"></span>
<a name="l02246"></a>02246     async_io_op precondition;
<a name="l02248"></a>02248     std::vector&lt;asio::mutable_buffer&gt; buffers;
<a name="l02250"></a>02250     off_t where;
<a name="l02251"></a>02251 <span class="preprocessor">#endif</span>
<a name="l02252"></a>02252 <span class="preprocessor"></span>
<a name="l02253"></a>02253     async_data_op_req()
<a name="l02254"></a>02254     {
<a name="l02255"></a>02255         static_assert(std::is_trivial&lt;T&gt;::value, <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; has not been specialised for this non-trivial type, which suggests you are trying to read or write a complex C++ type! Either add a custom specialisation, or directly instantiate an async_data_op_req with a void * and size_t length to some serialised representation.&quot;</span>);
<a name="l02256"></a>02256     }
<a name="l02258"></a>02258     async_data_op_req(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02260"></a>02260     async_data_op_req(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02262"></a>02262     async_data_op_req &amp;operator=(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02264"></a>02264     async_data_op_req &amp;operator=(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02266"></a>02266     async_data_op_req(async_io_op _precondition, T *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(v), _length, _where) { }
<a name="l02268"></a>02268     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req(async_io_op _precondition, T (&amp;v)[N], off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(v), N*sizeof(T), _where) { }
<a name="l02269"></a>02269 };
<a name="l02271"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html">02271</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_data_op_req&lt;const T&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02272"></a>02272 {
<a name="l02273"></a>02273 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02274"></a>02274 <span class="preprocessor"></span>
<a name="l02275"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8b4d9a3a897eaa4f987268131105d0c1">02275</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8b4d9a3a897eaa4f987268131105d0c1" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02277"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#aced07c86b9743bcfdebe3b90c3d62591">02277</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#aced07c86b9743bcfdebe3b90c3d62591" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02279"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ab952b695d73face205cf6fe447645939">02279</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ab952b695d73face205cf6fe447645939" title="The offset at which to write.">where</a>;
<a name="l02280"></a>02280 <span class="preprocessor">#endif</span>
<a name="l02281"></a>02281 <span class="preprocessor"></span>
<a name="l02282"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a738dc8039f2811ff5873b36270c0d90f">02282</a>     async_data_op_req()
<a name="l02283"></a>02283     {
<a name="l02284"></a>02284         static_assert(std::is_trivial&lt;T&gt;::value, <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; has not been specialised for this non-trivial type, which suggests you are trying to read or write a complex C++ type! Either add a custom specialisation, or directly instantiate an async_data_op_req with a void * and size_t length to some serialised representation.&quot;</span>);
<a name="l02285"></a>02285     }
<a name="l02287"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7702b989b18bf721f1dd76887e76cfc5">02287</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7702b989b18bf721f1dd76887e76cfc5" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02289"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a4510eef78c27390babaa17c3db95091f">02289</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a4510eef78c27390babaa17c3db95091f" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02291"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#abdd353984098f09cc6bbd1688b091c34">02291</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#abdd353984098f09cc6bbd1688b091c34" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;T&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02293"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8fc71db979d7c464f3805f89b4e2fe01">02293</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8fc71db979d7c464f3805f89b4e2fe01" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;T&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02295"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a1d2b3e0d72fc83efb6c853e62e4fd1f3">02295</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a1d2b3e0d72fc83efb6c853e62e4fd1f3" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02297"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a81da1f13244668e17b04b354e3411cb4">02297</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a81da1f13244668e17b04b354e3411cb4" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02299"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7fe9e15c8357b95da1e4c3459aecca6c">02299</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7fe9e15c8357b95da1e4c3459aecca6c" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> T *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(v), _length, _where) { }
<a name="l02301"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ae51742b31dd2cc992f050d02945a5edf">02301</a>     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ae51742b31dd2cc992f050d02945a5edf" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> T (&amp;v)[N], off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(v), N*sizeof(const T), _where) { }
<a name="l02302"></a>02302 };
<a name="l02304"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html">02304</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;void&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02305"></a>02305 {
<a name="l02306"></a>02306 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02307"></a>02307 <span class="preprocessor"></span>
<a name="l02308"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a9a3d4c33ace8a137f5575123d557b97e">02308</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a9a3d4c33ace8a137f5575123d557b97e" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02310"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a0eb7958a607f9f5441637e73ef95c5e9">02310</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a0eb7958a607f9f5441637e73ef95c5e9" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02312"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#aff95c1adec2bdf76a0b035871840c9a5">02312</a>     off_t <a class="code" href="structasync__data__op__req_3_01void_01_4.html#aff95c1adec2bdf76a0b035871840c9a5" title="The offset from which to read.">where</a>;
<a name="l02313"></a>02313 <span class="preprocessor">#endif</span>
<a name="l02314"></a>02314 <span class="preprocessor"></span>
<a name="l02315"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#aa558bd013d3594490913660ef0df0f84">02315</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#aa558bd013d3594490913660ef0df0f84" title="Default constructor.">async_data_op_req</a>() : detail::async_data_op_req_impl&lt;false&gt;() {}
<a name="l02317"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a6b529a7c9b285a4a9b875c7ff55816a2">02317</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a6b529a7c9b285a4a9b875c7ff55816a2" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) {}
<a name="l02319"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a4fea806b7e0a5586b0b387dbe7fc3710">02319</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a4fea806b7e0a5586b0b387dbe7fc3710" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) {}
<a name="l02321"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a7faede857bcf69cf930d9f8c95fbbcc5">02321</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a7faede857bcf69cf930d9f8c95fbbcc5" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), v, _length, _where) { }
<a name="l02323"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#af639bebe3826721588172364af0a0628">02323</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#af639bebe3826721588172364af0a0628" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;asio::mutable_buffer&gt; _buffers, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(_buffers), _where) { }
<a name="l02324"></a>02324 };
<a name="l02326"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html">02326</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;const void&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02327"></a>02327 {
<a name="l02328"></a>02328 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02329"></a>02329 <span class="preprocessor"></span>
<a name="l02330"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#aa53c260ce3a7681299932619543b13c7">02330</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#aa53c260ce3a7681299932619543b13c7" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02332"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a7e8f76f7b5ac4f366496b60a7fa7363b">02332</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a7e8f76f7b5ac4f366496b60a7fa7363b" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02334"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a81f74f0a9944e8b61ebe00e37119d1ad">02334</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a81f74f0a9944e8b61ebe00e37119d1ad" title="The offset at which to write.">where</a>;
<a name="l02335"></a>02335 <span class="preprocessor">#endif</span>
<a name="l02336"></a>02336 <span class="preprocessor"></span>
<a name="l02337"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a17fc278eb5804e1a89c2df7b7d30e797">02337</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a17fc278eb5804e1a89c2df7b7d30e797" title="Default constructor.">async_data_op_req</a>() : detail::async_data_op_req_impl&lt;true&gt;() {}
<a name="l02339"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a8f9db5191e5916f8b131a7571eb14aaf">02339</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a8f9db5191e5916f8b131a7571eb14aaf" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) {}
<a name="l02341"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#af0717c1869e7d5be6eb7ccf94a889ebb">02341</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#af0717c1869e7d5be6eb7ccf94a889ebb" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) {}
<a name="l02343"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#acf2bd064426fe9ac1e9978b8a2bec55e">02343</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#acf2bd064426fe9ac1e9978b8a2bec55e" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> <a class="code" href="structasync__data__op__req_3_01void_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `void *`. Data MUST stay arou...">async_data_op_req&lt;void&gt;</a> &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) {}
<a name="l02345"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ac3df6c3518a7c33be618ebd588949055">02345</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ac3df6c3518a7c33be618ebd588949055" title="Move constructor.">async_data_op_req</a>(<a class="code" href="structasync__data__op__req_3_01void_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `void *`. Data MUST stay arou...">async_data_op_req&lt;void&gt;</a> &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) {}
<a name="l02347"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ae0fcde818165bc41d923a15d58c54f73">02347</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ae0fcde818165bc41d923a15d58c54f73" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), v, _length, _where) {}
<a name="l02349"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ab3c43cd3df4250f3e6596cf84969e416">02349</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ab3c43cd3df4250f3e6596cf84969e416" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;asio::const_buffer&gt; _buffers, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), _buffers, _where) {}
<a name="l02350"></a>02350 };
<a name="l02352"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html">02352</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::vector&lt;T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02353"></a>02353 {
<a name="l02354"></a>02354 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02355"></a>02355 <span class="preprocessor"></span>
<a name="l02356"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a9db2f0540837497d4a74a9f9aa99249f">02356</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a9db2f0540837497d4a74a9f9aa99249f" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02358"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aec83c0f40f5da938e613bc1430f11f6e">02358</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aec83c0f40f5da938e613bc1430f11f6e" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02360"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afb9fabc95d35f67e787b57786ffcf02c">02360</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afb9fabc95d35f67e787b57786ffcf02c" title="The offset from which to read.">where</a>;
<a name="l02361"></a>02361 <span class="preprocessor">#endif</span>
<a name="l02362"></a>02362 <span class="preprocessor"></span>
<a name="l02363"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a195b101f57cfaf387a3dd32e569acb93">02363</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a195b101f57cfaf387a3dd32e569acb93" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02365"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aff540d1545e2637f9d37a56274d528c0">02365</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aff540d1545e2637f9d37a56274d528c0" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02367"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a4b845f1cec265bb75621119abb08a211">02367</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a4b845f1cec265bb75621119abb08a211" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02369"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aedc5dde6a41a422582735fadda7feea6">02369</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aedc5dde6a41a422582735fadda7feea6" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02371"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#adfa9d04476557664c362c326cd5eaa11">02371</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#adfa9d04476557664c362c326cd5eaa11" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02373"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a7a721ac1449a0a8ece653a124765611e">02373</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a7a721ac1449a0a8ece653a124765611e" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02374"></a>02374 };
<a name="l02376"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html">02376</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;const std::vector&lt;T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02377"></a>02377 {
<a name="l02378"></a>02378 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02379"></a>02379 <span class="preprocessor"></span>
<a name="l02380"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aebdd3b41b4a23ba0f1cb7165ebaddd75">02380</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aebdd3b41b4a23ba0f1cb7165ebaddd75" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02382"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a8006799ba08f6491079299e404c2d12b">02382</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a8006799ba08f6491079299e404c2d12b" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02384"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#acd50d8734e5bb4fc197da26c50071db7">02384</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#acd50d8734e5bb4fc197da26c50071db7" title="The offset at which to write.">where</a>;
<a name="l02385"></a>02385 <span class="preprocessor">#endif</span>
<a name="l02386"></a>02386 <span class="preprocessor"></span>
<a name="l02387"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a61c9e301eaf590af2fcb83c4593f29a1">02387</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a61c9e301eaf590af2fcb83c4593f29a1" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02389"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#abd8995c446dfa1d7f6b7346d4f708ac4">02389</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#abd8995c446dfa1d7f6b7346d4f708ac4" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02391"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a09f8468de149cefe3f4b9b7f2cfa1701">02391</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a09f8468de149cefe3f4b9b7f2cfa1701" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02393"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a913d0574ae7097d0b5482ec0eafe7249">02393</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a913d0574ae7097d0b5482ec0eafe7249" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::vector&lt;T, A&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02395"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aed5a52bdf30d6ca171f3135a41126feb">02395</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aed5a52bdf30d6ca171f3135a41126feb" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::vector&lt;T, A&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02397"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#ad5ad8e147f55a22be13f9e00b99c5017">02397</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#ad5ad8e147f55a22be13f9e00b99c5017" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02399"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a661702a38a8a78c15689790595cc21a6">02399</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a661702a38a8a78c15689790595cc21a6" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02401"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afa54d4431109c5b09ce1f59277d06332">02401</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afa54d4431109c5b09ce1f59277d06332" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> std::vector&lt;T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02402"></a>02402 };
<a name="l02404"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html">02404</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::array&lt;T, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02405"></a>02405 {
<a name="l02406"></a>02406 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02407"></a>02407 <span class="preprocessor"></span>
<a name="l02408"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#acb5ee9d7632ca61dfab1160835d19972">02408</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#acb5ee9d7632ca61dfab1160835d19972" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02410"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5fd23ea876988bbca4a89b7e84b9f4aa">02410</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5fd23ea876988bbca4a89b7e84b9f4aa" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02412"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a79b356b3e800ca045aba540d82891257">02412</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a79b356b3e800ca045aba540d82891257" title="The offset from which to read.">where</a>;
<a name="l02413"></a>02413 <span class="preprocessor">#endif</span>
<a name="l02414"></a>02414 <span class="preprocessor"></span>
<a name="l02415"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ac70890879b0c205062db792c4a355003">02415</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ac70890879b0c205062db792c4a355003" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02417"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4e5b046c0cac3f3440a8680e0f5fee31">02417</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4e5b046c0cac3f3440a8680e0f5fee31" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02419"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#aa7dbc72c6c7c3a2bfe80615545c1158e">02419</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#aa7dbc72c6c7c3a2bfe80615545c1158e" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02421"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4c42d29e8c40be8f1f71c7989584095d">02421</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4c42d29e8c40be8f1f71c7989584095d" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02423"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a21be2104ee4acfdbcc847190aa6c59c1">02423</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a21be2104ee4acfdbcc847190aa6c59c1" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02425"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5f99e325c396acbba17a571a104f70c3">02425</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5f99e325c396acbba17a571a104f70c3" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::array&lt;T, N&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02426"></a>02426 };
<a name="l02428"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html">02428</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;const std::array&lt;T, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02429"></a>02429 {
<a name="l02430"></a>02430 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02431"></a>02431 <span class="preprocessor"></span>
<a name="l02432"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a99f191975dc73ffb53dcc7d26fe992b5">02432</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a99f191975dc73ffb53dcc7d26fe992b5" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02434"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ae99a2152f6c647d77512167b05c18b3d">02434</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ae99a2152f6c647d77512167b05c18b3d" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02436"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#af77cca1ba0410f9350d08534f30081d8">02436</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#af77cca1ba0410f9350d08534f30081d8" title="The offset at which to write.">where</a>;
<a name="l02437"></a>02437 <span class="preprocessor">#endif</span>
<a name="l02438"></a>02438 <span class="preprocessor"></span>
<a name="l02439"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a7ed58b855c3121a7bf03564631e7ee51">02439</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a7ed58b855c3121a7bf03564631e7ee51" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02441"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a39f2cc7b884f5812ca586bc96ee6c2c0">02441</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a39f2cc7b884f5812ca586bc96ee6c2c0" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02443"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a63b99d8a9ac63251e4974dad7b5b2a08">02443</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a63b99d8a9ac63251e4974dad7b5b2a08" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02445"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a192d6df315e6d9e8c7a71f8390616396">02445</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a192d6df315e6d9e8c7a71f8390616396" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02447"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a29bb9526a7589b026b9f0119dc8c203a">02447</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a29bb9526a7589b026b9f0119dc8c203a" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02449"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a3867065cefffea7aef06ec3e1719b704">02449</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a3867065cefffea7aef06ec3e1719b704" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::array&lt;T, N&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02451"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a8f748d7b94cb78368011a01d409b6d1b">02451</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a8f748d7b94cb78368011a01d409b6d1b" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::array&lt;T, N&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02453"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a2a55626673c70fbd1da12a96bf6962c6">02453</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a2a55626673c70fbd1da12a96bf6962c6" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> std::array&lt;T, N&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02454"></a>02454 };
<a name="l02456"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html">02456</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::vector&lt;asio::mutable_buffer, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02457"></a>02457 {
<a name="l02458"></a>02458 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02459"></a>02459 <span class="preprocessor"></span>
<a name="l02460"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6e37945550d9a46c0be6d92d1c16b654">02460</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6e37945550d9a46c0be6d92d1c16b654" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02462"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a5c26fcd74b282d754cbfffaed20ace3f">02462</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a5c26fcd74b282d754cbfffaed20ace3f" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02464"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#ac9924a15aa7c81b7ad25de53531dd851">02464</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#ac9924a15aa7c81b7ad25de53531dd851" title="The offset from which to read.">where</a>;
<a name="l02465"></a>02465 <span class="preprocessor">#endif</span>
<a name="l02466"></a>02466 <span class="preprocessor"></span>
<a name="l02467"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a8596b5a26663e2c06b140ff574ced07a">02467</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a8596b5a26663e2c06b140ff574ced07a" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02469"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a215e023b2c26c9f17b1b102caf374aee">02469</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a215e023b2c26c9f17b1b102caf374aee" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02471"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#aff1df306f1f444b292ab1b2f76f641b4">02471</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#aff1df306f1f444b292ab1b2f76f641b4" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02473"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#adcf662b4d0482e51ef93c69fe2c00723">02473</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#adcf662b4d0482e51ef93c69fe2c00723" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02475"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6b543b32e6265fdffa3fff4e2f555375">02475</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6b543b32e6265fdffa3fff4e2f555375" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02477"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a35e5850e928e2404310439489fb66b75">02477</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a35e5850e928e2404310439489fb66b75" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;asio::mutable_buffer, A&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02478"></a>02478 };
<a name="l02480"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html">02480</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::vector&lt;asio::const_buffer, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02481"></a>02481 {
<a name="l02482"></a>02482 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02483"></a>02483 <span class="preprocessor"></span>
<a name="l02484"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a96aaef69a540855aa4af09d71777d26f">02484</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a96aaef69a540855aa4af09d71777d26f" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02486"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a32b9252bfb7b26c535b549a778d3551f">02486</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a32b9252bfb7b26c535b549a778d3551f" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02488"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ab1c9770402783c7fbccd4387ebc73010">02488</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ab1c9770402783c7fbccd4387ebc73010" title="The offset at which to write.">where</a>;
<a name="l02489"></a>02489 <span class="preprocessor">#endif</span>
<a name="l02490"></a>02490 <span class="preprocessor"></span>
<a name="l02491"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a9a41cdd9c1810a43645e4d10a5a15753">02491</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a9a41cdd9c1810a43645e4d10a5a15753" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02493"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a90d77633b50e21359689b0d8880309d4">02493</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a90d77633b50e21359689b0d8880309d4" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02495"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#aed50463a7d21774c7282a0c9ad30c1f1">02495</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#aed50463a7d21774c7282a0c9ad30c1f1" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02497"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ad2d687d997a66b5ae091fc67f7caef2f">02497</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ad2d687d997a66b5ae091fc67f7caef2f" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::vector&lt;asio::mutable_buffer, A&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02499"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a1cce8cc8b1f6e51a3d54298762adfde0">02499</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a1cce8cc8b1f6e51a3d54298762adfde0" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::vector&lt;asio::mutable_buffer, A&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02501"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a41c1e249c0f9fd93a77a4d4cb0453266">02501</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a41c1e249c0f9fd93a77a4d4cb0453266" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02503"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#abb1687dd8b9aa11b1efd13aa103e4d87">02503</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#abb1687dd8b9aa11b1efd13aa103e4d87" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02505"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a6b507d6b73a4f072464c336c6fa78681">02505</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A2&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a6b507d6b73a4f072464c336c6fa78681" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;T, A2&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02506"></a>02506 };
<a name="l02508"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html">02508</a> <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::array&lt;asio::mutable_buffer, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02509"></a>02509 {
<a name="l02510"></a>02510 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02511"></a>02511 <span class="preprocessor"></span>
<a name="l02512"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a25f18c4d46dd8fb6fbcf2d2a9c9b2eeb">02512</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a25f18c4d46dd8fb6fbcf2d2a9c9b2eeb" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02514"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a45d984e7a77aee860a7640ea22aa7c6d">02514</a>     std::array&lt;asio::mutable_buffer, N&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a45d984e7a77aee860a7640ea22aa7c6d" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02516"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9869697e2505b05e18a9faf58edd9549">02516</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9869697e2505b05e18a9faf58edd9549" title="The offset from which to read.">where</a>;
<a name="l02517"></a>02517 <span class="preprocessor">#endif</span>
<a name="l02518"></a>02518 <span class="preprocessor"></span>
<a name="l02519"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9c7c24fc70ee97db4870f723747c9783">02519</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9c7c24fc70ee97db4870f723747c9783" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02521"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#aab958fb56414e3609d5f8ae4bb82577d">02521</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#aab958fb56414e3609d5f8ae4bb82577d" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02523"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a8c44dbc38bc88ab78189bc918780e84d">02523</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a8c44dbc38bc88ab78189bc918780e84d" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02525"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#af82bcc3231f014ca8ea5898f00492a89">02525</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#af82bcc3231f014ca8ea5898f00492a89" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02527"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7e1f20afe25b60b7a9483db9d6d2342f">02527</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7e1f20afe25b60b7a9483db9d6d2342f" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02529"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7ffa120670eaed014318ba7cb68c0486">02529</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7ffa120670eaed014318ba7cb68c0486" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::array&lt;asio::mutable_buffer, N&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02530"></a>02530 };
<a name="l02532"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html">02532</a> <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::array&lt;asio::const_buffer, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02533"></a>02533 {
<a name="l02534"></a>02534 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02535"></a>02535 <span class="preprocessor"></span>
<a name="l02536"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a8c0e3c75ae0782316d2cc8513576e145">02536</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a8c0e3c75ae0782316d2cc8513576e145" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02538"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ac68c0ff61680ef02dedb28984f6857b7">02538</a>     std::array&lt;asio::const_buffer, N&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ac68c0ff61680ef02dedb28984f6857b7" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02540"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ab3a337449e3e644fd3ef0b716dae8555">02540</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ab3a337449e3e644fd3ef0b716dae8555" title="The offset at which to write.">where</a>;
<a name="l02541"></a>02541 <span class="preprocessor">#endif</span>
<a name="l02542"></a>02542 <span class="preprocessor"></span>
<a name="l02543"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a34171ac3e246df2d303a88515512b134">02543</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a34171ac3e246df2d303a88515512b134" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02545"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adf55b3d3bb7198e4ef97d3ab02572bb9">02545</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adf55b3d3bb7198e4ef97d3ab02572bb9" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02547"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a2592fce1ac89c75967f199adbab7f3b7">02547</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a2592fce1ac89c75967f199adbab7f3b7" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02549"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adcfbdc143dbaa9c0cc74dff5a38189fd">02549</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adcfbdc143dbaa9c0cc74dff5a38189fd" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::array&lt;asio::mutable_buffer, N&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02551"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a0c5111171d28ef4a8b25cb8169c3f760">02551</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a0c5111171d28ef4a8b25cb8169c3f760" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::array&lt;asio::mutable_buffer, N&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02553"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a5b7434d822be52057a5b97f60ad449bc">02553</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a5b7434d822be52057a5b97f60ad449bc" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02555"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a750966cc6b1ed8bd9d6b549503ddf830">02555</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a750966cc6b1ed8bd9d6b549503ddf830" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02557"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a728401f6d4cb93434b4340cdd5e3feeb">02557</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a728401f6d4cb93434b4340cdd5e3feeb" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::array&lt;T, N&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02558"></a>02558 };
<a name="l02560"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html">02560</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::basic_string&lt;C, T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02561"></a>02561 {
<a name="l02562"></a>02562 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02563"></a>02563 <span class="preprocessor"></span>
<a name="l02564"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a525ee986c7b2201e3d23c653ffa9b8f6">02564</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a525ee986c7b2201e3d23c653ffa9b8f6" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02566"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acdcaa44cd54feec5300ba413ec450ed9">02566</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acdcaa44cd54feec5300ba413ec450ed9" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02568"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acfd0a6074f911d2cf3f5e152fef64e9a">02568</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acfd0a6074f911d2cf3f5e152fef64e9a" title="The offset from which to read.">where</a>;
<a name="l02569"></a>02569 <span class="preprocessor">#endif</span>
<a name="l02570"></a>02570 <span class="preprocessor"></span>
<a name="l02571"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a0b60afc2d284899ab71bb12119ca1ddb">02571</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a0b60afc2d284899ab71bb12119ca1ddb" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02573"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a456015d21af288631910efa3498979ea">02573</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a456015d21af288631910efa3498979ea" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02575"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#abfeadd2c0ae3cc72ecc95f8a7104e85f">02575</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#abfeadd2c0ae3cc72ecc95f8a7104e85f" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02577"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ae093a1705c26004807fa45935070e7c7">02577</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ae093a1705c26004807fa45935070e7c7" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02579"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e409e11c523f5db6ca3835eda85e4fc">02579</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e409e11c523f5db6ca3835eda85e4fc" title="Move constructor.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02581"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aaea31ce0a843abb2d4f0442e074e0a06">02581</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aaea31ce0a843abb2d4f0442e074e0a06" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::basic_string&lt;C, T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(&amp;v.front()), v.size()*sizeof(A), _where) { }
<a name="l02582"></a>02582 };
<a name="l02584"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html">02584</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;const std::basic_string&lt;C, T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02585"></a>02585 {
<a name="l02586"></a>02586 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02587"></a>02587 <span class="preprocessor"></span>
<a name="l02588"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a2cfcd5b994620baf0a5757a629dce484">02588</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a2cfcd5b994620baf0a5757a629dce484" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02590"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ac62b80afd1757f4f84024528612c7e12">02590</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ac62b80afd1757f4f84024528612c7e12" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02592"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acddd1a08ec4238e3e81f799debc0eeee">02592</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acddd1a08ec4238e3e81f799debc0eeee" title="The offset at which to write.">where</a>;
<a name="l02593"></a>02593 <span class="preprocessor">#endif</span>
<a name="l02594"></a>02594 <span class="preprocessor"></span>
<a name="l02595"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aca6fd4e13e3bc7ae145a32ef42497484">02595</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aca6fd4e13e3bc7ae145a32ef42497484" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02597"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a46fc7c368c2f03510e4e2763a44a515b">02597</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a46fc7c368c2f03510e4e2763a44a515b" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02599"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9808c756f3772dfb1b76b8927b673ed1">02599</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9808c756f3772dfb1b76b8927b673ed1" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02601"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e3527b1237141911c14413c2ffc1587">02601</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e3527b1237141911c14413c2ffc1587" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::basic_string&lt;C, T, A&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02603"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a30b8e47a54718fb9aec6a683d7495759">02603</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a30b8e47a54718fb9aec6a683d7495759" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::basic_string&lt;C, T, A&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02605"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acaa4bbc37f047955586c59251d3d1606">02605</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acaa4bbc37f047955586c59251d3d1606" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02607"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9be210fd68569fd3ca98bf90701c951a">02607</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9be210fd68569fd3ca98bf90701c951a" title="Move constructor.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02609"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a60a2dfab6ba9465922bda18f28275b49">02609</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a60a2dfab6ba9465922bda18f28275b49" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> std::basic_string&lt;C, T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(&amp;v.front()), v.size()*sizeof(A), _where) { }
<a name="l02610"></a>02610 };
<a name="l02612"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html">02612</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;asio::mutable_buffer&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02613"></a>02613 {
<a name="l02614"></a>02614 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02615"></a>02615 <span class="preprocessor"></span>
<a name="l02616"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#adb72dc04c894f589cfa11e06033986b7">02616</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#adb72dc04c894f589cfa11e06033986b7" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02618"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a00e9df53735d13ba23cbffde07c2208d">02618</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a00e9df53735d13ba23cbffde07c2208d" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02620"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a352c10c1eb0578e6c34b18782986c9f1">02620</a>     off_t <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a352c10c1eb0578e6c34b18782986c9f1" title="The offset from which to read.">where</a>;
<a name="l02621"></a>02621 <span class="preprocessor">#endif</span>
<a name="l02622"></a>02622 <span class="preprocessor"></span>
<a name="l02623"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a48efb4aae104a4776026bad1359648f6">02623</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a48efb4aae104a4776026bad1359648f6" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02625"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a923630dbc44914a9175d14d4dcc2b390">02625</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a923630dbc44914a9175d14d4dcc2b390" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02627"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a61b1903a93a23c18bb2e457ad16a005a">02627</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a61b1903a93a23c18bb2e457ad16a005a" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02629"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a18ab52f4d6cdff6d764e88024b2f402f">02629</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a18ab52f4d6cdff6d764e88024b2f402f" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02631"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a57b2fed7167367325c5805ee099aec20">02631</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a57b2fed7167367325c5805ee099aec20" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02633"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a2d3c8951978e6882c52d95419959debc">02633</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a2d3c8951978e6882c52d95419959debc" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, asio::mutable_buffer v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02634"></a>02634 };
<a name="l02636"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html">02636</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;asio::const_buffer&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02637"></a>02637 {
<a name="l02638"></a>02638 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02639"></a>02639 <span class="preprocessor"></span>
<a name="l02640"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac62a9510152febe5b52cdf8ded4c50e4">02640</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac62a9510152febe5b52cdf8ded4c50e4" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02642"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b3f627ff6d124d636256791ddd4ce20">02642</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b3f627ff6d124d636256791ddd4ce20" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02644"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a717d51ec0e38a5f74a0cc73f2369df15">02644</a>     off_t <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a717d51ec0e38a5f74a0cc73f2369df15" title="The offset at which to write.">where</a>;
<a name="l02645"></a>02645 <span class="preprocessor">#endif</span>
<a name="l02646"></a>02646 <span class="preprocessor"></span>
<a name="l02647"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a44b751cb7871080e9cec788ce1676a8f">02647</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a44b751cb7871080e9cec788ce1676a8f" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02649"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b7ef7381fdee258c3586a5a90fd279c">02649</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b7ef7381fdee258c3586a5a90fd279c" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02651"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac0122ab2255985f00f34fdf66ae960ec">02651</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac0122ab2255985f00f34fdf66ae960ec" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02653"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a453629ca791dfbb313c17c7bbce30644">02653</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a453629ca791dfbb313c17c7bbce30644" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `asio::mutable_buffer`. Data MUST stay around until the operation completes.">async_data_op_req&lt;asio::mutable_buffer&gt;</a> &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02655"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8fbcbd3b18b16f3cc65cee4060d29476">02655</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8fbcbd3b18b16f3cc65cee4060d29476" title="Move constructor.">async_data_op_req</a>(<a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `asio::mutable_buffer`. Data MUST stay around until the operation completes.">async_data_op_req&lt;asio::mutable_buffer&gt;</a> &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02657"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a3c20c6a7d30faa80c9363ee4c38c8744">02657</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a3c20c6a7d30faa80c9363ee4c38c8744" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02659"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a4d72d72cb0c7cb9b7ae48ce3b6b368d8">02659</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a4d72d72cb0c7cb9b7ae48ce3b6b368d8" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02661"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a2afaf95515131055772953aab880a193">02661</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a2afaf95515131055772953aab880a193" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, T v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02662"></a>02662 };
<a name="l02663"></a>02663 
<a name="l02675"></a><a class="code" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e">02675</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_data_op_req&lt;typename std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type&gt; <a class="code" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e" title="Convenience instantiator of a async_data_op_req, letting the compiler deduce the template specialisat...">make_async_data_op_req</a>(async_io_op _precondition, T &amp;&amp;v, off_t _where)
<a name="l02676"></a>02676 {
<a name="l02677"></a>02677     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type _T;
<a name="l02678"></a>02678     <span class="keywordflow">return</span> async_data_op_req&lt;_T&gt;(_precondition, v, _where);
<a name="l02679"></a>02679 }
<a name="l02692"></a><a class="code" href="group__make__async__data__op__req.html#ga7a472d3abdf6c990c3475b8c120863dc">02692</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_data_op_req&lt;typename std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type&gt; <a class="code" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e" title="Convenience instantiator of a async_data_op_req, letting the compiler deduce the template specialisat...">make_async_data_op_req</a>(async_io_op _precondition, T &amp;&amp;v, <span class="keywordtype">size_t</span> _length, off_t _where)
<a name="l02693"></a>02693 {
<a name="l02694"></a>02694     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type _T;
<a name="l02695"></a>02695     <span class="keywordflow">return</span> async_data_op_req&lt;_T&gt;(_precondition, v, _length, _where);
<a name="l02696"></a>02696 }
<a name="l02697"></a>02697 
<a name="l02698"></a>02698 
<a name="l02712"></a><a class="code" href="structasync__enumerate__op__req.html">02712</a> <span class="keyword">struct </span><a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>
<a name="l02713"></a>02713 {
<a name="l02714"></a><a class="code" href="structasync__enumerate__op__req.html#a7e93fbb402a04aa4e349a2c5d05ff143">02714</a>     async_io_op <a class="code" href="structasync__enumerate__op__req.html#a7e93fbb402a04aa4e349a2c5d05ff143" title="A precondition for this operation.">precondition</a>;    
<a name="l02715"></a><a class="code" href="structasync__enumerate__op__req.html#a3f3c1f47214de54e22394910e410ad61">02715</a>     <span class="keywordtype">size_t</span> <a class="code" href="structasync__enumerate__op__req.html#a3f3c1f47214de54e22394910e410ad61" title="The maximum number of items to return in this request. Note that setting to one will often invoke two...">maxitems</a>;             
<a name="l02716"></a><a class="code" href="structasync__enumerate__op__req.html#afa340706a6f1ec9fa79583f5d2d89017">02716</a>     <span class="keywordtype">bool</span> <a class="code" href="structasync__enumerate__op__req.html#afa340706a6f1ec9fa79583f5d2d89017" title="Restarts the enumeration for this open directory handle.">restart</a>;                
<a name="l02717"></a><a class="code" href="structasync__enumerate__op__req.html#afe7743a44c86fbf2be24527f314ebcad">02717</a>     filesystem::path <a class="code" href="structasync__enumerate__op__req.html#afe7743a44c86fbf2be24527f314ebcad" title="An optional shell glob by which to filter the items returned. Done kernel side on Windows...">glob</a>;  
<a name="l02718"></a><a class="code" href="structasync__enumerate__op__req.html#a58c3b318b33c65d99964e4ba944162d8">02718</a>     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> metadata;     
<a name="l02719"></a>02719 
<a name="l02720"></a>02720     <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>() : maxitems(0), restart(false), metadata(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>::<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>) { }
<a name="l02729"></a><a class="code" href="structasync__enumerate__op__req.html#acd207be41eb88727b5087a35b872c1dd">02729</a>     <a class="code" href="structasync__enumerate__op__req.html#acd207be41eb88727b5087a35b872c1dd" title="Constructs an instance.">async_enumerate_op_req</a>(async_io_op _precondition, <span class="keywordtype">size_t</span> _maxitems=2, <span class="keywordtype">bool</span> _restart=<span class="keyword">true</span>, filesystem::path _glob=filesystem::path(), <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _metadata=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">metadata_flags::None</a>) : precondition(std::move(_precondition)), maxitems(_maxitems), restart(_restart), glob(std::move(_glob)), metadata(_metadata) { _validate(); }
<a name="l02738"></a><a class="code" href="structasync__enumerate__op__req.html#a76dfe1869add53f3bfe533ac2c998bad">02738</a>     <a class="code" href="structasync__enumerate__op__req.html#a76dfe1869add53f3bfe533ac2c998bad" title="Constructs an instance.">async_enumerate_op_req</a>(async_io_op _precondition, filesystem::path _glob, <span class="keywordtype">size_t</span> _maxitems=2, <span class="keywordtype">bool</span> _restart=<span class="keyword">true</span>, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _metadata=<a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4eac7485dcc8d256a6f197ed7802687f252" title="No flags set.">metadata_flags::None</a>) : precondition(std::move(_precondition)), maxitems(_maxitems), restart(_restart), glob(std::move(_glob)), metadata(_metadata) { _validate(); }
<a name="l02747"></a><a class="code" href="structasync__enumerate__op__req.html#acf7ec47be195a0210ec9f3d3b1221247">02747</a>     <a class="code" href="structasync__enumerate__op__req.html#acf7ec47be195a0210ec9f3d3b1221247" title="Constructs an instance.">async_enumerate_op_req</a>(async_io_op _precondition, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _metadata, <span class="keywordtype">size_t</span> _maxitems=2, <span class="keywordtype">bool</span> _restart=<span class="keyword">true</span>, filesystem::path _glob=filesystem::path()) : precondition(std::move(_precondition)), maxitems(_maxitems), restart(_restart), glob(std::move(_glob)), metadata(_metadata) { _validate(); }
<a name="l02749"></a><a class="code" href="structasync__enumerate__op__req.html#a3609173f9d91cfaefa842d3e2d86165b">02749</a>     <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l02750"></a>02750 <span class="keyword">    </span>{
<a name="l02751"></a>02751         <span class="keywordflow">if</span>(!maxitems) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02752"></a>02752         <span class="keywordflow">return</span> !precondition.id || precondition.validate();
<a name="l02753"></a>02753     }
<a name="l02754"></a>02754 <span class="keyword">private</span>:
<a name="l02755"></a>02755     <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l02756"></a>02756 <span class="keyword">    </span>{
<a name="l02757"></a>02757 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l02758"></a>02758 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!validate())
<a name="l02759"></a>02759             BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l02760"></a>02760 <span class="preprocessor">#endif</span>
<a name="l02761"></a>02761 <span class="preprocessor"></span>    }
<a name="l02762"></a>02762 };
<a name="l02763"></a>02763 
<a name="l02764"></a>02764 
<a name="l02765"></a>02765 <span class="keyword">namespace </span>detail {
<a name="l02766"></a>02766     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> iswrite, <span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_file_io_dispatcher_rwconverter
<a name="l02767"></a>02767     {
<a name="l02768"></a>02768         <span class="keyword">typedef</span> detail::async_data_op_req_impl&lt;iswrite&gt; return_type;
<a name="l02769"></a>02769         <span class="keyword">const</span> std::vector&lt;return_type&gt; &amp;operator()(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops)
<a name="l02770"></a>02770         {
<a name="l02771"></a>02771             <span class="keyword">typedef</span> async_data_op_req&lt;T&gt; reqT;
<a name="l02772"></a>02772             static_assert(std::is_convertible&lt;reqT, return_type&gt;::value, <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; is not convertible to detail::async_data_op_req_impl&lt;constness&gt;&quot;</span>);
<a name="l02773"></a>02773             static_assert(<span class="keyword">sizeof</span>(return_type)==<span class="keyword">sizeof</span>(reqT), <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; does not have the same size as detail::async_data_op_req_impl&lt;constness&gt;&quot;</span>);
<a name="l02774"></a>02774             <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::vector&lt;return_type&gt; &amp;<span class="keyword">&gt;</span>(ops);
<a name="l02775"></a>02775         }
<a name="l02776"></a>02776     };
<a name="l02777"></a>02777 }
<a name="l02778"></a>02778 
<a name="l02779"></a>02779 <span class="preprocessor">#if defined(BOOST_AFIO_ENABLE_BENCHMARKING_COMPLETION) // Only really used for benchmarking</span>
<a name="l02780"></a>02780 <span class="preprocessor"></span><span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt; &amp;callback)
<a name="l02781"></a>02781 {
<a name="l02782"></a>02782     std::vector&lt;async_io_op&gt; r;
<a name="l02783"></a>02783     std::vector&lt;std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt;&gt; i;
<a name="l02784"></a>02784     r.reserve(1); i.reserve(1);
<a name="l02785"></a>02785     r.push_back(req);
<a name="l02786"></a>02786     i.push_back(callback);
<a name="l02787"></a>02787     <span class="keywordflow">return</span> std::move(completion(r, i).front());
<a name="l02788"></a>02788 }
<a name="l02789"></a>02789 <span class="preprocessor">#endif</span>
<a name="l02790"></a>02790 <span class="preprocessor"></span><span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt; &amp;callback)
<a name="l02791"></a>02791 {
<a name="l02792"></a>02792     std::vector&lt;async_io_op&gt; r;
<a name="l02793"></a>02793     std::vector&lt;std::pair&lt;async_op_flags, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt;&gt; i;
<a name="l02794"></a>02794     r.reserve(1); i.reserve(1);
<a name="l02795"></a>02795     r.push_back(req);
<a name="l02796"></a>02796     i.push_back(callback);
<a name="l02797"></a>02797     <span class="keywordflow">return</span> std::move(completion(r, i).front());
<a name="l02798"></a>02798 }
<a name="l02799"></a>02799 <span class="keyword">namespace </span>detail {
<a name="l02800"></a>02800     <span class="keyword">template</span>&lt;<span class="keyword">class</span> tasktype&gt; std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; doCall(<span class="keywordtype">size_t</span>, async_io_op _, std::shared_ptr&lt;tasktype&gt; c)
<a name="l02801"></a>02801     {
<a name="l02802"></a>02802         (*c)();
<a name="l02803"></a>02803         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, _.get(<span class="keyword">true</span>));
<a name="l02804"></a>02804     }
<a name="l02805"></a>02805 }
<a name="l02806"></a>02806 <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables)
<a name="l02807"></a>02807 {
<a name="l02808"></a>02808     <span class="keyword">typedef</span> <a class="code" href="classenqueued__task_3_01_r_07_08_4.html">enqueued_task&lt;R()&gt;</a> tasktype;
<a name="l02809"></a>02809     std::vector&lt;shared_future&lt;R&gt;&gt; retfutures;
<a name="l02810"></a>02810     std::vector&lt;std::pair&lt;async_op_flags, std::function&lt;completion_t&gt;&gt;&gt; callbacks;
<a name="l02811"></a>02811     retfutures.reserve(callables.size());
<a name="l02812"></a>02812     callbacks.reserve(callables.size());
<a name="l02813"></a>02813     
<a name="l02814"></a>02814     <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;t: callables)
<a name="l02815"></a>02815     {
<a name="l02816"></a>02816         std::shared_ptr&lt;tasktype&gt; c(std::make_shared&lt;tasktype&gt;(std::function&lt;R()&gt;(t)));
<a name="l02817"></a>02817         retfutures.push_back(c-&gt;get_future());
<a name="l02818"></a>02818         callbacks.push_back(std::make_pair(<a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0" title="No flags set.">async_op_flags::none</a>, std::bind(&amp;detail::doCall&lt;tasktype&gt;, std::placeholders::_1, std::placeholders::_2, std::move(c))));
<a name="l02819"></a>02819     }
<a name="l02820"></a>02820     <span class="keywordflow">return</span> std::make_pair(std::move(retfutures), completion(ops, callbacks));
<a name="l02821"></a>02821 }
<a name="l02822"></a>02822 <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;R&gt;, async_io_op&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> async_io_op &amp;req, std::function&lt;R()&gt; callback)
<a name="l02823"></a>02823 {
<a name="l02824"></a>02824     std::vector&lt;async_io_op&gt; i;
<a name="l02825"></a>02825     std::vector&lt;std::function&lt;R()&gt;&gt; c;
<a name="l02826"></a>02826     i.reserve(1); c.reserve(1);
<a name="l02827"></a>02827     i.push_back(req);
<a name="l02828"></a>02828     c.push_back(std::move(callback));
<a name="l02829"></a>02829     std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; ret(call(i, c));
<a name="l02830"></a>02830     <span class="keywordflow">return</span> std::make_pair(std::move(ret.first.front()), ret.second.front());
<a name="l02831"></a>02831 }
<a name="l02832"></a>02832 
<a name="l02833"></a>02833 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02834"></a>02834 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> detail::vs2013_variadic_overload_resolution_workaround&lt;C, Args...&gt;::type&gt;, async_io_op&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args)
<a name="l02835"></a>02835 <span class="preprocessor">#else</span>
<a name="l02836"></a>02836 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type&gt;, async_io_op&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args)
<a name="l02837"></a>02837 <span class="preprocessor">#endif</span>
<a name="l02838"></a>02838 <span class="preprocessor"></span>{
<a name="l02839"></a>02839     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type rettype;
<a name="l02840"></a>02840     <span class="keywordflow">return</span> call(req, std::function&lt;rettype()&gt;(std::bind&lt;rettype&gt;(callback, args...)));
<a name="l02841"></a>02841 }
<a name="l02842"></a>02842 
<a name="l02843"></a>02843 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::adopt(std::shared_ptr&lt;async_io_handle&gt; h)
<a name="l02844"></a>02844 {
<a name="l02845"></a>02845     std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; i;
<a name="l02846"></a>02846     i.reserve(1);
<a name="l02847"></a>02847     i.push_back(std::move(h));
<a name="l02848"></a>02848     <span class="keywordflow">return</span> std::move(adopt(i).front());
<a name="l02849"></a>02849 }
<a name="l02850"></a>02850 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::dir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02851"></a>02851 {
<a name="l02852"></a>02852     std::vector&lt;async_path_op_req&gt; i;
<a name="l02853"></a>02853     i.reserve(1);
<a name="l02854"></a>02854     i.push_back(req);
<a name="l02855"></a>02855     <span class="keywordflow">return</span> std::move(dir(i).front());
<a name="l02856"></a>02856 }
<a name="l02857"></a>02857 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::rmdir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02858"></a>02858 {
<a name="l02859"></a>02859     std::vector&lt;async_path_op_req&gt; i;
<a name="l02860"></a>02860     i.reserve(1);
<a name="l02861"></a>02861     i.push_back(req);
<a name="l02862"></a>02862     <span class="keywordflow">return</span> std::move(rmdir(i).front());
<a name="l02863"></a>02863 }
<a name="l02864"></a>02864 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::file(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02865"></a>02865 {
<a name="l02866"></a>02866     std::vector&lt;async_path_op_req&gt; i;
<a name="l02867"></a>02867     i.reserve(1);
<a name="l02868"></a>02868     i.push_back(req);
<a name="l02869"></a>02869     <span class="keywordflow">return</span> std::move(file(i).front());
<a name="l02870"></a>02870 }
<a name="l02871"></a>02871 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::rmfile(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02872"></a>02872 {
<a name="l02873"></a>02873     std::vector&lt;async_path_op_req&gt; i;
<a name="l02874"></a>02874     i.reserve(1);
<a name="l02875"></a>02875     i.push_back(req);
<a name="l02876"></a>02876     <span class="keywordflow">return</span> std::move(rmfile(i).front());
<a name="l02877"></a>02877 }
<a name="l02878"></a>02878 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::symlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02879"></a>02879 {
<a name="l02880"></a>02880     std::vector&lt;async_path_op_req&gt; i;
<a name="l02881"></a>02881     i.reserve(1);
<a name="l02882"></a>02882     i.push_back(req);
<a name="l02883"></a>02883     <span class="keywordflow">return</span> std::move(symlink(i).front());
<a name="l02884"></a>02884 }
<a name="l02885"></a>02885 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::rmsymlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02886"></a>02886 {
<a name="l02887"></a>02887     std::vector&lt;async_path_op_req&gt; i;
<a name="l02888"></a>02888     i.reserve(1);
<a name="l02889"></a>02889     i.push_back(req);
<a name="l02890"></a>02890     <span class="keywordflow">return</span> std::move(rmsymlink(i).front());
<a name="l02891"></a>02891 }
<a name="l02892"></a>02892 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::sync(<span class="keyword">const</span> async_io_op &amp;req)
<a name="l02893"></a>02893 {
<a name="l02894"></a>02894     std::vector&lt;async_io_op&gt; i;
<a name="l02895"></a>02895     i.reserve(1);
<a name="l02896"></a>02896     i.push_back(req);
<a name="l02897"></a>02897     <span class="keywordflow">return</span> std::move(sync(i).front());
<a name="l02898"></a>02898 }
<a name="l02899"></a>02899 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::zero(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt; &amp;ranges)
<a name="l02900"></a>02900 {
<a name="l02901"></a>02901     std::vector&lt;async_io_op&gt; i;
<a name="l02902"></a>02902     std::vector&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt; r;
<a name="l02903"></a>02903     i.reserve(1);
<a name="l02904"></a>02904     i.push_back(req);
<a name="l02905"></a>02905     r.reserve(1);
<a name="l02906"></a>02906     r.push_back(ranges);
<a name="l02907"></a>02907     <span class="keywordflow">return</span> std::move(zero(i, r).front());
<a name="l02908"></a>02908 }
<a name="l02909"></a>02909 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::close(<span class="keyword">const</span> async_io_op &amp;req)
<a name="l02910"></a>02910 {
<a name="l02911"></a>02911     std::vector&lt;async_io_op&gt; i;
<a name="l02912"></a>02912     i.reserve(1);
<a name="l02913"></a>02913     i.push_back(req);
<a name="l02914"></a>02914     <span class="keywordflow">return</span> std::move(close(i).front());
<a name="l02915"></a>02915 }
<a name="l02916"></a>02916 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02917"></a>02917 <span class="preprocessor"></span><span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::read(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;false&gt; &amp;req)
<a name="l02918"></a>02918 {
<a name="l02919"></a>02919     std::vector&lt;detail::async_data_op_req_impl&lt;false&gt;&gt; i;
<a name="l02920"></a>02920     i.reserve(1);
<a name="l02921"></a>02921     i.push_back(req);
<a name="l02922"></a>02922     <span class="keywordflow">return</span> std::move(read(i).front());
<a name="l02923"></a>02923 }
<a name="l02924"></a>02924 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::write(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;true&gt; &amp;req)
<a name="l02925"></a>02925 {
<a name="l02926"></a>02926     std::vector&lt;detail::async_data_op_req_impl&lt;true&gt;&gt; i;
<a name="l02927"></a>02927     i.reserve(1);
<a name="l02928"></a>02928     i.push_back(req);
<a name="l02929"></a>02929     <span class="keywordflow">return</span> std::move(write(i).front());
<a name="l02930"></a>02930 }
<a name="l02931"></a>02931 <span class="preprocessor">#endif</span>
<a name="l02932"></a>02932 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> std::vector&lt;async_io_op&gt; async_file_io_dispatcher_base::read(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops)
<a name="l02933"></a>02933 {
<a name="l02934"></a>02934     <span class="keywordflow">return</span> read(detail::async_file_io_dispatcher_rwconverter&lt;false, T&gt;()(ops));
<a name="l02935"></a>02935 }
<a name="l02936"></a>02936 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> std::vector&lt;async_io_op&gt; async_file_io_dispatcher_base::write(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops)
<a name="l02937"></a>02937 {
<a name="l02938"></a>02938     <span class="keywordflow">return</span> write(detail::async_file_io_dispatcher_rwconverter&lt;true, T&gt;()(ops));
<a name="l02939"></a>02939 }
<a name="l02940"></a>02940 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::truncate(<span class="keyword">const</span> async_io_op &amp;op, off_t newsize)
<a name="l02941"></a>02941 {
<a name="l02942"></a>02942     std::vector&lt;async_io_op&gt; o;
<a name="l02943"></a>02943     std::vector&lt;off_t&gt; i;
<a name="l02944"></a>02944     o.reserve(1);
<a name="l02945"></a>02945     o.push_back(op);
<a name="l02946"></a>02946     i.reserve(1);
<a name="l02947"></a>02947     i.push_back(newsize);
<a name="l02948"></a>02948     <span class="keywordflow">return</span> std::move(truncate(o, i).front());
<a name="l02949"></a>02949 }
<a name="l02950"></a>02950 <span class="keyword">inline</span> std::pair&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;, async_io_op&gt; async_file_io_dispatcher_base::enumerate(<span class="keyword">const</span> <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a> &amp;req)
<a name="l02951"></a>02951 {
<a name="l02952"></a>02952     std::vector&lt;async_enumerate_op_req&gt; i;
<a name="l02953"></a>02953     i.reserve(1);
<a name="l02954"></a>02954     i.push_back(req);
<a name="l02955"></a>02955     <span class="keyword">auto</span> ret=enumerate(i);
<a name="l02956"></a>02956     <span class="keywordflow">return</span> std::make_pair(std::move(ret.first.front()), std::move(ret.second.front()));
<a name="l02957"></a>02957 }
<a name="l02958"></a>02958 <span class="keyword">inline</span> std::pair&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt;&gt;&gt;, async_io_op&gt; async_file_io_dispatcher_base::extents(<span class="keyword">const</span> async_io_op &amp;op)
<a name="l02959"></a>02959 {
<a name="l02960"></a>02960     std::vector&lt;async_io_op&gt; o;
<a name="l02961"></a>02961     o.reserve(1);
<a name="l02962"></a>02962     o.push_back(op);
<a name="l02963"></a>02963     <span class="keyword">auto</span> ret=extents(o);
<a name="l02964"></a>02964     <span class="keywordflow">return</span> std::make_pair(std::move(ret.first.front()), std::move(ret.second.front()));
<a name="l02965"></a>02965 }
<a name="l02966"></a>02966 <span class="keyword">inline</span> std::pair&lt;future&lt;statfs_t&gt;, async_io_op&gt; async_file_io_dispatcher_base::statfs(<span class="keyword">const</span> async_io_op &amp;op, <span class="keyword">const</span> <a class="code" href="afio_8hpp.html#aae6b08a811dd41617f875ab167b21d4e" title="Bitflags for availability of metadata from `struct statfs_t`.">fs_metadata_flags</a> &amp;req)
<a name="l02967"></a>02967 {
<a name="l02968"></a>02968   std::vector&lt;async_io_op&gt; o;
<a name="l02969"></a>02969   std::vector&lt;fs_metadata_flags&gt; i;
<a name="l02970"></a>02970   o.reserve(1);
<a name="l02971"></a>02971   o.push_back(op);
<a name="l02972"></a>02972   i.reserve(1);
<a name="l02973"></a>02973   i.push_back(req);
<a name="l02974"></a>02974   <span class="keyword">auto</span> ret = statfs(o, i);
<a name="l02975"></a>02975   <span class="keywordflow">return</span> std::make_pair(std::move(ret.first.front()), std::move(ret.second.front()));
<a name="l02976"></a>02976 }
<a name="l02977"></a>02977 
<a name="l02978"></a>02978 
<a name="l02979"></a>02979 BOOST_AFIO_V1_NAMESPACE_END
<a name="l02980"></a>02980 
<a name="l02981"></a>02981 <span class="comment">// Specialise std::hash&lt;&gt; for directory_entry</span>
<a name="l02982"></a>02982 <span class="preprocessor">#ifndef BOOST_AFIO_DISABLE_STD_HASH_SPECIALIZATION</span>
<a name="l02983"></a>02983 <span class="preprocessor"></span><span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l02984"></a>02984 <span class="keyword">namespace </span>std
<a name="l02985"></a>02985 {
<a name="l02986"></a>02986     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>hash&lt;BOOST_AFIO_V1_NAMESPACE::<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&gt;
<a name="l02987"></a>02987     {
<a name="l02988"></a>02988     <span class="keyword">public</span>:
<a name="l02989"></a>02989         <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> BOOST_AFIO_V1_NAMESPACE::directory_entry &amp;p)<span class="keyword"> const</span>
<a name="l02990"></a>02990 <span class="keyword">        </span>{
<a name="l02991"></a>02991             <span class="keywordflow">return</span> BOOST_AFIO_V1_NAMESPACE::directory_entry_hash()(p);
<a name="l02992"></a>02992         }
<a name="l02993"></a>02993     };
<a name="l02994"></a>02994 
<a name="l02995"></a>02995 }<span class="comment">//namesapce std</span>
<a name="l02996"></a>02996 <span class="preprocessor">#endif</span>
<a name="l02997"></a>02997 <span class="preprocessor"></span>
<a name="l02998"></a>02998 <span class="preprocessor">#ifdef BOOST_MSVC</span>
<a name="l02999"></a>02999 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(pop)</span>
<a name="l03000"></a>03000 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03001"></a>03001 <span class="preprocessor"></span>
<a name="l03002"></a>03002 <span class="preprocessor">#if BOOST_AFIO_HEADERS_ONLY == 1 &amp;&amp; !defined(DOXYGEN_SHOULD_SKIP_THIS)</span>
<a name="l03003"></a>03003 <span class="preprocessor"></span><span class="preprocessor">#undef BOOST_AFIO_VALIDATE_INPUTS // Let BOOST_AFIO_NEVER_VALIDATE_INPUTS take over</span>
<a name="l03004"></a>03004 <span class="preprocessor"></span><span class="preprocessor">#include &quot;detail/impl/afio.ipp&quot;</span>
<a name="l03005"></a>03005 <span class="preprocessor">#endif</span>
<a name="l03006"></a>03006 <span class="preprocessor"></span>
<a name="l03007"></a>03007 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
