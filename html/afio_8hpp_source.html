<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="afio_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* async_file_io</span>
<a name="l00002"></a>00002 <span class="comment">Provides a threadpool and asynchronous file i/o infrastructure based on Boost.ASIO, Boost.Iostreams and filesystem</span>
<a name="l00003"></a>00003 <span class="comment">(C) 2013-2014 Niall Douglas http://www.nedprod.com/</span>
<a name="l00004"></a>00004 <span class="comment">File Created: Mar 2013</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">Boost Software License - Version 1.0 - August 17th, 2003</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">Permission is hereby granted, free of charge, to any person or organization</span>
<a name="l00010"></a>00010 <span class="comment">obtaining a copy of the software and accompanying documentation covered by</span>
<a name="l00011"></a>00011 <span class="comment">this license (the &quot;Software&quot;) to use, reproduce, display, distribute,</span>
<a name="l00012"></a>00012 <span class="comment">execute, and transmit the Software, and to prepare derivative works of the</span>
<a name="l00013"></a>00013 <span class="comment">Software, and to permit third-parties to whom the Software is furnished to</span>
<a name="l00014"></a>00014 <span class="comment">do so, all subject to the following:</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">The copyright notices in the Software and this entire statement, including</span>
<a name="l00017"></a>00017 <span class="comment">the above license grant, this restriction and the following disclaimer,</span>
<a name="l00018"></a>00018 <span class="comment">must be included in all copies of the Software, in whole or in part, and</span>
<a name="l00019"></a>00019 <span class="comment">all derivative works of the Software, unless such copies or derivative</span>
<a name="l00020"></a>00020 <span class="comment">works are solely in the form of machine-executable object code generated by</span>
<a name="l00021"></a>00021 <span class="comment">a source language processor.</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00024"></a>00024 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00025"></a>00025 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT</span>
<a name="l00026"></a>00026 <span class="comment">SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE</span>
<a name="l00027"></a>00027 <span class="comment">FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,</span>
<a name="l00028"></a>00028 <span class="comment">ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<a name="l00029"></a>00029 <span class="comment">DEALINGS IN THE SOFTWARE.</span>
<a name="l00030"></a>00030 <span class="comment">*/</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;config.hpp&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="preprocessor">#ifdef BOOST_AFIO_NEED_DEFINE</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;detail/Undoer.hpp&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;detail/ErrorHandling.hpp&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;detail/Utility.hpp&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;type_traits&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;exception&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;algorithm&gt;</span> <span class="comment">// Boost.ASIO needs std::min and std::max</span>
<a name="l00043"></a>00043 
<a name="l00052"></a>00052 <span class="preprocessor">#ifndef BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#ifndef NDEBUG</span>
<a name="l00054"></a><a class="code" href="group__macros.html#ga8abeb465d2ca6fa15b3c3754697e5577">00054</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_VALIDATE_INPUTS 1</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_VALIDATE_INPUTS 0</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="preprocessor">#ifdef BOOST_MSVC</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(push)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(disable: 4251) // type needs to have dll-interface to be used by clients of class</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00080"></a>00080 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00081"></a><a class="code" href="afio_8hpp.html#a7d6cb43e029a76765081fb3a2f47187d">00081</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_HEADERS_ONLY 1</span>
<a name="l00082"></a><a class="code" href="afio_8hpp.html#a183b5c98a87ff28a56ea3bfdbe141ee9">00082</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_USE_BOOST_THREAD 0</span>
<a name="l00083"></a><a class="code" href="afio_8hpp.html#ab5974d84a78dbcf8b072fca370f1291d">00083</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_USE_BOOST_FILESYSTEM 1</span>
<a name="l00084"></a><a class="code" href="afio_8hpp.html#a5b90f4adb6bc09ca319c35c3448ee67a">00084</a> <span class="preprocessor"></span><span class="preprocessor">#define ASIO_STANDALONE 0</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 BOOST_AFIO_V1_NAMESPACE_BEGIN
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">// This isn&#39;t consistent on MSVC so hard code it</span>
<a name="l00090"></a>00090 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> off_t;
<a name="l00091"></a>00091 
<a name="l00093"></a>00093 <span class="keyword">namespace </span>detail
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">class </span>enqueued_task_impl
<a name="l00096"></a>00096     {
<a name="l00097"></a>00097     <span class="keyword">protected</span>:
<a name="l00098"></a>00098         <span class="keyword">struct </span>Private
<a name="l00099"></a>00099         {
<a name="l00100"></a>00100             std::function&lt;R()&gt; task;
<a name="l00101"></a>00101             promise&lt;R&gt; r;
<a name="l00102"></a>00102             shared_future&lt;R&gt; f;
<a name="l00103"></a>00103             <span class="keywordtype">bool</span> autoset;
<a name="l00104"></a>00104             atomic&lt;int&gt; done;
<a name="l00105"></a>00105             Private(std::function&lt;R()&gt; _task) : task(std::move(_task)), f(r.get_future().share()), autoset(<span class="keyword">true</span>), done(0) { }
<a name="l00106"></a>00106         };
<a name="l00107"></a>00107         std::shared_ptr&lt;Private&gt; p;
<a name="l00108"></a>00108         <span class="keywordtype">void</span> validate()<span class="keyword"> const </span>{ assert(p); <span class="comment">/*if(!p) abort();*/</span> }
<a name="l00109"></a>00109     <span class="keyword">public</span>:
<a name="l00111"></a>00111         enqueued_task_impl(std::function&lt;R()&gt; _task=std::function&lt;R()&gt;()) : p(std::make_shared&lt;Private&gt;(std::move(_task))) { }
<a name="l00113"></a>00113         <span class="keywordtype">bool</span> valid() <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW{ <span class="keywordflow">return</span> p.get()!=<span class="keyword">nullptr</span>; }
<a name="l00115"></a>00115         <span class="keywordtype">void</span> swap(enqueued_task_impl &amp;o) BOOST_NOEXCEPT_OR_NOTHROW{ p.swap(o.p); }
<a name="l00117"></a>00117         <span class="keywordtype">void</span> reset() { p.reset(); }
<a name="l00119"></a>00119         <span class="keywordtype">void</span> set_task(std::function&lt;R()&gt; _task) { p-&gt;task=std::move(_task); }
<a name="l00121"></a>00121         <span class="keyword">const</span> shared_future&lt;R&gt; &amp;get_future()<span class="keyword"> const </span>{ validate(); <span class="keywordflow">return</span> p-&gt;f; }
<a name="l00123"></a>00123         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> set_future_value(T v)
<a name="l00124"></a>00124         {
<a name="l00125"></a>00125             <span class="keywordtype">int</span> _=0;
<a name="l00126"></a>00126             validate();
<a name="l00127"></a>00127             <span class="keywordflow">if</span>(!p-&gt;done.compare_exchange_strong(_, 1))
<a name="l00128"></a>00128                 <span class="keywordflow">return</span>;
<a name="l00129"></a>00129             p-&gt;r.set_value(std::move(v));
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         <span class="keywordtype">void</span> set_future_value()
<a name="l00132"></a>00132         {
<a name="l00133"></a>00133             <span class="keywordtype">int</span> _=0;
<a name="l00134"></a>00134             validate();
<a name="l00135"></a>00135             <span class="keywordflow">if</span>(!p-&gt;done.compare_exchange_strong(_, 1))
<a name="l00136"></a>00136                 <span class="keywordflow">return</span>;
<a name="l00137"></a>00137             p-&gt;r.set_value();
<a name="l00138"></a>00138         }
<a name="l00140"></a>00140         <span class="keywordtype">void</span> set_future_exception(exception_ptr e)
<a name="l00141"></a>00141         {
<a name="l00142"></a>00142             <span class="keywordtype">int</span> _=0;
<a name="l00143"></a>00143             validate();
<a name="l00144"></a>00144             <span class="keywordflow">if</span>(!p-&gt;done.compare_exchange_strong(_, 1))
<a name="l00145"></a>00145                 <span class="keywordflow">return</span>;
<a name="l00146"></a>00146             p-&gt;r.set_exception(e);
<a name="l00147"></a>00147         }
<a name="l00149"></a>00149         <span class="keywordtype">void</span> disable_auto_set_future(<span class="keywordtype">bool</span> v=<span class="keyword">true</span>) { validate(); p-&gt;autoset=!v; }
<a name="l00150"></a>00150     };
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 
<a name="l00153"></a><a class="code" href="classenqueued__task.html">00153</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">class </span><a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task</a>;
<a name="l00164"></a>00164 <span class="comment">// Can&#39;t have args in callable type as that segfaults VS2010</span>
<a name="l00165"></a><a class="code" href="classenqueued__task_3_01_r_07_08_4.html">00165</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">class </span><a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task</a>&lt;R()&gt; : <span class="keyword">public</span> detail::enqueued_task_impl&lt;R&gt;
<a name="l00166"></a>00166 {
<a name="l00167"></a>00167     <span class="keyword">typedef</span> detail::enqueued_task_impl&lt;R&gt; Base;
<a name="l00168"></a>00168 <span class="keyword">public</span>:
<a name="l00170"></a><a class="code" href="classenqueued__task_3_01_r_07_08_4.html#a0fd457bc45b0c909efb1728b3aa4fe6f">00170</a>     <a class="code" href="classenqueued__task_3_01_r_07_08_4.html#a0fd457bc45b0c909efb1728b3aa4fe6f" title="Default constructor.">enqueued_task</a>(std::function&lt;R()&gt; _task=std::function&lt;R()&gt;()) : Base(std::move(_task)) { }
<a name="l00172"></a><a class="code" href="classenqueued__task_3_01_r_07_08_4.html#a7baccc036c5a35bdc3eed93294385e1e">00172</a>     <span class="keywordtype">void</span> operator()()
<a name="l00173"></a>00173     {
<a name="l00174"></a>00174         <span class="keyword">auto</span> _p(Base::p);
<a name="l00175"></a>00175         Base::validate();
<a name="l00176"></a>00176         <span class="keywordflow">if</span>(!_p-&gt;task) abort();
<a name="l00177"></a>00177         <span class="keywordflow">try</span>
<a name="l00178"></a>00178         {
<a name="l00179"></a>00179             <span class="keyword">auto</span> v(_p-&gt;task());
<a name="l00180"></a>00180             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done) Base::set_future_value(v);
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182         <span class="keywordflow">catch</span>(...)
<a name="l00183"></a>00183         {
<a name="l00184"></a>00184             <span class="keywordflow">if</span>(_p-&gt;done)
<a name="l00185"></a>00185             {
<a name="l00186"></a>00186               std::cerr &lt;&lt; detail::output_exception_info &lt;&lt; <span class="stringliteral">&quot; thrown up to enqueued_task&lt;&gt; after future set.&quot;</span> &lt;&lt; std::endl;
<a name="l00187"></a>00187               BOOST_AFIO_THROW_FATAL(std::runtime_error(<span class="stringliteral">&quot;Exception thrown up to enqueued_task&lt;&gt; after future set.&quot;</span>));
<a name="l00188"></a>00188             }
<a name="l00189"></a>00189             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done) 
<a name="l00190"></a>00190             {
<a name="l00191"></a>00191                 <span class="keyword">auto</span> e(current_exception());
<a name="l00192"></a>00192                 Base::set_future_exception(e);
<a name="l00193"></a>00193             }
<a name="l00194"></a>00194         }
<a name="l00195"></a>00195         <span class="comment">// Free any bound parameters in task to save memory</span>
<a name="l00196"></a>00196         _p-&gt;task=std::function&lt;R()&gt;();
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198 };
<a name="l00199"></a><a class="code" href="classenqueued__task_3_01void_07_08_4.html">00199</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span><a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task</a>&lt;void()&gt; : <span class="keyword">public</span> detail::enqueued_task_impl&lt;void&gt;
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201     <span class="keyword">typedef</span> detail::enqueued_task_impl&lt;void&gt; Base;
<a name="l00202"></a>00202 <span class="keyword">public</span>:
<a name="l00204"></a><a class="code" href="classenqueued__task_3_01void_07_08_4.html#afc7f622b214974cf02a3f592e6abd138">00204</a>     <a class="code" href="classenqueued__task_3_01void_07_08_4.html#afc7f622b214974cf02a3f592e6abd138" title="Default constructor.">enqueued_task</a>(std::function&lt;<span class="keywordtype">void</span>()&gt; _task=std::function&lt;<span class="keywordtype">void</span>()&gt;()) : Base(std::move(_task)) { }
<a name="l00206"></a><a class="code" href="classenqueued__task_3_01void_07_08_4.html#a9943506555ea046e28f4d631af337ea8">00206</a>     <span class="keywordtype">void</span> operator()()
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208         <span class="keyword">auto</span> _p(Base::p);
<a name="l00209"></a>00209         Base::validate();
<a name="l00210"></a>00210         <span class="keywordflow">if</span>(!_p-&gt;task) abort();
<a name="l00211"></a>00211         <span class="keywordflow">try</span>
<a name="l00212"></a>00212         {
<a name="l00213"></a>00213             _p-&gt;task();
<a name="l00214"></a>00214             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done) Base::set_future_value();
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216         <span class="keywordflow">catch</span>(...)
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218             <span class="keywordflow">if</span>(_p-&gt;done)
<a name="l00219"></a>00219             {
<a name="l00220"></a>00220               std::cerr &lt;&lt; detail::output_exception_info &lt;&lt; <span class="stringliteral">&quot; thrown up to enqueued_task&lt;&gt; after future set.&quot;</span> &lt;&lt; std::endl;
<a name="l00221"></a>00221               BOOST_AFIO_THROW_FATAL(std::runtime_error(<span class="stringliteral">&quot;Exception thrown up to enqueued_task&lt;&gt; after future set.&quot;</span>));
<a name="l00222"></a>00222             }
<a name="l00223"></a>00223             <span class="keywordflow">if</span>(_p-&gt;autoset &amp;&amp; !_p-&gt;done)
<a name="l00224"></a>00224             {
<a name="l00225"></a>00225                 <span class="keyword">auto</span> e(current_exception());
<a name="l00226"></a>00226                 Base::set_future_exception(e);
<a name="l00227"></a>00227             }
<a name="l00228"></a>00228         }
<a name="l00229"></a>00229         <span class="comment">// Free any bound parameters in task to save memory</span>
<a name="l00230"></a>00230         _p-&gt;task=std::function&lt;void()&gt;();
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232 };
<a name="l00240"></a><a class="code" href="classthread__source.html">00240</a> <span class="keyword">class </span><a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> : <span class="keyword">public</span> std::enable_shared_from_this&lt;thread_source&gt;
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242 <span class="keyword">protected</span>:
<a name="l00243"></a>00243     asio::io_service &amp;service;
<a name="l00244"></a>00244     <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a>(asio::io_service &amp;_service) : service(_service) { }
<a name="l00245"></a>00245     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~<a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a>() { }
<a name="l00246"></a>00246     <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> &amp;) = <span class="keyword">delete</span>;
<a name="l00247"></a>00247 <span class="keyword">public</span>:
<a name="l00249"></a><a class="code" href="classthread__source.html#a12ea3803826545dad75911f45f911fb0">00249</a>     asio::io_service &amp;<a class="code" href="classthread__source.html#a12ea3803826545dad75911f45f911fb0" title="Returns the underlying io_service.">io_service</a>() { <span class="keywordflow">return</span> service; }
<a name="l00251"></a><a class="code" href="classthread__source.html#a6a51649d8eef305a22225e1985b5c69a">00251</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keywordtype">void</span> <a class="code" href="classthread__source.html#a6a51649d8eef305a22225e1985b5c69a" title="Sends a task to the thread pool for execution.">enqueue</a>(<a class="code" href="classenqueued__task.html" title="The namespace containing Boost.ASIO internal details.">enqueued_task&lt;R&gt;</a> task)
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253         service.post(task);
<a name="l00254"></a>00254     }
<a name="l00256"></a><a class="code" href="classthread__source.html#aaaa9cabaf1ebc6be74301b207518b1e1">00256</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; shared_future&lt;typename std::result_of&lt;F()&gt;::type&gt; <a class="code" href="classthread__source.html#a6a51649d8eef305a22225e1985b5c69a" title="Sends a task to the thread pool for execution.">enqueue</a>(F f)
<a name="l00257"></a>00257     {
<a name="l00258"></a>00258         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;F()&gt;::type R;
<a name="l00259"></a>00259         <a class="code" href="classenqueued__task_3_01_r_07_08_4.html">enqueued_task&lt;R()&gt;</a> out(std::move(f));
<a name="l00260"></a>00260         <span class="keyword">auto</span> ret(out.get_future());
<a name="l00261"></a>00261         service.post(out);
<a name="l00262"></a>00262         <span class="keywordflow">return</span> std::move(ret);
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264 };
<a name="l00265"></a>00265 
<a name="l00271"></a><a class="code" href="classstd__thread__pool.html">00271</a> <span class="keyword">class </span><a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a> : <span class="keyword">public</span> <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a> {
<a name="l00272"></a>00272     <span class="keyword">class </span>worker
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274         <a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a> *pool;
<a name="l00275"></a>00275     <span class="keyword">public</span>:
<a name="l00276"></a>00276         <span class="keyword">explicit</span> worker(<a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a> *p) : pool(p) { }
<a name="l00277"></a>00277         <span class="keywordtype">void</span> operator()()
<a name="l00278"></a>00278         {
<a name="l00279"></a>00279             detail::set_threadname(<span class="stringliteral">&quot;boost::afio::std_thread_pool worker&quot;</span>);
<a name="l00280"></a>00280             <span class="keywordflow">try</span>
<a name="l00281"></a>00281             {
<a name="l00282"></a>00282                 pool-&gt;service.run();
<a name="l00283"></a>00283             }
<a name="l00284"></a>00284             <span class="keywordflow">catch</span>(...)
<a name="l00285"></a>00285             {
<a name="l00286"></a>00286                 std::cerr &lt;&lt; <span class="stringliteral">&quot;WARNING: ASIO exits via &quot;</span> &lt;&lt; detail::output_exception_info &lt;&lt; <span class="stringliteral">&quot; which shouldn&#39;t happen.&quot;</span> &lt;&lt; std::endl;
<a name="l00287"></a>00287             }
<a name="l00288"></a>00288         }
<a name="l00289"></a>00289     };
<a name="l00290"></a>00290     <span class="keyword">friend</span> <span class="keyword">class </span>worker;
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     asio::io_service service;
<a name="l00293"></a>00293     std::unique_ptr&lt;asio::io_service::work&gt; working;
<a name="l00294"></a>00294     std::vector&lt; std::unique_ptr&lt;thread&gt; &gt; workers;
<a name="l00295"></a>00295 <span class="keyword">public</span>:
<a name="l00299"></a><a class="code" href="classstd__thread__pool.html#ae6b19bc3e4bc336d2d64e85ac03b1608">00299</a>     <span class="keyword">explicit</span> <a class="code" href="classstd__thread__pool.html#ae6b19bc3e4bc336d2d64e85ac03b1608" title="Constructs a thread pool of no workers.">std_thread_pool</a>(<span class="keywordtype">size_t</span> no) : <a class="code" href="classthread__source.html" title="Abstract base class for a source of thread workers.">thread_source</a>(service), working(detail::make_unique&lt;asio::<a class="code" href="classthread__source.html#a12ea3803826545dad75911f45f911fb0" title="Returns the underlying io_service.">io_service</a>::work&gt;(service))
<a name="l00300"></a>00300     {
<a name="l00301"></a>00301         <a class="code" href="classstd__thread__pool.html#a41e63ac0720d88c4995457bbfc652bf4" title="Adds more workers to the thread pool.">add_workers</a>(no);
<a name="l00302"></a>00302     }
<a name="l00304"></a><a class="code" href="classstd__thread__pool.html#a41e63ac0720d88c4995457bbfc652bf4">00304</a>     <span class="keywordtype">void</span> <a class="code" href="classstd__thread__pool.html#a41e63ac0720d88c4995457bbfc652bf4" title="Adds more workers to the thread pool.">add_workers</a>(<span class="keywordtype">size_t</span> no)
<a name="l00305"></a>00305     {
<a name="l00306"></a>00306         workers.reserve(workers.size()+no);
<a name="l00307"></a>00307         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n=0; n&lt;no; n++)
<a name="l00308"></a>00308             workers.push_back(detail::make_unique&lt;thread&gt;(worker(<span class="keyword">this</span>)));
<a name="l00309"></a>00309     }
<a name="l00311"></a><a class="code" href="classstd__thread__pool.html#aa191fb9c0df971e2136bf977f220fb0b">00311</a>     <span class="keywordtype">void</span> <a class="code" href="classstd__thread__pool.html#aa191fb9c0df971e2136bf977f220fb0b" title="Destroys the thread pool, waiting for worker threads to exit beforehand.">destroy</a>()
<a name="l00312"></a>00312     {
<a name="l00313"></a>00313         <span class="keywordflow">if</span>(!service.stopped())
<a name="l00314"></a>00314         {
<a name="l00315"></a>00315             <span class="comment">// Tell the threads there is no more work to do</span>
<a name="l00316"></a>00316             working.reset();
<a name="l00317"></a>00317             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i: workers) { i-&gt;join(); }
<a name="l00318"></a>00318             workers.clear();
<a name="l00319"></a>00319             <span class="comment">// For some reason ASIO occasionally thinks there is still more work to do</span>
<a name="l00320"></a>00320             <span class="keywordflow">if</span>(!service.stopped())
<a name="l00321"></a>00321                 service.run();
<a name="l00322"></a>00322             service.stop();
<a name="l00323"></a>00323             service.reset();
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325     }
<a name="l00326"></a>00326     ~<a class="code" href="classstd__thread__pool.html" title="A very simple thread pool based on std::thread or boost::thread.">std_thread_pool</a>()
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328         <a class="code" href="classstd__thread__pool.html#aa191fb9c0df971e2136bf977f220fb0b" title="Destroys the thread pool, waiting for worker threads to exit beforehand.">destroy</a>();
<a name="l00329"></a>00329     }
<a name="l00330"></a>00330 };
<a name="l00336"></a>00336 BOOST_AFIO_HEADERS_ONLY_FUNC_SPEC std::shared_ptr&lt;std_thread_pool&gt; <a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>();
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keyword">class </span>async_file_io_dispatcher_base;
<a name="l00339"></a>00339 <span class="keyword">struct </span><a class="code" href="structasync__io__op.html" title="A reference to an asynchronous operation.">async_io_op</a>;
<a name="l00340"></a>00340 <span class="keyword">struct </span><a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a>;
<a name="l00341"></a>00341 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_data_op_req;
<a name="l00342"></a>00342 <span class="keyword">struct </span><a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>;
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="preprocessor">#define BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(type) \</span>
<a name="l00345"></a>00345 <span class="preprocessor">inline BOOST_CONSTEXPR type operator&amp;(type a, type b) \</span>
<a name="l00346"></a>00346 <span class="preprocessor">{ \</span>
<a name="l00347"></a>00347 <span class="preprocessor">    return static_cast&lt;type&gt;(static_cast&lt;size_t&gt;(a) &amp; static_cast&lt;size_t&gt;(b)); \</span>
<a name="l00348"></a>00348 <span class="preprocessor">} \</span>
<a name="l00349"></a>00349 <span class="preprocessor">inline BOOST_CONSTEXPR type operator|(type a, type b) \</span>
<a name="l00350"></a>00350 <span class="preprocessor">{ \</span>
<a name="l00351"></a>00351 <span class="preprocessor">    return static_cast&lt;type&gt;(static_cast&lt;size_t&gt;(a) | static_cast&lt;size_t&gt;(b)); \</span>
<a name="l00352"></a>00352 <span class="preprocessor">} \</span>
<a name="l00353"></a>00353 <span class="preprocessor">inline BOOST_CONSTEXPR type operator~(type a) \</span>
<a name="l00354"></a>00354 <span class="preprocessor">{ \</span>
<a name="l00355"></a>00355 <span class="preprocessor">    return static_cast&lt;type&gt;(~static_cast&lt;size_t&gt;(a)); \</span>
<a name="l00356"></a>00356 <span class="preprocessor">} \</span>
<a name="l00357"></a>00357 <span class="preprocessor">inline BOOST_CONSTEXPR bool operator!(type a) \</span>
<a name="l00358"></a>00358 <span class="preprocessor">{ \</span>
<a name="l00359"></a>00359 <span class="preprocessor">    return 0==static_cast&lt;size_t&gt;(a); \</span>
<a name="l00360"></a>00360 <span class="preprocessor">}</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>
<a name="l00362"></a>00362 
<a name="l00363"></a>00363 
<a name="l00368"></a>00368 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00369"></a><a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db">00369</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a>
<a name="l00370"></a>00370 <span class="preprocessor">#else</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> : size_t
<a name="l00372"></a>00372 <span class="preprocessor">#endif</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>{
<a name="l00374"></a><a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252">00374</a>     <a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>=0,             
<a name="l00375"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba809abe96853e69894bbf8e5730b31348">00375</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba809abe96853e69894bbf8e5730b31348" title="Read access.">Read</a>=1,             
<a name="l00376"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa56670174817e3fed92bfd8182d7c0d1">00376</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa56670174817e3fed92bfd8182d7c0d1" title="Write access.">Write</a>=2,            
<a name="l00377"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba3c4d2d19c91b345c33a83ca9f551f4e1">00377</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba3c4d2d19c91b345c33a83ca9f551f4e1" title="Read and write access.">ReadWrite</a>=3,        
<a name="l00378"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba71f30510b076569dd2830e348fb77a13">00378</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba71f30510b076569dd2830e348fb77a13" title="Append only.">Append</a>=4,           
<a name="l00379"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba4877d9d67c11656d88fc82cfeb94a4f3">00379</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba4877d9d67c11656d88fc82cfeb94a4f3" title="Truncate existing file to zero.">Truncate</a>=8,         
<a name="l00380"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba93479401ae71e13bd81626eb0b6c2d37">00380</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba93479401ae71e13bd81626eb0b6c2d37" title="Open and create if doesn&#39;t exist.">Create</a>=16,          
<a name="l00381"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbafd41a51c46068f24398d21e5e8d23d16">00381</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbafd41a51c46068f24398d21e5e8d23d16" title="Create and open only if doesn&#39;t exist.">CreateOnlyIfNotExist</a>=32, 
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa26ef493b962366c21fef788da134721">00383</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa26ef493b962366c21fef788da134721" title="Will be exclusively either read or written sequentially. If you&#39;re exclusively writing sequentially...">WillBeSequentiallyAccessed</a>=128, 
<a name="l00384"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba5ad1750347c8e7ce9513f1edb3dd3766">00384</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba5ad1750347c8e7ce9513f1edb3dd3766" title="Will be randomly accessed, so don&#39;t bother with read-ahead. If you&#39;re using this, strongly consider t...">WillBeRandomlyAccessed</a>=256, 
<a name="l00385"></a>00385 
<a name="l00386"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba6085ffcc368053b7563ee66109aba163">00386</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba6085ffcc368053b7563ee66109aba163" title="Hold a file handle open to the containing directory of each open file for fast directory enumeration...">FastDirectoryEnumeration</a>=(1&lt;&lt;10), 
<a name="l00387"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba837053fb9e27a38d2a153f5c85436644">00387</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba837053fb9e27a38d2a153f5c85436644" title="Return a unique directory handle rather than a shared directory handle.">UniqueDirectoryHandle</a>=(1&lt;&lt;11), 
<a name="l00388"></a>00388 
<a name="l00389"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b">00389</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b" title="Bypass the OS file buffers (only really useful for writing large files, or a lot of random reads and ...">OSDirect</a>=(1&lt;&lt;16),   
<a name="l00390"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa0ba263c207e29e2d1d6823d4dc7790b">00390</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa0ba263c207e29e2d1d6823d4dc7790b" title="Memory map files (for reads only).">OSMMap</a>=(1&lt;&lt;17),     
<a name="l00391"></a>00391 
<a name="l00392"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa3cc9b55b4157e3b0c799f941f21c001">00392</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaa3cc9b55b4157e3b0c799f941f21c001" title="Ask the OS to not complete until the data is on the physical storage. Best used only with OSDirect...">AlwaysSync</a>=(1&lt;&lt;24),     
<a name="l00393"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba58ef332941f8d3160a208d81a8d60f3f">00393</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba58ef332941f8d3160a208d81a8d60f3f" title="Automatically initiate an asynchronous flush just before file close, and fuse both operations so both...">SyncOnClose</a>=(1&lt;&lt;25),    
<a name="l00394"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba8f3aad3eb5f15e3dd74b03a781d3add2">00394</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba8f3aad3eb5f15e3dd74b03a781d3add2" title="Ensure that data writes to files reach physical storage in the same order as the op dependencies clos...">EnforceDependencyWriteOrder</a>=(1&lt;&lt;26), 
<a name="l00395"></a>00395 
<a name="l00396"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3">00396</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3" title="Internal use only. Don&#39;t use.">int_opening_link</a>=(1&lt;&lt;29), 
<a name="l00397"></a><a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d">00397</a>     <a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d" title="Internal use only. Don&#39;t use.">int_opening_dir</a>=(1&lt;&lt;30) 
<a name="l00398"></a>00398 };
<a name="l00399"></a>00399 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a>)
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 
<a name="l00405"></a>00405 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00406"></a><a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194">00406</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>
<a name="l00407"></a>00407 <span class="preprocessor">#else</span>
<a name="l00408"></a>00408 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> : size_t
<a name="l00409"></a>00409 <span class="preprocessor">#endif</span>
<a name="l00410"></a>00410 <span class="preprocessor"></span>{
<a name="l00411"></a><a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0">00411</a>     <a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0" title="No flags set.">none</a>=0,                 
<a name="l00412"></a><a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b">00412</a>     <a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b" title="Call chained completion immediately instead of scheduling for later. Make SURE your completion can no...">immediate</a>=1             
<a name="l00413"></a>00413 };
<a name="l00414"></a>00414 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>)
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 namespace detail {
<a name="l00417"></a>00417     <span class="keyword">struct </span>async_io_handle_posix;
<a name="l00418"></a>00418     <span class="keyword">struct </span>async_io_handle_windows;
<a name="l00419"></a>00419     <span class="keyword">struct </span>async_file_io_dispatcher_base_p;
<a name="l00420"></a>00420     <span class="keyword">class </span>async_file_io_dispatcher_compat;
<a name="l00421"></a>00421     <span class="keyword">class </span>async_file_io_dispatcher_windows;
<a name="l00422"></a>00422     <span class="keyword">class </span>async_file_io_dispatcher_linux;
<a name="l00423"></a>00423     <span class="keyword">class </span>async_file_io_dispatcher_qnx;
<a name="l00424"></a>00424     <span class="keyword">struct </span>immediate_async_ops;
<a name="l00425"></a>00425     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> for_writing&gt; <span class="keyword">class </span>async_data_op_req_impl;
<a name="l00426"></a>00426 
<a name="l00430"></a>00430 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00431"></a>00431 <span class="preprocessor"></span>    <span class="keyword">enum</span> OpType
<a name="l00432"></a>00432 <span class="preprocessor">#else</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>    <span class="keyword">enum class</span> OpType
<a name="l00434"></a>00434 #endif
<a name="l00435"></a>00435     {
<a name="l00436"></a>00436         Unknown,
<a name="l00437"></a>00437         UserCompletion,
<a name="l00438"></a>00438         dir,
<a name="l00439"></a>00439         rmdir,
<a name="l00440"></a>00440         file,
<a name="l00441"></a>00441         rmfile,
<a name="l00442"></a>00442         symlink,
<a name="l00443"></a>00443         rmsymlink,
<a name="l00444"></a>00444         sync,
<a name="l00445"></a>00445         close,
<a name="l00446"></a>00446         read,
<a name="l00447"></a>00447         write,
<a name="l00448"></a>00448         truncate,
<a name="l00449"></a>00449         barrier,
<a name="l00450"></a>00450         enumerate,
<a name="l00451"></a>00451         adopt,
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         Last
<a name="l00454"></a>00454     };
<a name="l00455"></a>00455     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *optypes[]={
<a name="l00456"></a>00456         <span class="stringliteral">&quot;unknown&quot;</span>,
<a name="l00457"></a>00457         <span class="stringliteral">&quot;UserCompletion&quot;</span>,
<a name="l00458"></a>00458         <span class="stringliteral">&quot;dir&quot;</span>,
<a name="l00459"></a>00459         <span class="stringliteral">&quot;rmdir&quot;</span>,
<a name="l00460"></a>00460         <span class="stringliteral">&quot;file&quot;</span>,
<a name="l00461"></a>00461         <span class="stringliteral">&quot;rmfile&quot;</span>,
<a name="l00462"></a>00462         <span class="stringliteral">&quot;symlink&quot;</span>,
<a name="l00463"></a>00463         <span class="stringliteral">&quot;rmsymlink&quot;</span>,
<a name="l00464"></a>00464         <span class="stringliteral">&quot;sync&quot;</span>,
<a name="l00465"></a>00465         <span class="stringliteral">&quot;close&quot;</span>,
<a name="l00466"></a>00466         <span class="stringliteral">&quot;read&quot;</span>,
<a name="l00467"></a>00467         <span class="stringliteral">&quot;write&quot;</span>,
<a name="l00468"></a>00468         <span class="stringliteral">&quot;truncate&quot;</span>,
<a name="l00469"></a>00469         <span class="stringliteral">&quot;barrier&quot;</span>,
<a name="l00470"></a>00470         <span class="stringliteral">&quot;enumerate&quot;</span>,
<a name="l00471"></a>00471         <span class="stringliteral">&quot;adopt&quot;</span>
<a name="l00472"></a>00472     };
<a name="l00473"></a>00473     static_assert(static_cast&lt;size_t&gt;(OpType::Last)==<span class="keyword">sizeof</span>(optypes)/<span class="keyword">sizeof</span>(*optypes), <span class="stringliteral">&quot;You forgot to fix up the strings matching OpType&quot;</span>);
<a name="l00474"></a>00474 }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="keyword">class </span><a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>;
<a name="l00477"></a>00477 
<a name="l00482"></a>00482 <span class="preprocessor">#ifdef DOXYGEN_NO_CLASS_ENUMS</span>
<a name="l00483"></a><a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">00483</a> <span class="preprocessor"></span><span class="keyword">enum</span> <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>
<a name="l00484"></a>00484 <span class="preprocessor">#else</span>
<a name="l00485"></a>00485 <span class="preprocessor"></span><span class="keyword">enum class</span> <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> : size_t
<a name="l00486"></a>00486 <span class="preprocessor">#endif</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>{
<a name="l00488"></a>00488     <a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>=0,
<a name="l00489"></a>00489     dev=1&lt;&lt;0,
<a name="l00490"></a>00490     ino=1&lt;&lt;1,
<a name="l00491"></a>00491     type=1&lt;&lt;2,
<a name="l00492"></a>00492     perms=1&lt;&lt;3,
<a name="l00493"></a>00493     nlink=1&lt;&lt;4,
<a name="l00494"></a>00494     uid=1&lt;&lt;5,
<a name="l00495"></a>00495     gid=1&lt;&lt;6,
<a name="l00496"></a>00496     rdev=1&lt;&lt;7,
<a name="l00497"></a>00497     atim=1&lt;&lt;8,
<a name="l00498"></a>00498     mtim=1&lt;&lt;9,
<a name="l00499"></a>00499     ctim=1&lt;&lt;10,
<a name="l00500"></a>00500     size=1&lt;&lt;11,
<a name="l00501"></a>00501     allocated=1&lt;&lt;12,
<a name="l00502"></a>00502     blocks=1&lt;&lt;13,
<a name="l00503"></a>00503     blksize=1&lt;&lt;14,
<a name="l00504"></a>00504     flags=1&lt;&lt;15,
<a name="l00505"></a>00505     gen=1&lt;&lt;16,
<a name="l00506"></a>00506     birthtim=1&lt;&lt;17,
<a name="l00507"></a><a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11fea54991d225c58ce0af43461d4e9a82312">00507</a>     <a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11fea54991d225c58ce0af43461d4e9a82312" title="Return the maximum possible metadata.">All</a>=(size_t)-1       
<a name="l00508"></a>00508 };
<a name="l00509"></a>00509 BOOST_AFIO_DECLARE_CLASS_ENUM_AS_BITFIELD(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>)
<a name="l00525"></a><a class="code" href="structstat__t.html">00525</a> struct <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a>
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00528"></a><a class="code" href="structstat__t.html#a7487cc455af320b602f8d334a15a1c3a">00528</a> <span class="preprocessor"></span>    uint64_t        <a class="code" href="structstat__t.html#a7487cc455af320b602f8d334a15a1c3a">st_dev</a>;                       
<a name="l00529"></a>00529 <span class="preprocessor">#endif</span>
<a name="l00530"></a><a class="code" href="structstat__t.html#af53eaec5ef5bf1b290f2dbb94af599c8">00530</a> <span class="preprocessor"></span>    uint64_t        <a class="code" href="structstat__t.html#af53eaec5ef5bf1b290f2dbb94af599c8">st_ino</a>;                       
<a name="l00531"></a><a class="code" href="structstat__t.html#a55e15f3a42407c84aacc348017ca8ab6">00531</a>     filesystem::file_type <a class="code" href="structstat__t.html#a55e15f3a42407c84aacc348017ca8ab6">st_type</a>;           
<a name="l00532"></a>00532 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00533"></a>00533 <span class="preprocessor"></span><span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00534"></a>00534 <span class="preprocessor"></span>    uint16_t        st_perms;
<a name="l00535"></a>00535 <span class="preprocessor">#else</span>
<a name="l00536"></a><a class="code" href="structstat__t.html#abf305545fb9145073630d52c8a6003bc">00536</a> <span class="preprocessor"></span>    filesystem::perms <a class="code" href="structstat__t.html#abf305545fb9145073630d52c8a6003bc">st_perms</a>;              
<a name="l00537"></a>00537 <span class="preprocessor">#endif</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00539"></a><a class="code" href="structstat__t.html#a19fed1af49a87be2ad39e3e1ddf4cde2">00539</a> <span class="preprocessor"></span>    int16_t         <a class="code" href="structstat__t.html#a19fed1af49a87be2ad39e3e1ddf4cde2">st_nlink</a>;                     
<a name="l00540"></a>00540 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00541"></a><a class="code" href="structstat__t.html#a0dafe518808f57a98f45361d42c9fe1f">00541</a> <span class="preprocessor"></span>    int16_t         <a class="code" href="structstat__t.html#a0dafe518808f57a98f45361d42c9fe1f">st_uid</a>;                       
<a name="l00542"></a><a class="code" href="structstat__t.html#ac928ac17d09faca0745d78e2eaceb13d">00542</a>     int16_t         <a class="code" href="structstat__t.html#ac928ac17d09faca0745d78e2eaceb13d">st_gid</a>;                       
<a name="l00543"></a><a class="code" href="structstat__t.html#a900c604b7b01f3b7a3dc3753c23ca41c">00543</a>     dev_t           <a class="code" href="structstat__t.html#a900c604b7b01f3b7a3dc3753c23ca41c">st_rdev</a>;                      
<a name="l00544"></a>00544 <span class="preprocessor">#endif</span>
<a name="l00545"></a><a class="code" href="structstat__t.html#aa78500f915a48ddf7a30eef9b5129d02">00545</a> <span class="preprocessor"></span>    chrono::system_clock::time_point <a class="code" href="structstat__t.html#aa78500f915a48ddf7a30eef9b5129d02">st_atim</a>;     
<a name="l00546"></a><a class="code" href="structstat__t.html#afe057e9458ea89ec8934f89c81300c8d">00546</a>     chrono::system_clock::time_point <a class="code" href="structstat__t.html#afe057e9458ea89ec8934f89c81300c8d">st_mtim</a>;     
<a name="l00547"></a><a class="code" href="structstat__t.html#a680581c4f03e2caccdbdfe21b8fc0929">00547</a>     chrono::system_clock::time_point <a class="code" href="structstat__t.html#a680581c4f03e2caccdbdfe21b8fc0929">st_ctim</a>;     
<a name="l00548"></a><a class="code" href="structstat__t.html#a7ebcf73d7edf079832744627f070665d">00548</a>     off_t           <a class="code" href="structstat__t.html#a7ebcf73d7edf079832744627f070665d">st_size</a>;                      
<a name="l00549"></a><a class="code" href="structstat__t.html#a0348936b7cadfe816e0105bcc256dd29">00549</a>     off_t           <a class="code" href="structstat__t.html#a0348936b7cadfe816e0105bcc256dd29">st_allocated</a>;                 
<a name="l00550"></a><a class="code" href="structstat__t.html#a1239310ac61bbdc1eda835321876a718">00550</a>     off_t           <a class="code" href="structstat__t.html#a1239310ac61bbdc1eda835321876a718">st_blocks</a>;                    
<a name="l00551"></a><a class="code" href="structstat__t.html#aa530698a20aa20fedfe0c205d0bcc674">00551</a>     uint16_t        <a class="code" href="structstat__t.html#aa530698a20aa20fedfe0c205d0bcc674">st_blksize</a>;                   
<a name="l00552"></a><a class="code" href="structstat__t.html#a796bc31527577465b0dd3c9fbc771961">00552</a>     uint32_t        <a class="code" href="structstat__t.html#a796bc31527577465b0dd3c9fbc771961">st_flags</a>;                     
<a name="l00553"></a><a class="code" href="structstat__t.html#a2524d9bce9db23cd67fb16df52e4abc0">00553</a>     uint32_t        <a class="code" href="structstat__t.html#a2524d9bce9db23cd67fb16df52e4abc0">st_gen</a>;                       
<a name="l00554"></a><a class="code" href="structstat__t.html#a1ebba916806061ad29be6b39f0268f9b">00554</a>     chrono::system_clock::time_point <a class="code" href="structstat__t.html#a1ebba916806061ad29be6b39f0268f9b">st_birthtim</a>; 
<a name="l00556"></a>00556 
<a name="l00557"></a><a class="code" href="structstat__t.html#a2765906190447535fa13532c8844a15e">00557</a>     <a class="code" href="structstat__t.html#a2765906190447535fa13532c8844a15e" title="Constructs a UNINITIALIZED instance i.e. full of random garbage.">stat_t</a>() { }
<a name="l00559"></a><a class="code" href="structstat__t.html#a8775018b5d9221d1da0e6e2c72e45da3">00559</a>     stat_t(std::nullptr_t) :
<a name="l00560"></a>00560 #ifndef WIN32
<a name="l00561"></a>00561         st_dev(0),
<a name="l00562"></a>00562 #endif
<a name="l00563"></a>00563         st_ino(0),
<a name="l00564"></a>00564 #ifdef BOOST_AFIO_USE_LEGACY_FILESYSTEM_SEMANTICS
<a name="l00565"></a>00565         st_type(filesystem::file_type::type_unknown),
<a name="l00566"></a>00566 #else
<a name="l00567"></a>00567         st_type(filesystem::file_type::unknown),
<a name="l00568"></a>00568 #endif
<a name="l00569"></a>00569 #ifndef WIN32
<a name="l00570"></a>00570         st_perms(0),
<a name="l00571"></a>00571 #endif
<a name="l00572"></a>00572         st_nlink(0),
<a name="l00573"></a>00573 #ifndef WIN32
<a name="l00574"></a>00574         st_uid(0), st_gid(0), st_rdev(0),
<a name="l00575"></a>00575 #endif
<a name="l00576"></a>00576         st_size(0), st_allocated(0), st_blocks(0), st_blksize(0), st_flags(0), st_gen(0) { }
<a name="l00577"></a>00577 };
<a name="l00578"></a>00578 
<a name="l00584"></a><a class="code" href="classdirectory__entry.html">00584</a> <span class="keyword">class </span>BOOST_AFIO_DECL <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_compat;
<a name="l00587"></a>00587     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_windows;
<a name="l00588"></a>00588     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_linux;
<a name="l00589"></a>00589     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_qnx;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     filesystem::path leafname;
<a name="l00592"></a>00592     <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> stat;
<a name="l00593"></a>00593     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> have_metadata;
<a name="l00594"></a>00594     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> _int_fetch(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted, std::shared_ptr&lt;async_io_handle&gt; dirh);
<a name="l00595"></a>00595 <span class="keyword">public</span>:
<a name="l00597"></a><a class="code" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958">00597</a>     <a class="code" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958" title="Default constructor.">directory_entry</a>() : stat(nullptr), have_metadata(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>::<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>) { }
<a name="l00599"></a><a class="code" href="classdirectory__entry.html#a9f9450830547a63eb719ca01b37c4325">00599</a>     <a class="code" href="classdirectory__entry.html#a9f9450830547a63eb719ca01b37c4325" title="Default constructor.">directory_entry</a>(filesystem::path _leafname, <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> __stat, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _have_metadata) : leafname(_leafname), stat(__stat), have_metadata(_have_metadata) { }
<a name="l00600"></a>00600     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;) = <span class="keywordflow">default</span>;
<a name="l00601"></a>00601     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;) = <span class="keywordflow">default</span>;
<a name="l00602"></a>00602     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>(<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;&amp;o) : leafname(std::move(o.leafname)), stat(std::move(o.stat)), have_metadata(std::move(o.have_metadata)) { }
<a name="l00603"></a>00603     <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;operator=(<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;&amp;o)
<a name="l00604"></a>00604     {
<a name="l00605"></a>00605         leafname=std::move(o.leafname);
<a name="l00606"></a>00606         stat=std::move(o.stat);
<a name="l00607"></a>00607         have_metadata=std::move(o.have_metadata);
<a name="l00608"></a>00608         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611     <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname == rhs.leafname; }
<a name="l00612"></a>00612     <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname != rhs.leafname; }
<a name="l00613"></a>00613     <span class="keywordtype">bool</span> operator&lt; (<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &lt; rhs.leafname; }
<a name="l00614"></a>00614     <span class="keywordtype">bool</span> operator&lt;=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &lt;= rhs.leafname; }
<a name="l00615"></a>00615     <span class="keywordtype">bool</span> operator&gt; (<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &gt; rhs.leafname; }
<a name="l00616"></a>00616     <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&amp; rhs) <span class="keyword">const</span> BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname &gt;= rhs.leafname; }
<a name="l00618"></a><a class="code" href="classdirectory__entry.html#a99c7aa29c44148401588fb680ab44334">00618</a>     filesystem::path <a class="code" href="classdirectory__entry.html#a99c7aa29c44148401588fb680ab44334">name</a>() const BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> leafname; }
<a name="l00620"></a><a class="code" href="classdirectory__entry.html#a67bdc31854318138ba9c34d8469f6b1c">00620</a>     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> <a class="code" href="classdirectory__entry.html#a67bdc31854318138ba9c34d8469f6b1c">metadata_ready</a>() const BOOST_NOEXCEPT_OR_NOTHROW { <span class="keywordflow">return</span> have_metadata; }
<a name="l00626"></a><a class="code" href="classdirectory__entry.html#a3ad8cabe9b14690a2f0eb7776d556458">00626</a>     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> fetch_metadata(std::shared_ptr&lt;async_io_handle&gt; dirh, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted)
<a name="l00627"></a>00627     {
<a name="l00628"></a>00628         <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> tofetch;
<a name="l00629"></a>00629         wanted=wanted&amp;metadata_supported();
<a name="l00630"></a>00630         tofetch=wanted&amp;~have_metadata;
<a name="l00631"></a>00631         <span class="keywordflow">if</span>(!!tofetch) _int_fetch(tofetch, dirh);
<a name="l00632"></a>00632         <span class="keywordflow">return</span> have_metadata;
<a name="l00633"></a>00633     }
<a name="l00639"></a><a class="code" href="classdirectory__entry.html#a82c821341533ccd6e7a6841f0df62362">00639</a>     <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> fetch_lstat(std::shared_ptr&lt;async_io_handle&gt; dirh, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted=<a class="code" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3" title="A bitfield of what metadata is fast on this platform. This doesn&#39;t mean all is available for every fi...">directory_entry::metadata_fastpath</a>())
<a name="l00640"></a>00640     {
<a name="l00641"></a>00641         fetch_metadata(dirh, wanted);
<a name="l00642"></a>00642         <span class="keywordflow">return</span> stat;
<a name="l00643"></a>00643     }
<a name="l00644"></a>00644 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00645"></a>00645 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(field) \</span>
<a name="l00646"></a>00646 <span class="preprocessor">decltype(stat_t().st_##field) st_##field() const { if(!(have_metadata&amp;metadata_flags::field)) { BOOST_AFIO_THROW(std::runtime_error(&quot;Field st_&quot; #field &quot; not present.&quot;)); } return stat.st_##field; } \</span>
<a name="l00647"></a>00647 <span class="preprocessor">decltype(stat_t().st_##field) st_##field(std::shared_ptr&lt;async_io_handle&gt; dirh) { if(!(have_metadata&amp;metadata_flags::field)) { _int_fetch(metadata_flags::field, dirh); } return stat.st_##field; }</span>
<a name="l00648"></a>00648 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00649"></a>00649 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(field) \</span>
<a name="l00650"></a>00650 <span class="preprocessor">fieldtype st_##field(std::shared_ptr&lt;async_io_handle&gt; dirh=std::shared_ptr&lt;async_io_handle&gt;()) { if(!(have_metadata&amp;metadata_flags::field)) { _int_fetch(metadata_flags::field, dirh); } return stat.st_##field; }</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span><span class="preprocessor">#ifndef WIN32</span>
<a name="l00653"></a>00653 <span class="preprocessor"></span>
<a name="l00654"></a><a class="code" href="classdirectory__entry.html#ab9fe9a795efa2479cde43919af0d4289">00654</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(dev)
<a name="l00655"></a>00655 <span class="preprocessor">#endif</span>
<a name="l00656"></a>00656 <span class="preprocessor"></span>
<a name="l00657"></a><a class="code" href="classdirectory__entry.html#aa668bf3b3f0e2825244214ab6fdb7b70">00657</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(ino)
<a name="l00659"></a><a class="code" href="classdirectory__entry.html#a04f94fc6f5b03fba8afd4b82866211a3">00659</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(type)
<a name="l00660"></a>00660 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00661"></a>00661 <span class="preprocessor"></span>
<a name="l00662"></a><a class="code" href="classdirectory__entry.html#a4e302e731c846a58c2f767a83c68f14e">00662</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(perms)
<a name="l00663"></a>00663 <span class="preprocessor">#endif</span>
<a name="l00664"></a>00664 <span class="preprocessor"></span>
<a name="l00665"></a><a class="code" href="classdirectory__entry.html#a014d472a4bff85d7a182756e3c0f9824">00665</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(nlink)
<a name="l00666"></a>00666 <span class="preprocessor">#ifndef WIN32</span>
<a name="l00667"></a>00667 <span class="preprocessor"></span>
<a name="l00668"></a><a class="code" href="classdirectory__entry.html#aef4bb48fb46e6c78dc1ad2aeda4681a9">00668</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(uid)
<a name="l00670"></a><a class="code" href="classdirectory__entry.html#a30cf008e632ad3c0590d5d5433b11d52">00670</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(gid)
<a name="l00672"></a><a class="code" href="classdirectory__entry.html#a1eb27dc286a7614ab5b06c08b4dba60e">00672</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(rdev)
<a name="l00673"></a>00673 <span class="preprocessor">#endif</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>
<a name="l00675"></a><a class="code" href="classdirectory__entry.html#abdd2752820b4f89ca615a6ab93ce3a06">00675</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(atim)
<a name="l00677"></a><a class="code" href="classdirectory__entry.html#a15c133f6acd511e518fcf213711b24e8">00677</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(mtim)
<a name="l00679"></a><a class="code" href="classdirectory__entry.html#a92de110c65ccc52b2f009c1d17e2c428">00679</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(ctim)
<a name="l00681"></a><a class="code" href="classdirectory__entry.html#ac7928966ebc20bc4e2b73321c8d3cf2b">00681</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(size)
<a name="l00683"></a><a class="code" href="classdirectory__entry.html#aaa7dfff87e368bb138676c2f8e194314">00683</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(allocated)
<a name="l00685"></a><a class="code" href="classdirectory__entry.html#a931b760be9308d5a20161713f63e2529">00685</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(blocks)
<a name="l00687"></a><a class="code" href="classdirectory__entry.html#a43ff38c6d1d1da845db602411ec3b3fb">00687</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(blksize)
<a name="l00689"></a><a class="code" href="classdirectory__entry.html#a5a1961a9215593f7f11ace287afa4001">00689</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(flags)
<a name="l00691"></a><a class="code" href="classdirectory__entry.html#a5bea44318235f6e0937d9e68dcc66aea">00691</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(gen)
<a name="l00693"></a><a class="code" href="classdirectory__entry.html#a98a8615a9123218b9aeaa195b7179486">00693</a>     BOOST_AFIO_DIRECTORY_ENTRY_ACCESS_METHOD(birthtim)
<a name="l00694"></a>00694 
<a name="l00696"></a>00696     static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> metadata_supported() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l00698"></a>00698     static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> metadata_fastpath() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l00700"></a>00700     static BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> compatibility_maximum() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l00701"></a>00701 };
<a name="l00702"></a>00702 
<a name="l00705"></a><a class="code" href="structdirectory__entry__hash.html">00705</a> struct <a class="code" href="structdirectory__entry__hash.html" title="A hasher for directory_entry, hashing inode and birth time (if available on this platform).">directory_entry_hash</a>
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707 <span class="keyword">public</span>:
<a name="l00708"></a>00708     <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> &amp;p)<span class="keyword"> const</span>
<a name="l00709"></a>00709 <span class="keyword">    </span>{
<a name="l00710"></a>00710         <span class="keywordtype">size_t</span> seed = (size_t) 0x9ddfea08eb382d69ULL;
<a name="l00711"></a>00711         detail::hash_combine(seed, p.<a class="code" href="classdirectory__entry.html#aa668bf3b3f0e2825244214ab6fdb7b70" title="Returns st_ino.">st_ino</a>());
<a name="l00712"></a>00712         <span class="keywordflow">if</span>(!!(<a class="code" href="classdirectory__entry.html#ac111d690ae103454c2c48c873b37ba77" title="A bitfield of what metadata is available on this platform. This doesn&#39;t mean all is available for eve...">directory_entry::metadata_supported</a>() &amp; metadata_flags::birthtim))
<a name="l00713"></a>00713             detail::hash_combine(seed, p.<a class="code" href="classdirectory__entry.html#a98a8615a9123218b9aeaa195b7179486" title="Returns st_birthtim.">st_birthtim</a>().time_since_epoch().count());
<a name="l00714"></a>00714         <span class="keywordflow">return</span> seed;
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716 };
<a name="l00717"></a>00717 
<a name="l00720"></a><a class="code" href="classasync__io__handle.html">00720</a> <span class="keyword">class </span><a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> : <span class="keyword">public</span> std::enable_shared_from_this&lt;async_io_handle&gt;
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722     <span class="keyword">friend</span> <span class="keyword">class </span>async_file_io_dispatcher_base;
<a name="l00723"></a>00723     <span class="keyword">friend</span> <span class="keyword">struct </span>async_io_handle_posix;
<a name="l00724"></a>00724     <span class="keyword">friend</span> <span class="keyword">struct </span>async_io_handle_windows;
<a name="l00725"></a>00725     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_compat;
<a name="l00726"></a>00726     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_windows;
<a name="l00727"></a>00727     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_linux;
<a name="l00728"></a>00728     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_qnx;
<a name="l00729"></a>00729 
<a name="l00730"></a>00730     async_file_io_dispatcher_base *_parent;
<a name="l00731"></a>00731     std::shared_ptr&lt;async_io_handle&gt; dirh;
<a name="l00732"></a>00732     chrono::system_clock::time_point _opened;
<a name="l00733"></a>00733     filesystem::path _path; <span class="comment">// guaranteed canonical</span>
<a name="l00734"></a>00734     <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags;
<a name="l00735"></a>00735 <span class="keyword">protected</span>:
<a name="l00736"></a>00736     atomic&lt;off_t&gt; bytesread, byteswritten, byteswrittenatlastfsync;
<a name="l00737"></a>00737     <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>(async_file_io_dispatcher_base *parent, std::shared_ptr&lt;async_io_handle&gt; _dirh, <span class="keyword">const</span> filesystem::path &amp;path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flags) : _parent(parent), dirh(std::move(_dirh)), _opened(chrono::system_clock::now()), _path(path), _flags(flags), bytesread(0), byteswritten(0), byteswrittenatlastfsync(0) { }
<a name="l00738"></a>00738     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <span class="keywordtype">void</span> close() BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00739"></a>00739 <span class="keyword">public</span>:
<a name="l00740"></a>00740     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>() { }
<a name="l00742"></a><a class="code" href="classasync__io__handle.html#aac13ab5def49a2405995ff6d11032076">00742</a>     async_file_io_dispatcher_base *<a class="code" href="classasync__io__handle.html#aac13ab5def49a2405995ff6d11032076" title="Returns the parent of this io handle.">parent</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _parent; }
<a name="l00744"></a><a class="code" href="classasync__io__handle.html#ae8574073fc1b0a67bcd46ddf9e9ae873">00744</a>     std::shared_ptr&lt;async_io_handle&gt; <a class="code" href="classasync__io__handle.html#ae8574073fc1b0a67bcd46ddf9e9ae873" title="Returns a handle to the directory containing this handle. Only works if `file_flagsFastDirectoryEnume...">container</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dirh; }
<a name="l00746"></a>00746     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <span class="keywordtype">void</span> *native_handle() const BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00748"></a><a class="code" href="classasync__io__handle.html#a89dd90d83b0c5902c561e4463abd97d5">00748</a>     const chrono::system_clock::time_point &amp;opened()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _opened; }
<a name="l00750"></a><a class="code" href="classasync__io__handle.html#ac797c31edac57f4a972d8bb3c0305cab">00750</a>     <span class="keyword">const</span> filesystem::path &amp;<a class="code" href="classasync__io__handle.html#ac797c31edac57f4a972d8bb3c0305cab" title="Returns the path of this io handle.">path</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _path; }
<a name="l00752"></a><a class="code" href="classasync__io__handle.html#aea1a9240f90cfa6ac551df5dcc546898">00752</a>     <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> <a class="code" href="classasync__io__handle.html#aea1a9240f90cfa6ac551df5dcc546898" title="Returns the final flags used when this handle was opened.">flags</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _flags; }
<a name="l00754"></a><a class="code" href="classasync__io__handle.html#a0f7d6ffefd528ee85aa217bc8d80baca">00754</a>     <span class="keywordtype">bool</span> <a class="code" href="classasync__io__handle.html#a0f7d6ffefd528ee85aa217bc8d80baca" title="True if this handle was opened as a file.">opened_as_file</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d" title="Internal use only. Don&#39;t use.">file_flags::int_opening_dir</a>) &amp;&amp; !(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3" title="Internal use only. Don&#39;t use.">file_flags::int_opening_link</a>); }
<a name="l00756"></a><a class="code" href="classasync__io__handle.html#a0a5d04f3f3ff7eefabed1d6af4fe8c52">00756</a>     <span class="keywordtype">bool</span> <a class="code" href="classasync__io__handle.html#a0a5d04f3f3ff7eefabed1d6af4fe8c52" title="True if this handle was opened as a directory.">opened_as_dir</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !!(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbaf8864b27bad71e73e66ab81cabd6f80d" title="Internal use only. Don&#39;t use.">file_flags::int_opening_dir</a>); }
<a name="l00758"></a><a class="code" href="classasync__io__handle.html#a259cca5d1e6a40b77bf33e433bcae863">00758</a>     <span class="keywordtype">bool</span> <a class="code" href="classasync__io__handle.html#a259cca5d1e6a40b77bf33e433bcae863" title="True if this handle was opened as a symlink.">opened_as_symlink</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !!(_flags&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dbacf70efc695fc6209e99b9161f6feead3" title="Internal use only. Don&#39;t use.">file_flags::int_opening_link</a>); }
<a name="l00760"></a><a class="code" href="classasync__io__handle.html#ac632d5739145e2139b4af93220c324f4">00760</a>     off_t <a class="code" href="classasync__io__handle.html#ac632d5739145e2139b4af93220c324f4" title="Returns how many bytes have been read since this handle was opened.">read_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bytesread; }
<a name="l00762"></a><a class="code" href="classasync__io__handle.html#a0320961d4e319ecd5a297b2e21da2cfb">00762</a>     off_t <a class="code" href="classasync__io__handle.html#a0320961d4e319ecd5a297b2e21da2cfb" title="Returns how many bytes have been written since this handle was opened.">write_count</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> byteswritten; }
<a name="l00764"></a><a class="code" href="classasync__io__handle.html#a096a1f09f761f5f04634b02586b4251e">00764</a>     off_t <a class="code" href="classasync__io__handle.html#a096a1f09f761f5f04634b02586b4251e" title="Returns how many bytes have been written since this handle was last fsynced.">write_count_since_fsync</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> byteswritten-byteswrittenatlastfsync; }
<a name="l00766"></a>00766     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> direntry(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted=<a class="code" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3" title="A bitfield of what metadata is fast on this platform. This doesn&#39;t mean all is available for every fi...">directory_entry::metadata_fastpath</a>()) const BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00768"></a><a class="code" href="classasync__io__handle.html#a87d756f9f38ee299dc404398576237f4">00768</a>     <a class="code" href="structstat__t.html" title="Metadata about a directory entry.">stat_t</a> lstat(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> wanted=<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>::metadata_fastpath())<span class="keyword"> const</span>
<a name="l00769"></a>00769 <span class="keyword">    </span>{
<a name="l00770"></a>00770         <a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> de(direntry(wanted));
<a name="l00771"></a>00771         <span class="keywordflow">return</span> de.<a class="code" href="classdirectory__entry.html#a82c821341533ccd6e7a6841f0df62362" title="Returns a copy of the internal `stat_t` structure. This is a blocking call if wanted metadata is not ...">fetch_lstat</a>(std::shared_ptr&lt;async_io_handle&gt;() <span class="comment">/* actually unneeded */</span>, wanted);
<a name="l00772"></a>00772     }
<a name="l00774"></a>00774     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC filesystem::path target() const BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00776"></a>00776     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC <span class="keywordtype">void</span> *try_mapfile() BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l00777"></a>00777 };
<a name="l00778"></a>00778 
<a name="l00784"></a><a class="code" href="structasync__io__op.html">00784</a> struct <a class="code" href="structasync__io__op.html" title="A reference to an asynchronous operation.">async_io_op</a>
<a name="l00785"></a>00785 {
<a name="l00786"></a><a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19">00786</a>     async_file_io_dispatcher_base *<a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19" title="The parent dispatcher.">parent</a>;              
<a name="l00787"></a><a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df">00787</a>     <span class="keywordtype">size_t</span> <a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df" title="A unique id for this operation.">id</a>;                                          
<a name="l00788"></a>00788     shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; h;  
<a name="l00789"></a>00789 
<a name="l00791"></a>00791     async_io_op() : parent(nullptr), id(0), h(shared_future&lt;std::shared_ptr&lt;<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>&gt;&gt;()) { }
<a name="l00793"></a>00793 <span class="preprocessor">#if 0 // used to find where std::move() isn&#39;t being used, and should be</span>
<a name="l00794"></a>00794 <span class="preprocessor"></span>    <span class="comment">//async_io_op(const async_io_op &amp;o);</span>
<a name="l00795"></a>00795 <span class="preprocessor">#else</span>
<a name="l00796"></a>00796 <span class="preprocessor"></span>    async_io_op(<span class="keyword">const</span> async_io_op &amp;o) : parent(o.parent), id(o.id), h(o.h) { }
<a name="l00797"></a>00797 <span class="preprocessor">#endif</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span>
<a name="l00799"></a>00799     async_io_op(async_io_op &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : parent(std::move(o.parent)), <span class="keywordtype">id</span>(std::move(o.<span class="keywordtype">id</span>)), h(std::move(o.h)) { }
<a name="l00807"></a>00807     async_io_op(async_file_io_dispatcher_base *_parent, <span class="keywordtype">size_t</span> _id, shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; _handle, <span class="keywordtype">bool</span> check_handle=<span class="keyword">true</span>, <span class="keywordtype">bool</span> validate=<span class="keyword">true</span>) : parent(_parent), id(_id), h(std::move(_handle)) { <span class="keywordflow">if</span>(validate) _validate(check_handle); }
<a name="l00812"></a>00812     async_io_op(async_file_io_dispatcher_base *_parent, <span class="keywordtype">size_t</span> _id) : parent(_parent), id(_id), h(shared_future&lt;std::shared_ptr&lt;<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>&gt;&gt;()) { }
<a name="l00814"></a>00814     async_io_op &amp;operator=(<span class="keyword">const</span> async_io_op &amp;o) { parent=o.<a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19" title="The parent dispatcher.">parent</a>; <span class="keywordtype">id</span>=o.<a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df" title="A unique id for this operation.">id</a>; h=o.h; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00816"></a>00816     async_io_op &amp;operator=(async_io_op &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW{ parent=std::move(o.parent); <span class="keywordtype">id</span>=std::move(o.id); h=std::move(o.h); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00818"></a>00818     std::shared_ptr&lt;async_io_handle&gt; <span class="keyword">get</span>(<span class="keywordtype">bool</span> return_null_if_errored=<span class="keyword">false</span>)
<a name="l00819"></a>00819     {
<a name="l00820"></a>00820         <span class="keywordflow">if</span>(!parent &amp;&amp; !<span class="keywordtype">id</span>)
<a name="l00821"></a>00821             <span class="keywordflow">return</span> std::shared_ptr&lt;async_io_handle&gt;();
<a name="l00822"></a>00822         <span class="keywordflow">if</span>(!return_null_if_errored)
<a name="l00823"></a>00823             <span class="keywordflow">return</span> h.get();
<a name="l00824"></a>00824         <span class="keyword">auto</span> e=get_exception_ptr(h);
<a name="l00825"></a>00825         <span class="keywordflow">return</span> e ? std::shared_ptr&lt;async_io_handle&gt;() : h.get();
<a name="l00826"></a>00826     }
<a name="l00828"></a>00828     <span class="keywordtype">bool</span> validate(<span class="keywordtype">bool</span> check_handle=<span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00829"></a>00829 <span class="keyword">    </span>{
<a name="l00830"></a>00830         <span class="keywordflow">if</span>(!parent || !<span class="keywordtype">id</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00831"></a>00831         <span class="comment">// If h is valid and ready and contains an exception, throw it now</span>
<a name="l00832"></a>00832         <span class="keywordflow">if</span>(h.valid() &amp;&amp; is_ready(h))
<a name="l00833"></a>00833         {
<a name="l00834"></a>00834             <span class="keywordflow">if</span>(check_handle)
<a name="l00835"></a>00835                 <span class="keywordflow">if</span>(!<span class="keyword">const_cast&lt;</span>shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;<span class="keyword">&gt;</span> &amp;&gt;(h).get().get())
<a name="l00836"></a>00836                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00837"></a>00837         }
<a name="l00838"></a>00838         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840 <span class="keyword">private</span>:
<a name="l00841"></a>00841     <span class="keywordtype">void</span> _validate(<span class="keywordtype">bool</span> check_handle=<span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00842"></a>00842 <span class="keyword">    </span>{
<a name="l00843"></a>00843 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!validate(check_handle))
<a name="l00845"></a>00845             BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l00846"></a>00846 <span class="preprocessor">#endif</span>
<a name="l00847"></a>00847 <span class="preprocessor"></span>    }
<a name="l00848"></a>00848 };
<a name="l00849"></a>00849 
<a name="l00850"></a>00850 <span class="comment">// This is a result_of filter to work around the weird mix of brittle decltype(), SFINAE incapable</span>
<a name="l00851"></a>00851 <span class="comment">// std::result_of and variadic template overload resolution rules in VS2013. Works on other compilers</span>
<a name="l00852"></a>00852 <span class="comment">// too of course, it simply prefilters out the call() overloads not matching the variadic overload.</span>
<a name="l00853"></a>00853 <span class="keyword">namespace </span>detail
<a name="l00854"></a>00854 {
<a name="l00855"></a>00855 <span class="preprocessor">#if 0</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround;
<a name="l00857"></a>00857     <span class="comment">// Match callable</span>
<a name="l00858"></a>00858     <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class</span>... OArgs, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;R (*)(OArgs...), Args...&gt;
<a name="l00859"></a>00859     {
<a name="l00860"></a>00860         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;R(*)(Args...)&gt;::type type;
<a name="l00861"></a>00861     };
<a name="l00862"></a>00862     <span class="comment">// Match callable</span>
<a name="l00863"></a>00863     <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class </span>T, <span class="keyword">class</span>... OArgs, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;R (T::*)(OArgs...) const, Args...&gt;
<a name="l00864"></a>00864     {
<a name="l00865"></a>00865         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;R (T::*)(Args...) <span class="keyword">const</span>&gt;::type type;
<a name="l00866"></a>00866     };
<a name="l00867"></a>00867     <span class="comment">// Match callable</span>
<a name="l00868"></a>00868     <span class="keyword">template</span>&lt;<span class="keyword">class </span>R, <span class="keyword">class </span>T, <span class="keyword">class</span>... OArgs, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;R (T::*const)(OArgs...) const, Args...&gt;
<a name="l00869"></a>00869     {
<a name="l00870"></a>00870         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;R (T::*<span class="keyword">const</span>)(Args...) <span class="keyword">const</span>&gt;::type type;
<a name="l00871"></a>00871     };
<a name="l00872"></a>00872 <span class="preprocessor">#else</span>
<a name="l00873"></a>00873 <span class="preprocessor"></span>    <span class="comment">/*</span>
<a name="l00874"></a>00874 <span class="comment">    call(const std::vector&lt;async_io_op&gt; &amp;ops             , const std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables              );</span>
<a name="l00875"></a>00875 <span class="comment">    call(const std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables                                                                );</span>
<a name="l00876"></a>00876 <span class="comment">    call(const async_io_op &amp;req                          , std::function&lt;R()&gt; callback                                   );</span>
<a name="l00877"></a>00877 <span class="comment">    call(const async_io_op &amp;req                          , C callback                                      , Args... args);</span>
<a name="l00878"></a>00878 <span class="comment">    */</span>
<a name="l00879"></a>00879     <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround
<a name="l00880"></a>00880     {
<a name="l00881"></a>00881         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type type;
<a name="l00882"></a>00882     };
<a name="l00883"></a>00883     <span class="comment">// Disable C being a const std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables</span>
<a name="l00884"></a>00884     <span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class</span>... Args&gt; <span class="keyword">struct </span>vs2013_variadic_overload_resolution_workaround&lt;std::vector&lt;T&gt;, Args...&gt;;
<a name="l00885"></a>00885 <span class="preprocessor">#endif</span>
<a name="l00886"></a>00886 <span class="preprocessor"></span>}
<a name="l00887"></a>00887 
<a name="l00905"></a>00905 class BOOST_AFIO_DECL async_file_io_dispatcher_base : <span class="keyword">public</span> std::enable_shared_from_this&lt;async_file_io_dispatcher_base&gt;
<a name="l00906"></a>00906 {
<a name="l00907"></a>00907     <span class="comment">//friend BOOST_AFIO_DECL std::shared_ptr&lt;async_file_io_dispatcher_base&gt; async_file_io_dispatcher(thread_source &amp;threadpool=process_threadpool(), file_flags flagsforce=file_flags::None, file_flags flagsmask=file_flags::None);</span>
<a name="l00908"></a>00908     <span class="keyword">friend</span> <span class="keyword">struct </span>detail::async_io_handle_posix;
<a name="l00909"></a>00909     <span class="keyword">friend</span> <span class="keyword">struct </span>detail::async_io_handle_windows;
<a name="l00910"></a>00910     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_compat;
<a name="l00911"></a>00911     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_windows;
<a name="l00912"></a>00912     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_linux;
<a name="l00913"></a>00913     <span class="keyword">friend</span> <span class="keyword">class </span>detail::async_file_io_dispatcher_qnx;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915     detail::async_file_io_dispatcher_base_p *p;
<a name="l00916"></a>00916     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> int_add_io_handle(<span class="keywordtype">void</span> *key, std::shared_ptr&lt;async_io_handle&gt; h);
<a name="l00917"></a>00917     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> int_del_io_handle(<span class="keywordtype">void</span> *key);
<a name="l00918"></a>00918     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_io_op int_op_from_scheduled_id(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;
<a name="l00919"></a>00919 <span class="keyword">protected</span>:
<a name="l00920"></a>00920     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_file_io_dispatcher_base(std::shared_ptr&lt;thread_source&gt; threadpool, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsforce, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsmask);
<a name="l00921"></a>00921     std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; doadopt(<span class="keywordtype">size_t</span>, async_io_op, std::shared_ptr&lt;async_io_handle&gt; h)
<a name="l00922"></a>00922     {
<a name="l00923"></a>00923         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, h);
<a name="l00924"></a>00924     }
<a name="l00925"></a>00925 <span class="keyword">public</span>:
<a name="l00927"></a>00927     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC ~async_file_io_dispatcher_base();
<a name="l00928"></a>00928 
<a name="l00930"></a>00930     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::shared_ptr&lt;thread_source&gt; threadsource() <span class="keyword">const</span>;
<a name="l00932"></a>00932     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> fileflags(<a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flags) <span class="keyword">const</span>;
<a name="l00934"></a>00934     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> wait_queue_depth() <span class="keyword">const</span>;
<a name="l00936"></a>00936     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> fd_count() <span class="keyword">const</span>;
<a name="l00943"></a>00943     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_io_op op_from_scheduled_id(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) <span class="keyword">const</span>;
<a name="l00944"></a>00944 
<a name="l00946"></a>00946     <span class="keyword">typedef</span> <span class="keywordtype">void</span> filter_t(detail::OpType, async_io_op &amp;);
<a name="l00948"></a>00948     <span class="keyword">typedef</span> <span class="keywordtype">void</span> filter_readwrite_t(detail::OpType, <a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a> *, <span class="keyword">const</span> detail::async_data_op_req_impl&lt;true&gt; &amp;, off_t, <span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>, <span class="keyword">const</span> asio::error_code &amp;, <span class="keywordtype">size_t</span>);
<a name="l00955"></a>00955     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> post_op_filter_clear();
<a name="l00970"></a>00970     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> post_op_filter(std::vector&lt;std::pair&lt;detail::OpType, std::function&lt;async_file_io_dispatcher_base::filter_t&gt;&gt;&gt; filters);
<a name="l00988"></a>00988     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> post_readwrite_filter(std::vector&lt;std::pair&lt;detail::OpType, std::function&lt;async_file_io_dispatcher_base::filter_readwrite_t&gt;&gt;&gt; filters);
<a name="l00989"></a>00989 
<a name="l00991"></a>00991     <span class="keyword">typedef</span> std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; completion_returntype;
<a name="l00993"></a>00993     <span class="keyword">typedef</span> completion_returntype completion_t(<span class="keywordtype">size_t</span>, async_io_op);
<a name="l00994"></a>00994 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l00995"></a>00995 <span class="preprocessor"></span><span class="preprocessor">#if defined(BOOST_AFIO_ENABLE_BENCHMARKING_COMPLETION) || BOOST_AFIO_HEADERS_ONLY==0 // Only really used for benchmarking</span>
<a name="l00996"></a>00996 <span class="preprocessor"></span>    BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; completion(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt;&gt; &amp;callbacks);
<a name="l00997"></a>00997     <span class="keyword">inline</span> async_io_op completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt; &amp;callback);
<a name="l00998"></a>00998 <span class="preprocessor">#endif</span>
<a name="l00999"></a>00999 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01000"></a>01000 <span class="preprocessor"></span>
<a name="l01011"></a>01011     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; completion(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::pair&lt;<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt;&gt; &amp;callbacks);
<a name="l01023"></a>01023     <span class="keyword">inline</span> async_io_op completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt; &amp;callback);
<a name="l01024"></a>01024 
<a name="l01040"></a>01040     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; call(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables);
<a name="l01056"></a>01056     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; call(<span class="keyword">const</span> std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables) { <span class="keywordflow">return</span> call(std::vector&lt;async_io_op&gt;(), callables); }
<a name="l01073"></a>01073     <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;R&gt;, async_io_op&gt; call(<span class="keyword">const</span> async_io_op &amp;req, std::function&lt;R()&gt; callback);
<a name="l01074"></a>01074 
<a name="l01075"></a>01075     
<a name="l01076"></a>01076     
<a name="l01077"></a>01077          
<a name="l01098"></a>01098 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> detail::vs2013_variadic_overload_resolution_workaround&lt;C, Args...&gt;::type&gt;, async_io_op&gt; call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args);
<a name="l01100"></a>01100 <span class="preprocessor">#else</span>
<a name="l01101"></a>01101 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type&gt;, async_io_op&gt; call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args);
<a name="l01102"></a>01102 <span class="preprocessor">#endif</span>
<a name="l01103"></a>01103 <span class="preprocessor"></span>
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 
<a name="l01120"></a>01120     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; adopt(<span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; &amp;hs);
<a name="l01135"></a>01135     <span class="keyword">inline</span> async_io_op adopt(std::shared_ptr&lt;async_io_handle&gt; h);
<a name="l01149"></a>01149     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; dir(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01163"></a>01163     <span class="keyword">inline</span> async_io_op dir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01174"></a>01174     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; rmdir(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01185"></a>01185     <span class="keyword">inline</span> async_io_op rmdir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01196"></a>01196     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; file(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01207"></a>01207     <span class="keyword">inline</span> async_io_op file(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01218"></a>01218     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; rmfile(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01229"></a>01229     <span class="keyword">inline</span> async_io_op rmfile(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01246"></a>01246     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; symlink(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01263"></a>01263     <span class="keyword">inline</span> async_io_op symlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01274"></a>01274     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; rmsymlink(<span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01285"></a>01285     <span class="keyword">inline</span> async_io_op rmsymlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req);
<a name="l01296"></a>01296     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; sync(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01307"></a>01307     <span class="keyword">inline</span> async_io_op sync(<span class="keyword">const</span> async_io_op &amp;req);
<a name="l01318"></a>01318     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; close(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01329"></a>01329     <span class="keyword">inline</span> async_io_op close(<span class="keyword">const</span> async_io_op &amp;req);
<a name="l01330"></a>01330 
<a name="l01344"></a>01344 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01345"></a>01345 <span class="preprocessor"></span>    BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; read(<span class="keyword">const</span> std::vector&lt;detail::async_data_op_req_impl&lt;false&gt;&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01346"></a>01346     template&lt;class T&gt; inline std::vector&lt;async_io_op&gt; read(const std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops);
<a name="l01347"></a>01347 <span class="preprocessor">#else</span>
<a name="l01348"></a>01348 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; read(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01349"></a>01349 <span class="preprocessor">#endif</span>
<a name="l01350"></a>01350 <span class="preprocessor"></span>
<a name="l01363"></a>01363 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01364"></a>01364 <span class="preprocessor"></span>    <span class="keyword">inline</span> async_io_op read(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;false&gt; &amp;req);
<a name="l01365"></a>01365 <span class="preprocessor">#else</span>
<a name="l01366"></a>01366 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_io_op read(<span class="keyword">const</span> async_data_op_req&lt;T&gt; &amp;req);
<a name="l01367"></a>01367 <span class="preprocessor">#endif</span>
<a name="l01368"></a>01368 <span class="preprocessor"></span>
<a name="l01381"></a>01381 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01382"></a>01382 <span class="preprocessor"></span>    BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; write(<span class="keyword">const</span> std::vector&lt;detail::async_data_op_req_impl&lt;true&gt;&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01383"></a>01383     template&lt;class T&gt; inline std::vector&lt;async_io_op&gt; write(const std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops);
<a name="l01384"></a>01384 <span class="preprocessor">#else</span>
<a name="l01385"></a>01385 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; write(<span class="keyword">const</span> std::vector&lt;<a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html" title="A convenience bundle of precondition, data and where for writing from a single `const T *`...">async_data_op_req&lt;const T&gt;</a>&gt; &amp;ops) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01386"></a>01386 <span class="preprocessor">#endif</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span>
<a name="l01400"></a>01400 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l01401"></a>01401 <span class="preprocessor"></span>    <span class="keyword">inline</span> async_io_op write(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;true&gt; &amp;req);
<a name="l01402"></a>01402 <span class="preprocessor">#else</span>
<a name="l01403"></a>01403 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_io_op write(<span class="keyword">const</span> <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html" title="A convenience bundle of precondition, data and where for writing from a single `const T *`...">async_data_op_req&lt;const T&gt;</a> &amp;req);
<a name="l01404"></a>01404 <span class="preprocessor">#endif</span>
<a name="l01405"></a>01405 <span class="preprocessor"></span>
<a name="l01417"></a>01417     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::vector&lt;async_io_op&gt; truncate(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;off_t&gt; &amp;sizes) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01429"></a>01429     <span class="keyword">inline</span> async_io_op truncate(<span class="keyword">const</span> async_io_op &amp;op, off_t newsize);
<a name="l01450"></a>01450     BOOST_AFIO_HEADERS_ONLY_VIRTUAL_SPEC std::pair&lt;std::vector&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; enumerate(<span class="keyword">const</span> std::vector&lt;async_enumerate_op_req&gt; &amp;reqs) BOOST_AFIO_HEADERS_ONLY_VIRTUAL_UNDEFINED_SPEC
<a name="l01471"></a>01471     <span class="keyword">inline</span> std::pair&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;, async_io_op&gt; enumerate(<span class="keyword">const</span> <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a> &amp;req);
<a name="l01472"></a>01472 
<a name="l01492"></a>01492     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; barrier(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops);
<a name="l01493"></a>01493 
<a name="l01501"></a>01501     <span class="keyword">static</span> BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">size_t</span> page_size() BOOST_NOEXCEPT_OR_NOTHROW;
<a name="l01502"></a>01502 
<a name="l01510"></a>01510     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC <span class="keywordtype">void</span> complete_async_op(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, std::shared_ptr&lt;<a class="code" href="classasync__io__handle.html" title="The abstract base class encapsulating a platform-specific file handle.">async_io_handle</a>&gt; h, exception_ptr e=exception_ptr());
<a name="l01518"></a>01518     <span class="keywordtype">void</span> complete_async_op(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, exception_ptr e) { complete_async_op(<span class="keywordtype">id</span>, std::shared_ptr&lt;async_io_handle&gt;(), e); }
<a name="l01519"></a>01519 <span class="keyword">protected</span>:
<a name="l01520"></a>01520     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC completion_returntype invoke_user_completion_fast(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, completion_t *callback);
<a name="l01521"></a>01521     BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC completion_returntype invoke_user_completion_slow(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, std::function&lt;completion_t&gt; callback);
<a name="l01522"></a>01522     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;preconditions, <span class="keyword">const</span> std::vector&lt;T&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, T));
<a name="l01523"></a>01523     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;T&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, T));
<a name="l01524"></a>01524     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, async_io_op));
<a name="l01525"></a>01525     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_path_op_req&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a>));
<a name="l01526"></a>01526     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keywordtype">bool</span> iswrite&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::vector&lt;async_io_op&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;detail::async_data_op_req_impl&lt;iswrite&gt;&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, detail::async_data_op_req_impl&lt;iswrite&gt;));
<a name="l01527"></a>01527     <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::pair&lt;std::vector&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; chain_async_ops(<span class="keywordtype">int</span> optype, <span class="keyword">const</span> std::vector&lt;async_enumerate_op_req&gt; &amp;container, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>, std::shared_ptr&lt;promise&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;&gt;));
<a name="l01528"></a>01528     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_file_io_dispatcher_base::completion_returntype dobarrier(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, T);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530     
<a name="l01531"></a>01531     <span class="keyword">template</span>&lt;<span class="keyword">class </span>F, <span class="keyword">class</span>... Args&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC std::shared_ptr&lt;async_io_handle&gt; invoke_async_op_completions(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, Args...), Args... args);
<a name="l01532"></a>01532     <span class="keyword">template</span>&lt;<span class="keyword">class </span>F, <span class="keyword">class</span>... Args&gt; BOOST_AFIO_HEADERS_ONLY_MEMFUNC_SPEC async_io_op chain_async_op(detail::immediate_async_ops &amp;immediates, <span class="keywordtype">int</span> optype, <span class="keyword">const</span> async_io_op &amp;precondition, <a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a> flags, completion_returntype(F::*f)(<span class="keywordtype">size_t</span>, async_io_op, Args...), Args... args);
<a name="l01533"></a>01533 };
<a name="l01550"></a>01550 BOOST_AFIO_HEADERS_ONLY_FUNC_SPEC std::shared_ptr&lt;async_file_io_dispatcher_base&gt; <a class="code" href="group__async__file__io__dispatcher.html#ga60af4394d09808d966a31a80fe9142eb" title="Instatiates the best available async_file_io_dispatcher implementation for this system.">make_async_file_io_dispatcher</a>(std::shared_ptr&lt;thread_source&gt; threadpool=<a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>(), <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsforce=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> flagsmask=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>);
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 <span class="keyword">namespace </span>detail
<a name="l01553"></a>01553 {
<a name="l01554"></a>01554     <span class="keyword">struct </span>when_all_state : std::enable_shared_from_this&lt;when_all_state&gt;
<a name="l01555"></a>01555     {
<a name="l01556"></a>01556         promise&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; out;
<a name="l01557"></a>01557         std::vector&lt;shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; in;
<a name="l01558"></a>01558     };
<a name="l01559"></a>01559     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> when_all_ops_do(std::shared_ptr&lt;when_all_state&gt; state)
<a name="l01560"></a>01560     {
<a name="l01561"></a>01561         <span class="comment">// If we&#39;re on Boost.Thread, coalesce all wait ops into a single</span>
<a name="l01562"></a>01562 <span class="preprocessor">#if BOOST_AFIO_USE_BOOST_THREAD</span>
<a name="l01563"></a>01563 <span class="preprocessor"></span>        boost::wait_for_all(state-&gt;in.begin(), state-&gt;in.end());
<a name="l01564"></a>01564 <span class="preprocessor">#endif</span>
<a name="l01565"></a>01565 <span class="preprocessor"></span>        std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; ret;
<a name="l01566"></a>01566         ret.reserve(state-&gt;in.size());
<a name="l01567"></a>01567         <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i: state-&gt;in)
<a name="l01568"></a>01568         {
<a name="l01569"></a>01569             <span class="keyword">auto</span> e(get_exception_ptr(i));
<a name="l01570"></a>01570             <span class="keywordflow">if</span>(e)
<a name="l01571"></a>01571             {
<a name="l01572"></a>01572                 <span class="keywordflow">if</span>(rethrow)
<a name="l01573"></a>01573                 {
<a name="l01574"></a>01574                     state-&gt;out.set_exception(e);
<a name="l01575"></a>01575                     <span class="keywordflow">return</span>;
<a name="l01576"></a>01576                 }
<a name="l01577"></a>01577                 ret.push_back(std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01578"></a>01578             }
<a name="l01579"></a>01579             <span class="keywordflow">else</span>
<a name="l01580"></a>01580                 ret.push_back(i.get());
<a name="l01581"></a>01581         }
<a name="l01582"></a>01582         state-&gt;out.set_value(ret);
<a name="l01583"></a>01583     }
<a name="l01584"></a>01584     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow, <span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all_ops(Iterator first, Iterator last)
<a name="l01585"></a>01585     {
<a name="l01586"></a>01586         <span class="keyword">auto</span> state=std::make_shared&lt;when_all_state&gt;();
<a name="l01587"></a>01587         state-&gt;in.reserve(std::distance(first, last));
<a name="l01588"></a>01588         <span class="keywordflow">for</span>(; first!=last; ++first)
<a name="l01589"></a>01589             state-&gt;in.push_back(first-&gt;h);
<a name="l01590"></a>01590         <span class="keyword">auto</span> ret=state-&gt;out.get_future();
<a name="l01591"></a>01591         <a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>()-&gt;enqueue([BOOST_AFIO_LAMBDA_MOVE_CAPTURE(state)] { when_all_ops_do&lt;rethrow&gt;(std::move(state)); });
<a name="l01592"></a>01592         <span class="keywordflow">return</span> std::move(ret);
<a name="l01593"></a>01593     }
<a name="l01594"></a>01594     <span class="keyword">struct </span>when_any_state : std::enable_shared_from_this&lt;when_any_state&gt;
<a name="l01595"></a>01595     {
<a name="l01596"></a>01596         atomic&lt;size_t&gt; count;
<a name="l01597"></a>01597         promise&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; out;
<a name="l01598"></a>01598         std::vector&lt;shared_future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; in;
<a name="l01599"></a>01599         when_any_state() : count(0) { }
<a name="l01600"></a>01600     };
<a name="l01601"></a>01601 <span class="preprocessor">#if BOOST_AFIO_USE_BOOST_THREAD</span>
<a name="l01602"></a>01602 <span class="preprocessor"></span>    <span class="comment">// Boost.Thread has wait_for_any() which lets us be more efficient here and wait directly on the futures</span>
<a name="l01603"></a>01603     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> when_any_ops_do(std::shared_ptr&lt;when_any_state&gt; state)
<a name="l01604"></a>01604     {
<a name="l01605"></a>01605         <span class="keyword">auto</span> &amp;i=*boost::wait_for_any(state-&gt;in.begin(), state-&gt;in.end());
<a name="l01606"></a>01606         <span class="keyword">auto</span> e(get_exception_ptr(i));
<a name="l01607"></a>01607         <span class="keywordflow">if</span>(e)
<a name="l01608"></a>01608         {
<a name="l01609"></a>01609             <span class="keywordflow">if</span>(rethrow)
<a name="l01610"></a>01610             {
<a name="l01611"></a>01611                 state-&gt;out.set_exception(e);
<a name="l01612"></a>01612                 <span class="keywordflow">return</span>;
<a name="l01613"></a>01613             }
<a name="l01614"></a>01614             state-&gt;out.set_value(std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01615"></a>01615         }
<a name="l01616"></a>01616         <span class="keywordflow">else</span>
<a name="l01617"></a>01617             state-&gt;out.set_value(i.get());
<a name="l01618"></a>01618     }
<a name="l01619"></a>01619     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow, <span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; when_any_ops(Iterator first, Iterator last)
<a name="l01620"></a>01620     {
<a name="l01621"></a>01621         <span class="keyword">auto</span> state=std::make_shared&lt;when_any_state&gt;();
<a name="l01622"></a>01622         state-&gt;in.reserve(std::distance(first, last));
<a name="l01623"></a>01623         <span class="keywordflow">for</span>(; first!=last; ++first)
<a name="l01624"></a>01624             state-&gt;in.push_back(first-&gt;h);
<a name="l01625"></a>01625         <span class="keyword">auto</span> ret=state-&gt;out.get_future();
<a name="l01626"></a>01626         <a class="code" href="group__process__threadpool.html#ga3cd49e64119265af60e5162b76fd95ca" title="Returns the process threadpool.">process_threadpool</a>()-&gt;enqueue([BOOST_AFIO_LAMBDA_MOVE_CAPTURE(state)]{ when_any_ops_do&lt;rethrow&gt;(std::move(state)); });
<a name="l01627"></a>01627         <span class="keywordflow">return</span> std::move(ret);
<a name="l01628"></a>01628     }
<a name="l01629"></a>01629 <span class="preprocessor">#else</span>
<a name="l01630"></a>01630 <span class="preprocessor"></span>    <span class="comment">// Without wait_for_any, schedule a completion onto every op and the first to fire wins</span>
<a name="l01631"></a>01631     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow&gt; <span class="keyword">inline</span> std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; when_any_ops_do(std::shared_ptr&lt;when_any_state&gt; state, <span class="keywordtype">size_t</span> idx, <span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, async_io_op h)
<a name="l01632"></a>01632     {
<a name="l01633"></a>01633         <span class="keyword">auto</span> &amp;i=state-&gt;in[idx];
<a name="l01634"></a>01634         <span class="keywordflow">if</span>(0==state-&gt;count.fetch_add(1, memory_order_relaxed))  <span class="comment">// Will be zero exactly once</span>
<a name="l01635"></a>01635         {
<a name="l01636"></a>01636             <span class="keyword">auto</span> e(get_exception_ptr(i));
<a name="l01637"></a>01637             <span class="keywordflow">if</span>(e)
<a name="l01638"></a>01638             {
<a name="l01639"></a>01639                 <span class="keywordflow">if</span>(rethrow)
<a name="l01640"></a>01640                 {
<a name="l01641"></a>01641                     state-&gt;out.set_exception(e);
<a name="l01642"></a>01642                     <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01643"></a>01643                 }
<a name="l01644"></a>01644                 state-&gt;out.set_value(std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01645"></a>01645             }
<a name="l01646"></a>01646             <span class="keywordflow">else</span>
<a name="l01647"></a>01647                 state-&gt;out.set_value(i.get());
<a name="l01648"></a>01648         }
<a name="l01649"></a>01649         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, std::shared_ptr&lt;async_io_handle&gt;());
<a name="l01650"></a>01650     }
<a name="l01651"></a>01651     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> rethrow, <span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; when_any_ops(Iterator first, Iterator last)
<a name="l01652"></a>01652     {
<a name="l01653"></a>01653         <span class="keyword">auto</span> state=std::make_shared&lt;when_any_state&gt;();
<a name="l01654"></a>01654         <span class="keyword">auto</span> dispatcher=first-&gt;parent;
<a name="l01655"></a>01655         std::vector&lt;async_io_op&gt; ops(first, last);
<a name="l01656"></a>01656         state-&gt;in.reserve(ops.size());
<a name="l01657"></a>01657         <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;op : ops)
<a name="l01658"></a>01658             state-&gt;in.push_back(op.h);
<a name="l01659"></a>01659         <span class="keyword">auto</span> ret=state-&gt;out.get_future();
<a name="l01660"></a>01660         <span class="keyword">typedef</span> std::function&lt;typename async_file_io_dispatcher_base::completion_t&gt; ft;
<a name="l01661"></a>01661         std::vector&lt;std::pair&lt;async_op_flags, ft&gt;&gt; completions;
<a name="l01662"></a>01662         completions.reserve(ops.size());
<a name="l01663"></a>01663         <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> n=0; n&lt;ops.size(); n++)
<a name="l01664"></a>01664           completions.push_back(std::make_pair(<a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194a97994fd50a3715e96da85e7f8705a94b" title="Call chained completion immediately instead of scheduling for later. Make SURE your completion can no...">async_op_flags::immediate</a>, std::bind(&amp;when_any_ops_do&lt;rethrow&gt;, state, n, std::placeholders::_1, std::placeholders::_2)));
<a name="l01665"></a>01665         dispatcher-&gt;completion(ops, completions);
<a name="l01666"></a>01666         <span class="keywordflow">return</span> std::move(ret);
<a name="l01667"></a>01667     }
<a name="l01668"></a>01668 <span class="preprocessor">#endif</span>
<a name="l01669"></a>01669 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_all&gt; <span class="keyword">struct </span>select_when_ops_return_type
<a name="l01670"></a>01670     {
<a name="l01671"></a>01671         <span class="keyword">typedef</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; type; <span class="comment">// when_all()</span>
<a name="l01672"></a>01672     };
<a name="l01673"></a>01673     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>select_when_ops_return_type&lt;false&gt;
<a name="l01674"></a>01674     {
<a name="l01675"></a>01675         <span class="keyword">typedef</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; type; <span class="comment">// when_any()</span>
<a name="l01676"></a>01676     };
<a name="l01677"></a>01677     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_all, <span class="keyword">class</span> T&gt; <span class="keyword">struct </span>enable_if_async_op
<a name="l01678"></a>01678     {
<a name="l01679"></a>01679         <span class="comment">//static_assert(std::is_same&lt;T, T&gt;::value, &quot;Not an iterator of async_io_op&quot;);</span>
<a name="l01680"></a>01680     };
<a name="l01681"></a>01681     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> is_all&gt; <span class="keyword">struct </span>enable_if_async_op&lt;is_all, async_io_op&gt;
<a name="l01682"></a>01682     {
<a name="l01683"></a>01683         <span class="keyword">typedef</span> <span class="keyword">typename</span> select_when_ops_return_type&lt;is_all&gt;::type type;
<a name="l01684"></a>01684     };
<a name="l01685"></a>01685 }
<a name="l01686"></a>01686 
<a name="l01699"></a>01699 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;true, typename Iterator::value_type&gt;::type when_all(std::nothrow_t _, Iterator first, Iterator last)
<a name="l01700"></a>01700 {
<a name="l01701"></a>01701     <span class="keywordflow">if</span>(first==last)
<a name="l01702"></a>01702         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01703"></a>01703     <span class="keywordflow">return</span> detail::when_all_ops&lt;false&gt;(first, last);
<a name="l01704"></a>01704 }
<a name="l01717"></a><a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635">01717</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;false, typename Iterator::value_type&gt;::type <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(std::nothrow_t _, Iterator first, Iterator last)
<a name="l01718"></a>01718 {
<a name="l01719"></a>01719     <span class="keywordflow">if</span>(first==last)
<a name="l01720"></a>01720         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01721"></a>01721     <span class="keywordflow">return</span> detail::when_any_ops&lt;false&gt;(first, last);
<a name="l01722"></a>01722 }
<a name="l01733"></a><a class="code" href="group__when__all__ops.html#ga461b0e5f0a135982cac72648a1689e83">01733</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(std::nothrow_t _, std::vector&lt;async_io_op&gt; ops)
<a name="l01734"></a>01734 {
<a name="l01735"></a>01735     <span class="keywordflow">if</span>(ops.empty())
<a name="l01736"></a>01736         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01737"></a>01737     <span class="keywordflow">return</span> detail::when_all_ops&lt;false&gt;(ops.begin(), ops.end());
<a name="l01738"></a>01738 }
<a name="l01749"></a><a class="code" href="group__when__all__ops.html#gae51d3626cd8b9d2c5fe1d3b55c451fbd">01749</a> <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(std::nothrow_t _, std::vector&lt;async_io_op&gt; ops)
<a name="l01750"></a>01750 {
<a name="l01751"></a>01751     <span class="keywordflow">if</span>(ops.empty())
<a name="l01752"></a>01752         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01753"></a>01753     <span class="keywordflow">return</span> detail::when_any_ops&lt;false&gt;(ops.begin(), ops.end());
<a name="l01754"></a>01754 }
<a name="l01766"></a><a class="code" href="group__when__all__ops.html#gaaa1c16812271841ff671cfe7f231cb0b">01766</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;true, typename Iterator::value_type&gt;::type when_all(Iterator first, Iterator last)
<a name="l01767"></a>01767 {
<a name="l01768"></a>01768     <span class="keywordflow">if</span>(first==last)
<a name="l01769"></a>01769         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01770"></a>01770     <span class="keywordflow">return</span> detail::when_all_ops&lt;true&gt;(first, last);
<a name="l01771"></a>01771 }
<a name="l01783"></a><a class="code" href="group__when__all__ops.html#ga5da03663689177b4c470ce149c87361d">01783</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> detail::enable_if_async_op&lt;false, typename Iterator::value_type&gt;::type <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(Iterator first, Iterator last)
<a name="l01784"></a>01784 {
<a name="l01785"></a>01785     <span class="keywordflow">if</span>(first==last)
<a name="l01786"></a>01786         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01787"></a>01787     <span class="keywordflow">return</span> detail::when_any_ops&lt;true&gt;(first, last);
<a name="l01788"></a>01788 }
<a name="l01798"></a><a class="code" href="group__when__all__ops.html#ga536ffef275e197aa15d35a3a4dd3a9bf">01798</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(std::vector&lt;async_io_op&gt; ops)
<a name="l01799"></a>01799 {
<a name="l01800"></a>01800     <span class="keywordflow">if</span>(ops.empty())
<a name="l01801"></a>01801         <span class="keywordflow">return</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt;();
<a name="l01802"></a>01802     <span class="keywordflow">return</span> detail::when_all_ops&lt;true&gt;(ops.begin(), ops.end());
<a name="l01803"></a>01803 }
<a name="l01813"></a><a class="code" href="group__when__all__ops.html#ga73eaeec972558c72429fbd5042307036">01813</a> <span class="keyword">inline</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; <a class="code" href="group__when__all__ops.html#ga5fd1f0c0c526e5911c5279a36f865635" title="Returns a result when any the supplied ops complete. Does not propagate exception states...">when_any</a>(std::vector&lt;async_io_op&gt; ops)
<a name="l01814"></a>01814 {
<a name="l01815"></a>01815     <span class="keywordflow">if</span>(ops.empty())
<a name="l01816"></a>01816         <span class="keywordflow">return</span> future&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;();
<a name="l01817"></a>01817     <span class="keywordflow">return</span> detail::when_any_ops&lt;true&gt;(ops.begin(), ops.end());
<a name="l01818"></a>01818 }
<a name="l01829"></a><a class="code" href="group__when__all__ops.html#gaff9f004d3897d9bf83261e45a050c252">01829</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(std::nothrow_t _, async_io_op op)
<a name="l01830"></a>01830 {
<a name="l01831"></a>01831     std::vector&lt;async_io_op&gt; ops(1, op);
<a name="l01832"></a>01832     <span class="keywordflow">return</span> when_all(_, ops);
<a name="l01833"></a>01833 }
<a name="l01843"></a><a class="code" href="group__when__all__ops.html#ga7e235ffd635c6b38fa0c416c872ae044">01843</a> <span class="keyword">inline</span> future&lt;std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt;&gt; when_all(async_io_op op)
<a name="l01844"></a>01844 {
<a name="l01845"></a>01845     std::vector&lt;async_io_op&gt; ops(1, op);
<a name="l01846"></a>01846     <span class="keywordflow">return</span> when_all(ops);
<a name="l01847"></a>01847 }
<a name="l01848"></a>01848 
<a name="l01852"></a><a class="code" href="structasync__path__op__req.html">01852</a> <span class="keyword">struct </span><a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a>
<a name="l01853"></a>01853 {
<a name="l01854"></a><a class="code" href="structasync__path__op__req.html#ac95903f23add8d81993d0aa857ebf4e0">01854</a>     filesystem::path <a class="code" href="structasync__path__op__req.html#ac95903f23add8d81993d0aa857ebf4e0" title="The filing system path to be used for this operation.">path</a>; 
<a name="l01855"></a><a class="code" href="structasync__path__op__req.html#a3051dba59ddb18a5f8a8e023f65b8801">01855</a>     <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> <a class="code" href="structasync__path__op__req.html#a3051dba59ddb18a5f8a8e023f65b8801" title="The flags to be used for this operation (note they can be overriden by flags passed during dispatcher...">flags</a>;           
<a name="l01856"></a><a class="code" href="structasync__path__op__req.html#a3851b041fa3c59aa67c375457ac37f2e">01856</a>     async_io_op <a class="code" href="structasync__path__op__req.html#a3851b041fa3c59aa67c375457ac37f2e">precondition</a>;   
<a name="l01857"></a>01857 
<a name="l01858"></a><a class="code" href="structasync__path__op__req.html#a01733eeb8f8c26f5b5e57cdd5b1542c4">01858</a>     <a class="code" href="structasync__path__op__req.html#a01733eeb8f8c26f5b5e57cdd5b1542c4" title="Default constructor.">async_path_op_req</a>() : flags(<a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a>::<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>) { }
<a name="l01866"></a><a class="code" href="structasync__path__op__req.html#a5746c1fb8b51a69f9a24eb7ea695c56f">01866</a>     <a class="code" href="structasync__path__op__req.html#a5746c1fb8b51a69f9a24eb7ea695c56f" title="Constructs an instance.">async_path_op_req</a>(filesystem::path _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(_path), flags(_flags) { <span class="keywordflow">if</span>(!path.is_absolute()) BOOST_AFIO_THROW(std::runtime_error(<span class="stringliteral">&quot;Non-absolute path&quot;</span>)); }
<a name="l01875"></a><a class="code" href="structasync__path__op__req.html#a18121b00a21954c9feae6070f9606528">01875</a>     <a class="code" href="structasync__path__op__req.html#a18121b00a21954c9feae6070f9606528" title="Constructs an instance.">async_path_op_req</a>(async_io_op _precondition, filesystem::path _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(_path), flags(_flags), precondition(std::move(_precondition)) { _validate(); <span class="keywordflow">if</span>(!path.is_absolute()) BOOST_AFIO_THROW(std::runtime_error(<span class="stringliteral">&quot;Non-absolute path&quot;</span>)); }
<a name="l01880"></a><a class="code" href="structasync__path__op__req.html#a03660fe32ffad9db2f2c9864ca21d37b">01880</a>     <a class="code" href="structasync__path__op__req.html#a03660fe32ffad9db2f2c9864ca21d37b" title="Constructs an instance.">async_path_op_req</a>(std::string _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags) { _validate(); }
<a name="l01886"></a><a class="code" href="structasync__path__op__req.html#aa8253bc55cb7108c5083671cb377a2d9">01886</a>     <a class="code" href="structasync__path__op__req.html#aa8253bc55cb7108c5083671cb377a2d9" title="Constructs an instance.">async_path_op_req</a>(async_io_op _precondition, std::string _path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags), precondition(std::move(_precondition)) { _validate(); }
<a name="l01891"></a><a class="code" href="structasync__path__op__req.html#a80ed3677a2fb31bf82155f6d6519799a">01891</a>     <a class="code" href="structasync__path__op__req.html#a80ed3677a2fb31bf82155f6d6519799a" title="Constructs an instance.">async_path_op_req</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *_path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags) { _validate(); }
<a name="l01897"></a><a class="code" href="structasync__path__op__req.html#ae78240228df17dc8f805384b53ead54d">01897</a>     <a class="code" href="structasync__path__op__req.html#ae78240228df17dc8f805384b53ead54d" title="Constructs an instance.">async_path_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> <span class="keywordtype">char</span> *_path, <a class="code" href="group__file__flags.html#gaba2d48ea5b39d1ab48c6b892a2e2d0db" title="Bitwise file and directory open flags.">file_flags</a> _flags=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>) : path(filesystem::absolute(filesystem::path(_path).make_preferred())), flags(_flags), precondition(std::move(_precondition)) { _validate(); }
<a name="l01899"></a><a class="code" href="structasync__path__op__req.html#abc282e406dc24df47df1938872558f2b">01899</a>     <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l01900"></a>01900 <span class="keyword">    </span>{
<a name="l01901"></a>01901         <span class="keywordflow">if</span>(path.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01902"></a>01902         <span class="keywordflow">return</span> !precondition.<a class="code" href="structasync__io__op.html#a5b4f46c6c6c5425e57362ff6b4eb73df" title="A unique id for this operation.">id</a> || precondition.validate();
<a name="l01903"></a>01903     }
<a name="l01904"></a>01904 <span class="keyword">private</span>:
<a name="l01905"></a>01905     <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l01906"></a>01906 <span class="keyword">    </span>{
<a name="l01907"></a>01907 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!validate())
<a name="l01909"></a>01909             BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l01910"></a>01910 <span class="preprocessor">#endif</span>
<a name="l01911"></a>01911 <span class="preprocessor"></span>    }
<a name="l01912"></a>01912 };
<a name="l01913"></a>01913 
<a name="l01914"></a>01914 <span class="keyword">namespace </span>detail
<a name="l01915"></a>01915 {
<a name="l01917"></a>01917     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> for_writing&gt; <span class="keyword">class </span>async_data_op_req_impl;
<a name="l01918"></a>01918     <span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>async_data_op_req_impl&lt;false&gt;
<a name="l01919"></a>01919     {
<a name="l01920"></a>01920     <span class="keyword">public</span>:
<a name="l01922"></a>01922         async_io_op precondition;
<a name="l01924"></a>01924         std::vector&lt;asio::mutable_buffer&gt; buffers;
<a name="l01926"></a>01926         off_t where;
<a name="l01928"></a>01928         async_data_op_req_impl() { }
<a name="l01930"></a>01930         async_data_op_req_impl(<span class="keyword">const</span> async_data_op_req_impl &amp;o) : precondition(o.precondition), buffers(o.buffers), where(o.where) { }
<a name="l01932"></a>01932         async_data_op_req_impl(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : precondition(std::move(o.precondition)), buffers(std::move(o.buffers)), where(std::move(o.where)) { }
<a name="l01934"></a>01934         async_data_op_req_impl &amp;operator=(<span class="keyword">const</span> async_data_op_req_impl &amp;o) { precondition=o.precondition; buffers=o.buffers; where=o.where; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l01936"></a>01936         async_data_op_req_impl &amp;operator=(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { precondition=std::move(o.precondition); buffers=std::move(o.buffers); where=std::move(o.where); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l01938"></a>01938         async_data_op_req_impl(async_io_op _precondition, <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : precondition(std::move(_precondition)), where(_where) { buffers.reserve(1); buffers.push_back(asio::mutable_buffer(v, _length)); _validate(); }
<a name="l01940"></a>01940         async_data_op_req_impl(async_io_op _precondition, std::vector&lt;asio::mutable_buffer&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::move(_buffers)), where(_where) { _validate(); }
<a name="l01942"></a>01942         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req_impl(async_io_op _precondition, std::array&lt;asio::mutable_buffer, N&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::make_move_iterator(_buffers.begin()), std::make_move_iterator(_buffers.end())), where(_where) { _validate(); }
<a name="l01944"></a>01944         async_data_op_req_impl(async_io_op _precondition, asio::mutable_buffer _buffer, off_t _where) : precondition(std::move(_precondition)), buffers(1, std::move(_buffer)), where(_where) { _validate(); }
<a name="l01946"></a>01946         <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l01947"></a>01947 <span class="keyword">        </span>{
<a name="l01948"></a>01948             <span class="keywordflow">if</span>(!precondition.validate()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01949"></a>01949             <span class="keywordflow">if</span>(buffers.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01950"></a>01950             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;b: buffers)
<a name="l01951"></a>01951             {
<a name="l01952"></a>01952                 <span class="keywordflow">if</span>(!asio::buffer_cast&lt;const void *&gt;(b) || !asio::buffer_size(b)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01953"></a>01953                 <span class="keywordflow">if</span>(!!(precondition.<a class="code" href="structasync__io__op.html#a961080cd4967d47310f2f584599b0a19" title="The parent dispatcher.">parent</a>-&gt;fileflags(<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>)&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b" title="Bypass the OS file buffers (only really useful for writing large files, or a lot of random reads and ...">file_flags::OSDirect</a>))
<a name="l01954"></a>01954                 {
<a name="l01955"></a>01955                     <span class="keywordflow">if</span>(((<span class="keywordtype">size_t</span>) asio::buffer_cast&lt;<span class="keyword">const</span> <span class="keywordtype">void</span> *&gt;(b) &amp; 4095) || (asio::buffer_size(b) &amp; 4095)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01956"></a>01956                 }
<a name="l01957"></a>01957             }
<a name="l01958"></a>01958             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01959"></a>01959         }
<a name="l01960"></a>01960     <span class="keyword">private</span>:
<a name="l01961"></a>01961         <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l01962"></a>01962 <span class="keyword">        </span>{
<a name="l01963"></a>01963 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l01964"></a>01964 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!validate())
<a name="l01965"></a>01965                 BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l01966"></a>01966 <span class="preprocessor">#endif</span>
<a name="l01967"></a>01967 <span class="preprocessor"></span>        }
<a name="l01968"></a>01968     };
<a name="l01969"></a>01969     <span class="keyword">template</span>&lt;&gt; <span class="keyword">class </span>async_data_op_req_impl&lt;true&gt;
<a name="l01970"></a>01970     {
<a name="l01971"></a>01971     <span class="keyword">public</span>:
<a name="l01973"></a>01973         async_io_op precondition;
<a name="l01975"></a>01975         std::vector&lt;asio::const_buffer&gt; buffers;
<a name="l01977"></a>01977         off_t where;
<a name="l01979"></a>01979         async_data_op_req_impl() { }
<a name="l01981"></a>01981         async_data_op_req_impl(<span class="keyword">const</span> async_data_op_req_impl &amp;o) : precondition(o.precondition), buffers(o.buffers), where(o.where) { }
<a name="l01983"></a>01983         async_data_op_req_impl(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : precondition(std::move(o.precondition)), buffers(std::move(o.buffers)), where(std::move(o.where)) { }
<a name="l01985"></a>01985         async_data_op_req_impl(<span class="keyword">const</span> async_data_op_req_impl&lt;false&gt; &amp;o) : precondition(o.precondition), where(o.where) { buffers.reserve(o.buffers.capacity()); <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;i: o.buffers){ buffers.push_back(i); } }
<a name="l01987"></a>01987         async_data_op_req_impl(async_data_op_req_impl&lt;false&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : precondition(std::move(o.precondition)), where(std::move(o.where)) { buffers.reserve(o.buffers.capacity()); <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;i: o.buffers){ buffers.push_back(std::move(i)); } }
<a name="l01989"></a>01989         async_data_op_req_impl &amp;operator=(<span class="keyword">const</span> async_data_op_req_impl &amp;o) { precondition=o.precondition; buffers=o.buffers; where=o.where; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l01991"></a>01991         async_data_op_req_impl &amp;operator=(async_data_op_req_impl &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { precondition=std::move(o.precondition); buffers=std::move(o.buffers); where=std::move(o.where); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l01993"></a>01993         async_data_op_req_impl(async_io_op _precondition, <span class="keyword">const</span> <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : precondition(std::move(_precondition)), where(_where) { buffers.reserve(1); buffers.push_back(asio::const_buffer(v, _length)); _validate(); }
<a name="l01995"></a>01995         async_data_op_req_impl(async_io_op _precondition, std::vector&lt;asio::const_buffer&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::move(_buffers)), where(_where) { _validate(); }
<a name="l01997"></a>01997         async_data_op_req_impl(async_io_op _precondition, std::vector&lt;asio::mutable_buffer&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), where(_where)
<a name="l01998"></a>01998         {
<a name="l01999"></a>01999             buffers.reserve(_buffers.capacity());
<a name="l02000"></a>02000             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;i: _buffers)
<a name="l02001"></a>02001                 buffers.push_back(std::move(i));
<a name="l02002"></a>02002             _validate();
<a name="l02003"></a>02003         }
<a name="l02005"></a>02005         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req_impl(async_io_op _precondition, std::array&lt;asio::const_buffer, N&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), buffers(std::make_move_iterator(_buffers.begin()), std::make_move_iterator(_buffers.end())), where(_where) { _validate(); }
<a name="l02007"></a>02007         <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req_impl(async_io_op _precondition, std::array&lt;asio::mutable_buffer, N&gt; _buffers, off_t _where) : precondition(std::move(_precondition)), where(_where)
<a name="l02008"></a>02008         {
<a name="l02009"></a>02009             buffers.reserve(_buffers.size());
<a name="l02010"></a>02010             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;&amp;i: _buffers)
<a name="l02011"></a>02011                 buffers.push_back(std::move(i));
<a name="l02012"></a>02012             _validate();
<a name="l02013"></a>02013         }
<a name="l02015"></a>02015         async_data_op_req_impl(async_io_op _precondition, asio::const_buffer _buffer, off_t _where) : precondition(std::move(_precondition)), buffers(1, std::move(_buffer)), where(_where) { _validate(); }
<a name="l02017"></a>02017         <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l02018"></a>02018 <span class="keyword">        </span>{
<a name="l02019"></a>02019             <span class="keywordflow">if</span>(!precondition.validate()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02020"></a>02020             <span class="keywordflow">if</span>(buffers.empty()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02021"></a>02021             <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;b: buffers)
<a name="l02022"></a>02022             {
<a name="l02023"></a>02023                 <span class="keywordflow">if</span>(!asio::buffer_cast&lt;const void *&gt;(b) || !asio::buffer_size(b)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02024"></a>02024                 <span class="keywordflow">if</span>(!!(precondition.parent-&gt;fileflags(<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">file_flags::None</a>)&amp;<a class="code" href="afio_8hpp.html#gaba2d48ea5b39d1ab48c6b892a2e2d0dba648331f85d7765a2b1fcc854dfde389b" title="Bypass the OS file buffers (only really useful for writing large files, or a lot of random reads and ...">file_flags::OSDirect</a>))
<a name="l02025"></a>02025                 {
<a name="l02026"></a>02026                     <span class="keywordflow">if</span>(((<span class="keywordtype">size_t</span>) asio::buffer_cast&lt;<span class="keyword">const</span> <span class="keywordtype">void</span> *&gt;(b) &amp; 4095) || (asio::buffer_size(b) &amp; 4095)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02027"></a>02027                 }
<a name="l02028"></a>02028             }
<a name="l02029"></a>02029             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02030"></a>02030         }
<a name="l02031"></a>02031     <span class="keyword">private</span>:
<a name="l02032"></a>02032         <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l02033"></a>02033 <span class="keyword">        </span>{
<a name="l02034"></a>02034 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l02035"></a>02035 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!validate())
<a name="l02036"></a>02036                 BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l02037"></a>02037 <span class="preprocessor">#endif</span>
<a name="l02038"></a>02038 <span class="preprocessor"></span>        }
<a name="l02039"></a>02039     };
<a name="l02040"></a>02040 }
<a name="l02041"></a>02041 
<a name="l02047"></a>02047 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_data_op_req : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02048"></a>02048 {
<a name="l02049"></a>02049 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02050"></a>02050 <span class="preprocessor"></span>
<a name="l02051"></a>02051     async_io_op precondition;
<a name="l02053"></a>02053     std::vector&lt;asio::mutable_buffer&gt; buffers;
<a name="l02055"></a>02055     off_t where;
<a name="l02056"></a>02056 <span class="preprocessor">#endif</span>
<a name="l02057"></a>02057 <span class="preprocessor"></span>
<a name="l02058"></a>02058     async_data_op_req()
<a name="l02059"></a>02059     {
<a name="l02060"></a>02060         static_assert(std::is_trivial&lt;T&gt;::value, <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; has not been specialised for this non-trivial type, which suggests you are trying to read or write a complex C++ type! Either add a custom specialisation, or directly instantiate an async_data_op_req with a void * and size_t length to some serialised representation.&quot;</span>);
<a name="l02061"></a>02061     }
<a name="l02063"></a>02063     async_data_op_req(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02065"></a>02065     async_data_op_req(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02067"></a>02067     async_data_op_req &amp;operator=(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02069"></a>02069     async_data_op_req &amp;operator=(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02071"></a>02071     async_data_op_req(async_io_op _precondition, T *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(v), _length, _where) { }
<a name="l02073"></a>02073     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; async_data_op_req(async_io_op _precondition, T (&amp;v)[N], off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(v), N*sizeof(T), _where) { }
<a name="l02074"></a>02074 };
<a name="l02076"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html">02076</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_data_op_req&lt;const T&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02077"></a>02077 {
<a name="l02078"></a>02078 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02079"></a>02079 <span class="preprocessor"></span>
<a name="l02080"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8b4d9a3a897eaa4f987268131105d0c1">02080</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8b4d9a3a897eaa4f987268131105d0c1" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02082"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#aced07c86b9743bcfdebe3b90c3d62591">02082</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#aced07c86b9743bcfdebe3b90c3d62591" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02084"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ab952b695d73face205cf6fe447645939">02084</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ab952b695d73face205cf6fe447645939" title="The offset at which to write.">where</a>;
<a name="l02085"></a>02085 <span class="preprocessor">#endif</span>
<a name="l02086"></a>02086 <span class="preprocessor"></span>
<a name="l02087"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a738dc8039f2811ff5873b36270c0d90f">02087</a>     async_data_op_req()
<a name="l02088"></a>02088     {
<a name="l02089"></a>02089         static_assert(std::is_trivial&lt;T&gt;::value, <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; has not been specialised for this non-trivial type, which suggests you are trying to read or write a complex C++ type! Either add a custom specialisation, or directly instantiate an async_data_op_req with a void * and size_t length to some serialised representation.&quot;</span>);
<a name="l02090"></a>02090     }
<a name="l02092"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7702b989b18bf721f1dd76887e76cfc5">02092</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7702b989b18bf721f1dd76887e76cfc5" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02094"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a4510eef78c27390babaa17c3db95091f">02094</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a4510eef78c27390babaa17c3db95091f" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02096"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#abdd353984098f09cc6bbd1688b091c34">02096</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#abdd353984098f09cc6bbd1688b091c34" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;T&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02098"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8fc71db979d7c464f3805f89b4e2fe01">02098</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a8fc71db979d7c464f3805f89b4e2fe01" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;T&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02100"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a1d2b3e0d72fc83efb6c853e62e4fd1f3">02100</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a1d2b3e0d72fc83efb6c853e62e4fd1f3" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02102"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a81da1f13244668e17b04b354e3411cb4">02102</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a81da1f13244668e17b04b354e3411cb4" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02104"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7fe9e15c8357b95da1e4c3459aecca6c">02104</a>     <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#a7fe9e15c8357b95da1e4c3459aecca6c" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> T *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(v), _length, _where) { }
<a name="l02106"></a><a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ae51742b31dd2cc992f050d02945a5edf">02106</a>     <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; <a class="code" href="structasync__data__op__req_3_01const_01_t_01_4.html#ae51742b31dd2cc992f050d02945a5edf" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> T (&amp;v)[N], off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(v), N*sizeof(const T), _where) { }
<a name="l02107"></a>02107 };
<a name="l02109"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html">02109</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;void&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02110"></a>02110 {
<a name="l02111"></a>02111 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02112"></a>02112 <span class="preprocessor"></span>
<a name="l02113"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a9a3d4c33ace8a137f5575123d557b97e">02113</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a9a3d4c33ace8a137f5575123d557b97e" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02115"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a0eb7958a607f9f5441637e73ef95c5e9">02115</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a0eb7958a607f9f5441637e73ef95c5e9" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02117"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#aff95c1adec2bdf76a0b035871840c9a5">02117</a>     off_t <a class="code" href="structasync__data__op__req_3_01void_01_4.html#aff95c1adec2bdf76a0b035871840c9a5" title="The offset from which to read.">where</a>;
<a name="l02118"></a>02118 <span class="preprocessor">#endif</span>
<a name="l02119"></a>02119 <span class="preprocessor"></span>
<a name="l02120"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#aa558bd013d3594490913660ef0df0f84">02120</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#aa558bd013d3594490913660ef0df0f84" title="Default constructor.">async_data_op_req</a>() : detail::async_data_op_req_impl&lt;false&gt;() {}
<a name="l02122"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a6b529a7c9b285a4a9b875c7ff55816a2">02122</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a6b529a7c9b285a4a9b875c7ff55816a2" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) {}
<a name="l02124"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a4fea806b7e0a5586b0b387dbe7fc3710">02124</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a4fea806b7e0a5586b0b387dbe7fc3710" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) {}
<a name="l02126"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#a7faede857bcf69cf930d9f8c95fbbcc5">02126</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#a7faede857bcf69cf930d9f8c95fbbcc5" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), v, _length, _where) { }
<a name="l02128"></a><a class="code" href="structasync__data__op__req_3_01void_01_4.html#af639bebe3826721588172364af0a0628">02128</a>     <a class="code" href="structasync__data__op__req_3_01void_01_4.html#af639bebe3826721588172364af0a0628" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;asio::mutable_buffer&gt; _buffers, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(_buffers), _where) { }
<a name="l02129"></a>02129 };
<a name="l02131"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html">02131</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;const void&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02132"></a>02132 {
<a name="l02133"></a>02133 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02134"></a>02134 <span class="preprocessor"></span>
<a name="l02135"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#aa53c260ce3a7681299932619543b13c7">02135</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#aa53c260ce3a7681299932619543b13c7" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02137"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a7e8f76f7b5ac4f366496b60a7fa7363b">02137</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a7e8f76f7b5ac4f366496b60a7fa7363b" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02139"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a81f74f0a9944e8b61ebe00e37119d1ad">02139</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a81f74f0a9944e8b61ebe00e37119d1ad" title="The offset at which to write.">where</a>;
<a name="l02140"></a>02140 <span class="preprocessor">#endif</span>
<a name="l02141"></a>02141 <span class="preprocessor"></span>
<a name="l02142"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a17fc278eb5804e1a89c2df7b7d30e797">02142</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a17fc278eb5804e1a89c2df7b7d30e797" title="Default constructor.">async_data_op_req</a>() : detail::async_data_op_req_impl&lt;true&gt;() {}
<a name="l02144"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a8f9db5191e5916f8b131a7571eb14aaf">02144</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#a8f9db5191e5916f8b131a7571eb14aaf" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) {}
<a name="l02146"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#af0717c1869e7d5be6eb7ccf94a889ebb">02146</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#af0717c1869e7d5be6eb7ccf94a889ebb" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) {}
<a name="l02148"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#acf2bd064426fe9ac1e9978b8a2bec55e">02148</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#acf2bd064426fe9ac1e9978b8a2bec55e" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> <a class="code" href="structasync__data__op__req_3_01void_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `void *`. Data MUST stay arou...">async_data_op_req&lt;void&gt;</a> &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) {}
<a name="l02150"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ac3df6c3518a7c33be618ebd588949055">02150</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ac3df6c3518a7c33be618ebd588949055" title="Move constructor.">async_data_op_req</a>(<a class="code" href="structasync__data__op__req_3_01void_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `void *`. Data MUST stay arou...">async_data_op_req&lt;void&gt;</a> &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) {}
<a name="l02152"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ae0fcde818165bc41d923a15d58c54f73">02152</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ae0fcde818165bc41d923a15d58c54f73" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> <span class="keywordtype">void</span> *v, <span class="keywordtype">size_t</span> _length, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), v, _length, _where) {}
<a name="l02154"></a><a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ab3c43cd3df4250f3e6596cf84969e416">02154</a>     <a class="code" href="structasync__data__op__req_3_01const_01void_01_4.html#ab3c43cd3df4250f3e6596cf84969e416" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;asio::const_buffer&gt; _buffers, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), _buffers, _where) {}
<a name="l02155"></a>02155 };
<a name="l02157"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html">02157</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::vector&lt;T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02158"></a>02158 {
<a name="l02159"></a>02159 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02160"></a>02160 <span class="preprocessor"></span>
<a name="l02161"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a9db2f0540837497d4a74a9f9aa99249f">02161</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a9db2f0540837497d4a74a9f9aa99249f" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02163"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aec83c0f40f5da938e613bc1430f11f6e">02163</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aec83c0f40f5da938e613bc1430f11f6e" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02165"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afb9fabc95d35f67e787b57786ffcf02c">02165</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afb9fabc95d35f67e787b57786ffcf02c" title="The offset from which to read.">where</a>;
<a name="l02166"></a>02166 <span class="preprocessor">#endif</span>
<a name="l02167"></a>02167 <span class="preprocessor"></span>
<a name="l02168"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a195b101f57cfaf387a3dd32e569acb93">02168</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a195b101f57cfaf387a3dd32e569acb93" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02170"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aff540d1545e2637f9d37a56274d528c0">02170</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aff540d1545e2637f9d37a56274d528c0" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02172"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a4b845f1cec265bb75621119abb08a211">02172</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a4b845f1cec265bb75621119abb08a211" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02174"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aedc5dde6a41a422582735fadda7feea6">02174</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aedc5dde6a41a422582735fadda7feea6" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02176"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#adfa9d04476557664c362c326cd5eaa11">02176</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#adfa9d04476557664c362c326cd5eaa11" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02178"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a7a721ac1449a0a8ece653a124765611e">02178</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a7a721ac1449a0a8ece653a124765611e" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02179"></a>02179 };
<a name="l02181"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html">02181</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;const std::vector&lt;T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02182"></a>02182 {
<a name="l02183"></a>02183 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02184"></a>02184 <span class="preprocessor"></span>
<a name="l02185"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aebdd3b41b4a23ba0f1cb7165ebaddd75">02185</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aebdd3b41b4a23ba0f1cb7165ebaddd75" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02187"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a8006799ba08f6491079299e404c2d12b">02187</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a8006799ba08f6491079299e404c2d12b" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02189"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#acd50d8734e5bb4fc197da26c50071db7">02189</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#acd50d8734e5bb4fc197da26c50071db7" title="The offset at which to write.">where</a>;
<a name="l02190"></a>02190 <span class="preprocessor">#endif</span>
<a name="l02191"></a>02191 <span class="preprocessor"></span>
<a name="l02192"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a61c9e301eaf590af2fcb83c4593f29a1">02192</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a61c9e301eaf590af2fcb83c4593f29a1" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02194"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#abd8995c446dfa1d7f6b7346d4f708ac4">02194</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#abd8995c446dfa1d7f6b7346d4f708ac4" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02196"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a09f8468de149cefe3f4b9b7f2cfa1701">02196</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a09f8468de149cefe3f4b9b7f2cfa1701" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02198"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a913d0574ae7097d0b5482ec0eafe7249">02198</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a913d0574ae7097d0b5482ec0eafe7249" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::vector&lt;T, A&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02200"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aed5a52bdf30d6ca171f3135a41126feb">02200</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#aed5a52bdf30d6ca171f3135a41126feb" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::vector&lt;T, A&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02202"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#ad5ad8e147f55a22be13f9e00b99c5017">02202</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#ad5ad8e147f55a22be13f9e00b99c5017" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02204"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a661702a38a8a78c15689790595cc21a6">02204</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#a661702a38a8a78c15689790595cc21a6" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02206"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afa54d4431109c5b09ce1f59277d06332">02206</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1vector_3_01_t_00_01_a_01_4_01_4.html#afa54d4431109c5b09ce1f59277d06332" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> std::vector&lt;T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02207"></a>02207 };
<a name="l02209"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html">02209</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::array&lt;T, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02210"></a>02210 {
<a name="l02211"></a>02211 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02212"></a>02212 <span class="preprocessor"></span>
<a name="l02213"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#acb5ee9d7632ca61dfab1160835d19972">02213</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#acb5ee9d7632ca61dfab1160835d19972" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02215"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5fd23ea876988bbca4a89b7e84b9f4aa">02215</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5fd23ea876988bbca4a89b7e84b9f4aa" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02217"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a79b356b3e800ca045aba540d82891257">02217</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a79b356b3e800ca045aba540d82891257" title="The offset from which to read.">where</a>;
<a name="l02218"></a>02218 <span class="preprocessor">#endif</span>
<a name="l02219"></a>02219 <span class="preprocessor"></span>
<a name="l02220"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ac70890879b0c205062db792c4a355003">02220</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ac70890879b0c205062db792c4a355003" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02222"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4e5b046c0cac3f3440a8680e0f5fee31">02222</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4e5b046c0cac3f3440a8680e0f5fee31" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02224"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#aa7dbc72c6c7c3a2bfe80615545c1158e">02224</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#aa7dbc72c6c7c3a2bfe80615545c1158e" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02226"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4c42d29e8c40be8f1f71c7989584095d">02226</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a4c42d29e8c40be8f1f71c7989584095d" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02228"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a21be2104ee4acfdbcc847190aa6c59c1">02228</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a21be2104ee4acfdbcc847190aa6c59c1" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02230"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5f99e325c396acbba17a571a104f70c3">02230</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a5f99e325c396acbba17a571a104f70c3" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::array&lt;T, N&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02231"></a>02231 };
<a name="l02233"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html">02233</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;const std::array&lt;T, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02234"></a>02234 {
<a name="l02235"></a>02235 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02236"></a>02236 <span class="preprocessor"></span>
<a name="l02237"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a99f191975dc73ffb53dcc7d26fe992b5">02237</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a99f191975dc73ffb53dcc7d26fe992b5" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02239"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ae99a2152f6c647d77512167b05c18b3d">02239</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#ae99a2152f6c647d77512167b05c18b3d" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02241"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#af77cca1ba0410f9350d08534f30081d8">02241</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#af77cca1ba0410f9350d08534f30081d8" title="The offset at which to write.">where</a>;
<a name="l02242"></a>02242 <span class="preprocessor">#endif</span>
<a name="l02243"></a>02243 <span class="preprocessor"></span>
<a name="l02244"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a7ed58b855c3121a7bf03564631e7ee51">02244</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a7ed58b855c3121a7bf03564631e7ee51" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02246"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a39f2cc7b884f5812ca586bc96ee6c2c0">02246</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a39f2cc7b884f5812ca586bc96ee6c2c0" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02248"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a63b99d8a9ac63251e4974dad7b5b2a08">02248</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a63b99d8a9ac63251e4974dad7b5b2a08" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02250"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a192d6df315e6d9e8c7a71f8390616396">02250</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a192d6df315e6d9e8c7a71f8390616396" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02252"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a29bb9526a7589b026b9f0119dc8c203a">02252</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a29bb9526a7589b026b9f0119dc8c203a" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02254"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a3867065cefffea7aef06ec3e1719b704">02254</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a3867065cefffea7aef06ec3e1719b704" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::array&lt;T, N&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02256"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a8f748d7b94cb78368011a01d409b6d1b">02256</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a8f748d7b94cb78368011a01d409b6d1b" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::array&lt;T, N&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02258"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a2a55626673c70fbd1da12a96bf6962c6">02258</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1array_3_01_t_00_01_n_01_4_01_4.html#a2a55626673c70fbd1da12a96bf6962c6" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> std::array&lt;T, N&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(&amp;v.front()), v.size()*sizeof(T), _where) { }
<a name="l02259"></a>02259 };
<a name="l02261"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html">02261</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::vector&lt;asio::mutable_buffer, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02262"></a>02262 {
<a name="l02263"></a>02263 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02264"></a>02264 <span class="preprocessor"></span>
<a name="l02265"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6e37945550d9a46c0be6d92d1c16b654">02265</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6e37945550d9a46c0be6d92d1c16b654" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02267"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a5c26fcd74b282d754cbfffaed20ace3f">02267</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a5c26fcd74b282d754cbfffaed20ace3f" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02269"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#ac9924a15aa7c81b7ad25de53531dd851">02269</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#ac9924a15aa7c81b7ad25de53531dd851" title="The offset from which to read.">where</a>;
<a name="l02270"></a>02270 <span class="preprocessor">#endif</span>
<a name="l02271"></a>02271 <span class="preprocessor"></span>
<a name="l02272"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a8596b5a26663e2c06b140ff574ced07a">02272</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a8596b5a26663e2c06b140ff574ced07a" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02274"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a215e023b2c26c9f17b1b102caf374aee">02274</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a215e023b2c26c9f17b1b102caf374aee" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02276"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#aff1df306f1f444b292ab1b2f76f641b4">02276</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#aff1df306f1f444b292ab1b2f76f641b4" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02278"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#adcf662b4d0482e51ef93c69fe2c00723">02278</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#adcf662b4d0482e51ef93c69fe2c00723" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02280"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6b543b32e6265fdffa3fff4e2f555375">02280</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a6b543b32e6265fdffa3fff4e2f555375" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02282"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a35e5850e928e2404310439489fb66b75">02282</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1mutable__buffer_00_01_a_01_4_01_4.html#a35e5850e928e2404310439489fb66b75" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;asio::mutable_buffer, A&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02283"></a>02283 };
<a name="l02285"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html">02285</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::vector&lt;asio::const_buffer, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02286"></a>02286 {
<a name="l02287"></a>02287 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02288"></a>02288 <span class="preprocessor"></span>
<a name="l02289"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a96aaef69a540855aa4af09d71777d26f">02289</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a96aaef69a540855aa4af09d71777d26f" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02291"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a32b9252bfb7b26c535b549a778d3551f">02291</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a32b9252bfb7b26c535b549a778d3551f" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02293"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ab1c9770402783c7fbccd4387ebc73010">02293</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ab1c9770402783c7fbccd4387ebc73010" title="The offset at which to write.">where</a>;
<a name="l02294"></a>02294 <span class="preprocessor">#endif</span>
<a name="l02295"></a>02295 <span class="preprocessor"></span>
<a name="l02296"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a9a41cdd9c1810a43645e4d10a5a15753">02296</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a9a41cdd9c1810a43645e4d10a5a15753" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02298"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a90d77633b50e21359689b0d8880309d4">02298</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a90d77633b50e21359689b0d8880309d4" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02300"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#aed50463a7d21774c7282a0c9ad30c1f1">02300</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#aed50463a7d21774c7282a0c9ad30c1f1" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02302"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ad2d687d997a66b5ae091fc67f7caef2f">02302</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#ad2d687d997a66b5ae091fc67f7caef2f" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::vector&lt;asio::mutable_buffer, A&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02304"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a1cce8cc8b1f6e51a3d54298762adfde0">02304</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a1cce8cc8b1f6e51a3d54298762adfde0" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::vector&lt;asio::mutable_buffer, A&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02306"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a41c1e249c0f9fd93a77a4d4cb0453266">02306</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a41c1e249c0f9fd93a77a4d4cb0453266" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02308"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#abb1687dd8b9aa11b1efd13aa103e4d87">02308</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#abb1687dd8b9aa11b1efd13aa103e4d87" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02310"></a><a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a6b507d6b73a4f072464c336c6fa78681">02310</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A2&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1vector_3_01asio_1_1const__buffer_00_01_a_01_4_01_4.html#a6b507d6b73a4f072464c336c6fa78681" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::vector&lt;T, A2&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02311"></a>02311 };
<a name="l02313"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html">02313</a> <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::array&lt;asio::mutable_buffer, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02314"></a>02314 {
<a name="l02315"></a>02315 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02316"></a>02316 <span class="preprocessor"></span>
<a name="l02317"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a25f18c4d46dd8fb6fbcf2d2a9c9b2eeb">02317</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a25f18c4d46dd8fb6fbcf2d2a9c9b2eeb" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02319"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a45d984e7a77aee860a7640ea22aa7c6d">02319</a>     std::array&lt;asio::mutable_buffer, N&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a45d984e7a77aee860a7640ea22aa7c6d" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02321"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9869697e2505b05e18a9faf58edd9549">02321</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9869697e2505b05e18a9faf58edd9549" title="The offset from which to read.">where</a>;
<a name="l02322"></a>02322 <span class="preprocessor">#endif</span>
<a name="l02323"></a>02323 <span class="preprocessor"></span>
<a name="l02324"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9c7c24fc70ee97db4870f723747c9783">02324</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a9c7c24fc70ee97db4870f723747c9783" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02326"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#aab958fb56414e3609d5f8ae4bb82577d">02326</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#aab958fb56414e3609d5f8ae4bb82577d" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02328"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a8c44dbc38bc88ab78189bc918780e84d">02328</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a8c44dbc38bc88ab78189bc918780e84d" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02330"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#af82bcc3231f014ca8ea5898f00492a89">02330</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#af82bcc3231f014ca8ea5898f00492a89" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02332"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7e1f20afe25b60b7a9483db9d6d2342f">02332</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7e1f20afe25b60b7a9483db9d6d2342f" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02334"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7ffa120670eaed014318ba7cb68c0486">02334</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1mutable__buffer_00_01_n_01_4_01_4.html#a7ffa120670eaed014318ba7cb68c0486" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::array&lt;asio::mutable_buffer, N&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02335"></a>02335 };
<a name="l02337"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html">02337</a> <span class="keyword">template</span>&lt;<span class="keywordtype">size_t</span> N&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::array&lt;asio::const_buffer, N&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02338"></a>02338 {
<a name="l02339"></a>02339 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02340"></a>02340 <span class="preprocessor"></span>
<a name="l02341"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a8c0e3c75ae0782316d2cc8513576e145">02341</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a8c0e3c75ae0782316d2cc8513576e145" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02343"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ac68c0ff61680ef02dedb28984f6857b7">02343</a>     std::array&lt;asio::const_buffer, N&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ac68c0ff61680ef02dedb28984f6857b7" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02345"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ab3a337449e3e644fd3ef0b716dae8555">02345</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#ab3a337449e3e644fd3ef0b716dae8555" title="The offset at which to write.">where</a>;
<a name="l02346"></a>02346 <span class="preprocessor">#endif</span>
<a name="l02347"></a>02347 <span class="preprocessor"></span>
<a name="l02348"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a34171ac3e246df2d303a88515512b134">02348</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a34171ac3e246df2d303a88515512b134" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02350"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adf55b3d3bb7198e4ef97d3ab02572bb9">02350</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adf55b3d3bb7198e4ef97d3ab02572bb9" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02352"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a2592fce1ac89c75967f199adbab7f3b7">02352</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a2592fce1ac89c75967f199adbab7f3b7" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02354"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adcfbdc143dbaa9c0cc74dff5a38189fd">02354</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#adcfbdc143dbaa9c0cc74dff5a38189fd" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::array&lt;asio::mutable_buffer, N&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02356"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a0c5111171d28ef4a8b25cb8169c3f760">02356</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a0c5111171d28ef4a8b25cb8169c3f760" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::array&lt;asio::mutable_buffer, N&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02358"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a5b7434d822be52057a5b97f60ad449bc">02358</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a5b7434d822be52057a5b97f60ad449bc" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02360"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a750966cc6b1ed8bd9d6b549503ddf830">02360</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a750966cc6b1ed8bd9d6b549503ddf830" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02362"></a><a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a728401f6d4cb93434b4340cdd5e3feeb">02362</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1array_3_01asio_1_1const__buffer_00_01_n_01_4_01_4.html#a728401f6d4cb93434b4340cdd5e3feeb" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::array&lt;T, N&gt; v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02363"></a>02363 };
<a name="l02365"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html">02365</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;std::basic_string&lt;C, T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02366"></a>02366 {
<a name="l02367"></a>02367 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02368"></a>02368 <span class="preprocessor"></span>
<a name="l02369"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a525ee986c7b2201e3d23c653ffa9b8f6">02369</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a525ee986c7b2201e3d23c653ffa9b8f6" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02371"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acdcaa44cd54feec5300ba413ec450ed9">02371</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acdcaa44cd54feec5300ba413ec450ed9" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02373"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acfd0a6074f911d2cf3f5e152fef64e9a">02373</a>     off_t <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acfd0a6074f911d2cf3f5e152fef64e9a" title="The offset from which to read.">where</a>;
<a name="l02374"></a>02374 <span class="preprocessor">#endif</span>
<a name="l02375"></a>02375 <span class="preprocessor"></span>
<a name="l02376"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a0b60afc2d284899ab71bb12119ca1ddb">02376</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a0b60afc2d284899ab71bb12119ca1ddb" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02378"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a456015d21af288631910efa3498979ea">02378</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a456015d21af288631910efa3498979ea" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02380"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#abfeadd2c0ae3cc72ecc95f8a7104e85f">02380</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#abfeadd2c0ae3cc72ecc95f8a7104e85f" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02382"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ae093a1705c26004807fa45935070e7c7">02382</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ae093a1705c26004807fa45935070e7c7" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02384"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e409e11c523f5db6ca3835eda85e4fc">02384</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e409e11c523f5db6ca3835eda85e4fc" title="Move constructor.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02386"></a><a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aaea31ce0a843abb2d4f0442e074e0a06">02386</a>     <a class="code" href="structasync__data__op__req_3_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aaea31ce0a843abb2d4f0442e074e0a06" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, std::basic_string&lt;C, T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), static_cast&lt;void *&gt;(&amp;v.front()), v.size()*sizeof(A), _where) { }
<a name="l02387"></a>02387 };
<a name="l02389"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html">02389</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> T, <span class="keyword">class</span> A&gt; <span class="keyword">struct </span>async_data_op_req&lt;const std::basic_string&lt;C, T, A&gt;&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02390"></a>02390 {
<a name="l02391"></a>02391 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02392"></a>02392 <span class="preprocessor"></span>
<a name="l02393"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a2cfcd5b994620baf0a5757a629dce484">02393</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a2cfcd5b994620baf0a5757a629dce484" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02395"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ac62b80afd1757f4f84024528612c7e12">02395</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#ac62b80afd1757f4f84024528612c7e12" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02397"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acddd1a08ec4238e3e81f799debc0eeee">02397</a>     off_t <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acddd1a08ec4238e3e81f799debc0eeee" title="The offset at which to write.">where</a>;
<a name="l02398"></a>02398 <span class="preprocessor">#endif</span>
<a name="l02399"></a>02399 <span class="preprocessor"></span>
<a name="l02400"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aca6fd4e13e3bc7ae145a32ef42497484">02400</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#aca6fd4e13e3bc7ae145a32ef42497484" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02402"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a46fc7c368c2f03510e4e2763a44a515b">02402</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a46fc7c368c2f03510e4e2763a44a515b" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02404"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9808c756f3772dfb1b76b8927b673ed1">02404</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9808c756f3772dfb1b76b8927b673ed1" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02406"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e3527b1237141911c14413c2ffc1587">02406</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a4e3527b1237141911c14413c2ffc1587" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req&lt;std::basic_string&lt;C, T, A&gt;&gt; &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02408"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a30b8e47a54718fb9aec6a683d7495759">02408</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a30b8e47a54718fb9aec6a683d7495759" title="Move constructor.">async_data_op_req</a>(async_data_op_req&lt;std::basic_string&lt;C, T, A&gt;&gt; &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02410"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acaa4bbc37f047955586c59251d3d1606">02410</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#acaa4bbc37f047955586c59251d3d1606" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02412"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9be210fd68569fd3ca98bf90701c951a">02412</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a9be210fd68569fd3ca98bf90701c951a" title="Move constructor.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02414"></a><a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a60a2dfab6ba9465922bda18f28275b49">02414</a>     <a class="code" href="structasync__data__op__req_3_01const_01std_1_1basic__string_3_01_c_00_01_t_00_01_a_01_4_01_4.html#a60a2dfab6ba9465922bda18f28275b49" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, <span class="keyword">const</span> std::basic_string&lt;C, T, A&gt; &amp;v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), static_cast&lt;const void *&gt;(&amp;v.front()), v.size()*sizeof(A), _where) { }
<a name="l02415"></a>02415 };
<a name="l02417"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html">02417</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;asio::mutable_buffer&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;false&gt;
<a name="l02418"></a>02418 {
<a name="l02419"></a>02419 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02420"></a>02420 <span class="preprocessor"></span>
<a name="l02421"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#adb72dc04c894f589cfa11e06033986b7">02421</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#adb72dc04c894f589cfa11e06033986b7" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02423"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a00e9df53735d13ba23cbffde07c2208d">02423</a>     std::vector&lt;asio::mutable_buffer&gt; <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a00e9df53735d13ba23cbffde07c2208d" title="A sequence of mutable Boost.ASIO buffers to read into.">buffers</a>;
<a name="l02425"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a352c10c1eb0578e6c34b18782986c9f1">02425</a>     off_t <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a352c10c1eb0578e6c34b18782986c9f1" title="The offset from which to read.">where</a>;
<a name="l02426"></a>02426 <span class="preprocessor">#endif</span>
<a name="l02427"></a>02427 <span class="preprocessor"></span>
<a name="l02428"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a48efb4aae104a4776026bad1359648f6">02428</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a48efb4aae104a4776026bad1359648f6" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02430"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a923630dbc44914a9175d14d4dcc2b390">02430</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a923630dbc44914a9175d14d4dcc2b390" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;false&gt;(o) { }
<a name="l02432"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a61b1903a93a23c18bb2e457ad16a005a">02432</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a61b1903a93a23c18bb2e457ad16a005a" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;false&gt;(std::move(o)) { }
<a name="l02434"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a18ab52f4d6cdff6d764e88024b2f402f">02434</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a18ab52f4d6cdff6d764e88024b2f402f" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02436"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a57b2fed7167367325c5805ee099aec20">02436</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a57b2fed7167367325c5805ee099aec20" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;false&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02438"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a2d3c8951978e6882c52d95419959debc">02438</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html#a2d3c8951978e6882c52d95419959debc" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, asio::mutable_buffer v, off_t _where) : detail::async_data_op_req_impl&lt;false&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02439"></a>02439 };
<a name="l02441"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html">02441</a> <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>async_data_op_req&lt;asio::const_buffer&gt; : <span class="keyword">public</span> detail::async_data_op_req_impl&lt;true&gt;
<a name="l02442"></a>02442 {
<a name="l02443"></a>02443 <span class="preprocessor">#ifdef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02444"></a>02444 <span class="preprocessor"></span>
<a name="l02445"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac62a9510152febe5b52cdf8ded4c50e4">02445</a>     async_io_op <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac62a9510152febe5b52cdf8ded4c50e4" title="A precondition containing an open file handle for this operation.">precondition</a>;
<a name="l02447"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b3f627ff6d124d636256791ddd4ce20">02447</a>     std::vector&lt;asio::const_buffer&gt; <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b3f627ff6d124d636256791ddd4ce20" title="A sequence of const Boost.ASIO buffers to write from.">buffers</a>;
<a name="l02449"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a717d51ec0e38a5f74a0cc73f2369df15">02449</a>     off_t <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a717d51ec0e38a5f74a0cc73f2369df15" title="The offset at which to write.">where</a>;
<a name="l02450"></a>02450 <span class="preprocessor">#endif</span>
<a name="l02451"></a>02451 <span class="preprocessor"></span>
<a name="l02452"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a44b751cb7871080e9cec788ce1676a8f">02452</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a44b751cb7871080e9cec788ce1676a8f" title="Default constructor.">async_data_op_req</a>() { }
<a name="l02454"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b7ef7381fdee258c3586a5a90fd279c">02454</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8b7ef7381fdee258c3586a5a90fd279c" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> async_data_op_req &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02456"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac0122ab2255985f00f34fdf66ae960ec">02456</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#ac0122ab2255985f00f34fdf66ae960ec" title="Move constructor.">async_data_op_req</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02458"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a453629ca791dfbb313c17c7bbce30644">02458</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a453629ca791dfbb313c17c7bbce30644" title="Copy constructor.">async_data_op_req</a>(<span class="keyword">const</span> <a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `asio::mutable_buffer`. Data MUST stay around until the operation completes.">async_data_op_req&lt;asio::mutable_buffer&gt;</a> &amp;o) : detail::async_data_op_req_impl&lt;true&gt;(o) { }
<a name="l02460"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8fbcbd3b18b16f3cc65cee4060d29476">02460</a>     <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a8fbcbd3b18b16f3cc65cee4060d29476" title="Move constructor.">async_data_op_req</a>(<a class="code" href="structasync__data__op__req_3_01asio_1_1mutable__buffer_01_4.html" title="A convenience bundle of precondition, data and where for reading into a `asio::mutable_buffer`. Data MUST stay around until the operation completes.">async_data_op_req&lt;asio::mutable_buffer&gt;</a> &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW : detail::async_data_op_req_impl&lt;true&gt;(std::move(o)) { }
<a name="l02462"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a3c20c6a7d30faa80c9363ee4c38c8744">02462</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a3c20c6a7d30faa80c9363ee4c38c8744" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> async_data_op_req &amp;o) { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=o; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02464"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a4d72d72cb0c7cb9b7ae48ce3b6b368d8">02464</a>     async_data_op_req &amp;<a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a4d72d72cb0c7cb9b7ae48ce3b6b368d8" title="Move assignment.">operator=</a>(async_data_op_req &amp;&amp;o) BOOST_NOEXCEPT_OR_NOTHROW { <span class="keyword">static_cast&lt;</span>detail::async_data_op_req_impl&lt;true&gt;<span class="keyword">&gt;</span>(*this)=std::move(o); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l02466"></a><a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a2afaf95515131055772953aab880a193">02466</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <a class="code" href="structasync__data__op__req_3_01asio_1_1const__buffer_01_4.html#a2afaf95515131055772953aab880a193" title="Constructs an instance.">async_data_op_req</a>(async_io_op _precondition, T v, off_t _where) : detail::async_data_op_req_impl&lt;true&gt;(std::move(_precondition), std::move(v), _where) { }
<a name="l02467"></a>02467 };
<a name="l02468"></a>02468 
<a name="l02480"></a><a class="code" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e">02480</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_data_op_req&lt;typename std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type&gt; <a class="code" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e" title="Convenience instantiator of a async_data_op_req, letting the compiler deduce the template specialisat...">make_async_data_op_req</a>(async_io_op _precondition, T &amp;&amp;v, off_t _where)
<a name="l02481"></a>02481 {
<a name="l02482"></a>02482     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type _T;
<a name="l02483"></a>02483     <span class="keywordflow">return</span> async_data_op_req&lt;_T&gt;(_precondition, v, _where);
<a name="l02484"></a>02484 }
<a name="l02497"></a><a class="code" href="group__make__async__data__op__req.html#ga7a472d3abdf6c990c3475b8c120863dc">02497</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> async_data_op_req&lt;typename std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type&gt; <a class="code" href="group__make__async__data__op__req.html#gadc690546179d67a27772655c9455c47e" title="Convenience instantiator of a async_data_op_req, letting the compiler deduce the template specialisat...">make_async_data_op_req</a>(async_io_op _precondition, T &amp;&amp;v, <span class="keywordtype">size_t</span> _length, off_t _where)
<a name="l02498"></a>02498 {
<a name="l02499"></a>02499     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::remove_pointer&lt;typename std::decay&lt;T&gt;::type&gt;::type _T;
<a name="l02500"></a>02500     <span class="keywordflow">return</span> async_data_op_req&lt;_T&gt;(_precondition, v, _length, _where);
<a name="l02501"></a>02501 }
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 
<a name="l02517"></a><a class="code" href="structasync__enumerate__op__req.html">02517</a> <span class="keyword">struct </span><a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>
<a name="l02518"></a>02518 {
<a name="l02519"></a><a class="code" href="structasync__enumerate__op__req.html#a7e93fbb402a04aa4e349a2c5d05ff143">02519</a>     async_io_op <a class="code" href="structasync__enumerate__op__req.html#a7e93fbb402a04aa4e349a2c5d05ff143" title="A precondition for this operation.">precondition</a>;    
<a name="l02520"></a><a class="code" href="structasync__enumerate__op__req.html#a3f3c1f47214de54e22394910e410ad61">02520</a>     <span class="keywordtype">size_t</span> <a class="code" href="structasync__enumerate__op__req.html#a3f3c1f47214de54e22394910e410ad61" title="The maximum number of items to return in this request. Note that setting to one will often invoke two...">maxitems</a>;             
<a name="l02521"></a><a class="code" href="structasync__enumerate__op__req.html#afa340706a6f1ec9fa79583f5d2d89017">02521</a>     <span class="keywordtype">bool</span> <a class="code" href="structasync__enumerate__op__req.html#afa340706a6f1ec9fa79583f5d2d89017" title="Restarts the enumeration for this open directory handle.">restart</a>;                
<a name="l02522"></a><a class="code" href="structasync__enumerate__op__req.html#afe7743a44c86fbf2be24527f314ebcad">02522</a>     filesystem::path <a class="code" href="structasync__enumerate__op__req.html#afe7743a44c86fbf2be24527f314ebcad" title="An optional shell glob by which to filter the items returned. Done kernel side on Windows...">glob</a>;  
<a name="l02523"></a><a class="code" href="structasync__enumerate__op__req.html#a58c3b318b33c65d99964e4ba944162d8">02523</a>     <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> metadata;     
<a name="l02524"></a>02524 
<a name="l02525"></a>02525     <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a>() : maxitems(0), restart(false), metadata(<a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a>::<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">None</a>) { }
<a name="l02534"></a><a class="code" href="structasync__enumerate__op__req.html#acd207be41eb88727b5087a35b872c1dd">02534</a>     <a class="code" href="structasync__enumerate__op__req.html#acd207be41eb88727b5087a35b872c1dd" title="Constructs an instance.">async_enumerate_op_req</a>(async_io_op _precondition, <span class="keywordtype">size_t</span> _maxitems=2, <span class="keywordtype">bool</span> _restart=<span class="keyword">true</span>, filesystem::path _glob=filesystem::path(), <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _metadata=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">metadata_flags::None</a>) : precondition(std::move(_precondition)), maxitems(_maxitems), restart(_restart), glob(std::move(_glob)), metadata(_metadata) { _validate(); }
<a name="l02543"></a><a class="code" href="structasync__enumerate__op__req.html#a76dfe1869add53f3bfe533ac2c998bad">02543</a>     <a class="code" href="structasync__enumerate__op__req.html#a76dfe1869add53f3bfe533ac2c998bad" title="Constructs an instance.">async_enumerate_op_req</a>(async_io_op _precondition, filesystem::path _glob, <span class="keywordtype">size_t</span> _maxitems=2, <span class="keywordtype">bool</span> _restart=<span class="keyword">true</span>, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _metadata=<a class="code" href="afio_8hpp.html#ga9d8b6ad0ba3e48637529aace103e11feac7485dcc8d256a6f197ed7802687f252" title="No flags set.">metadata_flags::None</a>) : precondition(std::move(_precondition)), maxitems(_maxitems), restart(_restart), glob(std::move(_glob)), metadata(_metadata) { _validate(); }
<a name="l02552"></a><a class="code" href="structasync__enumerate__op__req.html#acf7ec47be195a0210ec9f3d3b1221247">02552</a>     <a class="code" href="structasync__enumerate__op__req.html#acf7ec47be195a0210ec9f3d3b1221247" title="Constructs an instance.">async_enumerate_op_req</a>(async_io_op _precondition, <a class="code" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe" title="Bitflags for availability of metadata from `struct stat_t`.">metadata_flags</a> _metadata, <span class="keywordtype">size_t</span> _maxitems=2, <span class="keywordtype">bool</span> _restart=<span class="keyword">true</span>, filesystem::path _glob=filesystem::path()) : precondition(std::move(_precondition)), maxitems(_maxitems), restart(_restart), glob(std::move(_glob)), metadata(_metadata) { _validate(); }
<a name="l02554"></a><a class="code" href="structasync__enumerate__op__req.html#a3609173f9d91cfaefa842d3e2d86165b">02554</a>     <span class="keywordtype">bool</span> validate()<span class="keyword"> const</span>
<a name="l02555"></a>02555 <span class="keyword">    </span>{
<a name="l02556"></a>02556         <span class="keywordflow">if</span>(!maxitems) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02557"></a>02557         <span class="keywordflow">return</span> !precondition.id || precondition.validate();
<a name="l02558"></a>02558     }
<a name="l02559"></a>02559 <span class="keyword">private</span>:
<a name="l02560"></a>02560     <span class="keywordtype">void</span> _validate()<span class="keyword"> const</span>
<a name="l02561"></a>02561 <span class="keyword">    </span>{
<a name="l02562"></a>02562 <span class="preprocessor">#if BOOST_AFIO_VALIDATE_INPUTS</span>
<a name="l02563"></a>02563 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!validate())
<a name="l02564"></a>02564             BOOST_AFIO_THROW(std::invalid_argument(<span class="stringliteral">&quot;Inputs are invalid.&quot;</span>));
<a name="l02565"></a>02565 <span class="preprocessor">#endif</span>
<a name="l02566"></a>02566 <span class="preprocessor"></span>    }
<a name="l02567"></a>02567 };
<a name="l02568"></a>02568 
<a name="l02569"></a>02569 
<a name="l02570"></a>02570 <span class="keyword">namespace </span>detail {
<a name="l02571"></a>02571     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> iswrite, <span class="keyword">class</span> T&gt; <span class="keyword">struct </span>async_file_io_dispatcher_rwconverter
<a name="l02572"></a>02572     {
<a name="l02573"></a>02573         <span class="keyword">typedef</span> detail::async_data_op_req_impl&lt;iswrite&gt; return_type;
<a name="l02574"></a>02574         <span class="keyword">const</span> std::vector&lt;return_type&gt; &amp;operator()(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops)
<a name="l02575"></a>02575         {
<a name="l02576"></a>02576             <span class="keyword">typedef</span> async_data_op_req&lt;T&gt; reqT;
<a name="l02577"></a>02577             static_assert(std::is_convertible&lt;reqT, return_type&gt;::value, <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; is not convertible to detail::async_data_op_req_impl&lt;constness&gt;&quot;</span>);
<a name="l02578"></a>02578             static_assert(<span class="keyword">sizeof</span>(return_type)==<span class="keyword">sizeof</span>(reqT), <span class="stringliteral">&quot;async_data_op_req&lt;T&gt; does not have the same size as detail::async_data_op_req_impl&lt;constness&gt;&quot;</span>);
<a name="l02579"></a>02579             <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>std::vector&lt;return_type&gt; &amp;<span class="keyword">&gt;</span>(ops);
<a name="l02580"></a>02580         }
<a name="l02581"></a>02581     };
<a name="l02582"></a>02582 }
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 <span class="preprocessor">#if defined(BOOST_AFIO_ENABLE_BENCHMARKING_COMPLETION) // Only really used for benchmarking</span>
<a name="l02585"></a>02585 <span class="preprocessor"></span><span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt; &amp;callback)
<a name="l02586"></a>02586 {
<a name="l02587"></a>02587     std::vector&lt;async_io_op&gt; r;
<a name="l02588"></a>02588     std::vector&lt;std::pair&lt;async_op_flags, async_file_io_dispatcher_base::completion_t *&gt;&gt; i;
<a name="l02589"></a>02589     r.reserve(1); i.reserve(1);
<a name="l02590"></a>02590     r.push_back(req);
<a name="l02591"></a>02591     i.push_back(callback);
<a name="l02592"></a>02592     <span class="keywordflow">return</span> std::move(completion(r, i).front());
<a name="l02593"></a>02593 }
<a name="l02594"></a>02594 <span class="preprocessor">#endif</span>
<a name="l02595"></a>02595 <span class="preprocessor"></span><span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::completion(<span class="keyword">const</span> async_io_op &amp;req, <span class="keyword">const</span> std::pair&lt;<a class="code" href="group__async__op__flags.html#gaa1e754d20cbcf3979c15a3acdc485194" title="Bitwise async_op_flags flags.">async_op_flags</a>, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt; &amp;callback)
<a name="l02596"></a>02596 {
<a name="l02597"></a>02597     std::vector&lt;async_io_op&gt; r;
<a name="l02598"></a>02598     std::vector&lt;std::pair&lt;async_op_flags, std::function&lt;async_file_io_dispatcher_base::completion_t&gt;&gt;&gt; i;
<a name="l02599"></a>02599     r.reserve(1); i.reserve(1);
<a name="l02600"></a>02600     r.push_back(req);
<a name="l02601"></a>02601     i.push_back(callback);
<a name="l02602"></a>02602     <span class="keywordflow">return</span> std::move(completion(r, i).front());
<a name="l02603"></a>02603 }
<a name="l02604"></a>02604 <span class="keyword">namespace </span>detail {
<a name="l02605"></a>02605     <span class="keyword">template</span>&lt;<span class="keyword">class</span> tasktype&gt; std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt;&gt; doCall(<span class="keywordtype">size_t</span>, async_io_op _, std::shared_ptr&lt;tasktype&gt; c)
<a name="l02606"></a>02606     {
<a name="l02607"></a>02607         (*c)();
<a name="l02608"></a>02608         <span class="keywordflow">return</span> std::make_pair(<span class="keyword">true</span>, _.get(<span class="keyword">true</span>));
<a name="l02609"></a>02609     }
<a name="l02610"></a>02610 }
<a name="l02611"></a>02611 <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> std::vector&lt;async_io_op&gt; &amp;ops, <span class="keyword">const</span> std::vector&lt;std::function&lt;R()&gt;&gt; &amp;callables)
<a name="l02612"></a>02612 {
<a name="l02613"></a>02613     <span class="keyword">typedef</span> <a class="code" href="classenqueued__task_3_01_r_07_08_4.html">enqueued_task&lt;R()&gt;</a> tasktype;
<a name="l02614"></a>02614     std::vector&lt;shared_future&lt;R&gt;&gt; retfutures;
<a name="l02615"></a>02615     std::vector&lt;std::pair&lt;async_op_flags, std::function&lt;completion_t&gt;&gt;&gt; callbacks;
<a name="l02616"></a>02616     retfutures.reserve(callables.size());
<a name="l02617"></a>02617     callbacks.reserve(callables.size());
<a name="l02618"></a>02618     
<a name="l02619"></a>02619     <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;t: callables)
<a name="l02620"></a>02620     {
<a name="l02621"></a>02621         std::shared_ptr&lt;tasktype&gt; c(std::make_shared&lt;tasktype&gt;(std::function&lt;R()&gt;(t)));
<a name="l02622"></a>02622         retfutures.push_back(c-&gt;get_future());
<a name="l02623"></a>02623         callbacks.push_back(std::make_pair(<a class="code" href="afio_8hpp.html#gaa1e754d20cbcf3979c15a3acdc485194ab7e4e0120a041dbe6528b050c04269e0" title="No flags set.">async_op_flags::none</a>, std::bind(&amp;detail::doCall&lt;tasktype&gt;, std::placeholders::_1, std::placeholders::_2, std::move(c))));
<a name="l02624"></a>02624     }
<a name="l02625"></a>02625     <span class="keywordflow">return</span> std::make_pair(std::move(retfutures), completion(ops, callbacks));
<a name="l02626"></a>02626 }
<a name="l02627"></a>02627 <span class="keyword">template</span>&lt;<span class="keyword">class</span> R&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;R&gt;, async_io_op&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> async_io_op &amp;req, std::function&lt;R()&gt; callback)
<a name="l02628"></a>02628 {
<a name="l02629"></a>02629     std::vector&lt;async_io_op&gt; i;
<a name="l02630"></a>02630     std::vector&lt;std::function&lt;R()&gt;&gt; c;
<a name="l02631"></a>02631     i.reserve(1); c.reserve(1);
<a name="l02632"></a>02632     i.push_back(req);
<a name="l02633"></a>02633     c.push_back(std::move(callback));
<a name="l02634"></a>02634     std::pair&lt;std::vector&lt;shared_future&lt;R&gt;&gt;, std::vector&lt;async_io_op&gt;&gt; ret(call(i, c));
<a name="l02635"></a>02635     <span class="keywordflow">return</span> std::make_pair(std::move(ret.first.front()), ret.second.front());
<a name="l02636"></a>02636 }
<a name="l02637"></a>02637 
<a name="l02638"></a>02638 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02639"></a>02639 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> detail::vs2013_variadic_overload_resolution_workaround&lt;C, Args...&gt;::type&gt;, async_io_op&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args)
<a name="l02640"></a>02640 <span class="preprocessor">#else</span>
<a name="l02641"></a>02641 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>C, <span class="keyword">class</span>... Args&gt; <span class="keyword">inline</span> std::pair&lt;shared_future&lt;<span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type&gt;, async_io_op&gt; async_file_io_dispatcher_base::call(<span class="keyword">const</span> async_io_op &amp;req, C callback, Args... args)
<a name="l02642"></a>02642 <span class="preprocessor">#endif</span>
<a name="l02643"></a>02643 <span class="preprocessor"></span>{
<a name="l02644"></a>02644     <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;C(Args...)&gt;::type rettype;
<a name="l02645"></a>02645     <span class="keywordflow">return</span> call(req, std::function&lt;rettype()&gt;(std::bind&lt;rettype&gt;(callback, args...)));
<a name="l02646"></a>02646 }
<a name="l02647"></a>02647 
<a name="l02648"></a>02648 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::adopt(std::shared_ptr&lt;async_io_handle&gt; h)
<a name="l02649"></a>02649 {
<a name="l02650"></a>02650     std::vector&lt;std::shared_ptr&lt;async_io_handle&gt;&gt; i;
<a name="l02651"></a>02651     i.reserve(1);
<a name="l02652"></a>02652     i.push_back(std::move(h));
<a name="l02653"></a>02653     <span class="keywordflow">return</span> std::move(adopt(i).front());
<a name="l02654"></a>02654 }
<a name="l02655"></a>02655 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::dir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02656"></a>02656 {
<a name="l02657"></a>02657     std::vector&lt;async_path_op_req&gt; i;
<a name="l02658"></a>02658     i.reserve(1);
<a name="l02659"></a>02659     i.push_back(req);
<a name="l02660"></a>02660     <span class="keywordflow">return</span> std::move(dir(i).front());
<a name="l02661"></a>02661 }
<a name="l02662"></a>02662 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::rmdir(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02663"></a>02663 {
<a name="l02664"></a>02664     std::vector&lt;async_path_op_req&gt; i;
<a name="l02665"></a>02665     i.reserve(1);
<a name="l02666"></a>02666     i.push_back(req);
<a name="l02667"></a>02667     <span class="keywordflow">return</span> std::move(rmdir(i).front());
<a name="l02668"></a>02668 }
<a name="l02669"></a>02669 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::file(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02670"></a>02670 {
<a name="l02671"></a>02671     std::vector&lt;async_path_op_req&gt; i;
<a name="l02672"></a>02672     i.reserve(1);
<a name="l02673"></a>02673     i.push_back(req);
<a name="l02674"></a>02674     <span class="keywordflow">return</span> std::move(file(i).front());
<a name="l02675"></a>02675 }
<a name="l02676"></a>02676 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::rmfile(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02677"></a>02677 {
<a name="l02678"></a>02678     std::vector&lt;async_path_op_req&gt; i;
<a name="l02679"></a>02679     i.reserve(1);
<a name="l02680"></a>02680     i.push_back(req);
<a name="l02681"></a>02681     <span class="keywordflow">return</span> std::move(rmfile(i).front());
<a name="l02682"></a>02682 }
<a name="l02683"></a>02683 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::symlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02684"></a>02684 {
<a name="l02685"></a>02685     std::vector&lt;async_path_op_req&gt; i;
<a name="l02686"></a>02686     i.reserve(1);
<a name="l02687"></a>02687     i.push_back(req);
<a name="l02688"></a>02688     <span class="keywordflow">return</span> std::move(symlink(i).front());
<a name="l02689"></a>02689 }
<a name="l02690"></a>02690 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::rmsymlink(<span class="keyword">const</span> <a class="code" href="structasync__path__op__req.html" title="A convenience bundle of path and flags, with optional precondition.">async_path_op_req</a> &amp;req)
<a name="l02691"></a>02691 {
<a name="l02692"></a>02692     std::vector&lt;async_path_op_req&gt; i;
<a name="l02693"></a>02693     i.reserve(1);
<a name="l02694"></a>02694     i.push_back(req);
<a name="l02695"></a>02695     <span class="keywordflow">return</span> std::move(rmsymlink(i).front());
<a name="l02696"></a>02696 }
<a name="l02697"></a>02697 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::sync(<span class="keyword">const</span> async_io_op &amp;req)
<a name="l02698"></a>02698 {
<a name="l02699"></a>02699     std::vector&lt;async_io_op&gt; i;
<a name="l02700"></a>02700     i.reserve(1);
<a name="l02701"></a>02701     i.push_back(req);
<a name="l02702"></a>02702     <span class="keywordflow">return</span> std::move(sync(i).front());
<a name="l02703"></a>02703 }
<a name="l02704"></a>02704 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::close(<span class="keyword">const</span> async_io_op &amp;req)
<a name="l02705"></a>02705 {
<a name="l02706"></a>02706     std::vector&lt;async_io_op&gt; i;
<a name="l02707"></a>02707     i.reserve(1);
<a name="l02708"></a>02708     i.push_back(req);
<a name="l02709"></a>02709     <span class="keywordflow">return</span> std::move(close(i).front());
<a name="l02710"></a>02710 }
<a name="l02711"></a>02711 <span class="preprocessor">#ifndef DOXYGEN_SHOULD_SKIP_THIS</span>
<a name="l02712"></a>02712 <span class="preprocessor"></span><span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::read(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;false&gt; &amp;req)
<a name="l02713"></a>02713 {
<a name="l02714"></a>02714     std::vector&lt;detail::async_data_op_req_impl&lt;false&gt;&gt; i;
<a name="l02715"></a>02715     i.reserve(1);
<a name="l02716"></a>02716     i.push_back(req);
<a name="l02717"></a>02717     <span class="keywordflow">return</span> std::move(read(i).front());
<a name="l02718"></a>02718 }
<a name="l02719"></a>02719 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::write(<span class="keyword">const</span> detail::async_data_op_req_impl&lt;true&gt; &amp;req)
<a name="l02720"></a>02720 {
<a name="l02721"></a>02721     std::vector&lt;detail::async_data_op_req_impl&lt;true&gt;&gt; i;
<a name="l02722"></a>02722     i.reserve(1);
<a name="l02723"></a>02723     i.push_back(req);
<a name="l02724"></a>02724     <span class="keywordflow">return</span> std::move(write(i).front());
<a name="l02725"></a>02725 }
<a name="l02726"></a>02726 <span class="preprocessor">#endif</span>
<a name="l02727"></a>02727 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> std::vector&lt;async_io_op&gt; async_file_io_dispatcher_base::read(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops)
<a name="l02728"></a>02728 {
<a name="l02729"></a>02729     <span class="keywordflow">return</span> read(detail::async_file_io_dispatcher_rwconverter&lt;false, T&gt;()(ops));
<a name="l02730"></a>02730 }
<a name="l02731"></a>02731 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> std::vector&lt;async_io_op&gt; async_file_io_dispatcher_base::write(<span class="keyword">const</span> std::vector&lt;async_data_op_req&lt;T&gt;&gt; &amp;ops)
<a name="l02732"></a>02732 {
<a name="l02733"></a>02733     <span class="keywordflow">return</span> write(detail::async_file_io_dispatcher_rwconverter&lt;true, T&gt;()(ops));
<a name="l02734"></a>02734 }
<a name="l02735"></a>02735 <span class="keyword">inline</span> async_io_op async_file_io_dispatcher_base::truncate(<span class="keyword">const</span> async_io_op &amp;op, off_t newsize)
<a name="l02736"></a>02736 {
<a name="l02737"></a>02737     std::vector&lt;async_io_op&gt; o;
<a name="l02738"></a>02738     std::vector&lt;off_t&gt; i;
<a name="l02739"></a>02739     o.reserve(1);
<a name="l02740"></a>02740     o.push_back(op);
<a name="l02741"></a>02741     i.reserve(1);
<a name="l02742"></a>02742     i.push_back(newsize);
<a name="l02743"></a>02743     <span class="keywordflow">return</span> std::move(truncate(o, i).front());
<a name="l02744"></a>02744 }
<a name="l02745"></a>02745 <span class="keyword">inline</span> std::pair&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, <span class="keywordtype">bool</span>&gt;&gt;, async_io_op&gt; async_file_io_dispatcher_base::enumerate(<span class="keyword">const</span> <a class="code" href="structasync__enumerate__op__req.html" title="A convenience bundle of precondition, number of items to enumerate, item pattern match and metadata t...">async_enumerate_op_req</a> &amp;req)
<a name="l02746"></a>02746 {
<a name="l02747"></a>02747     std::vector&lt;async_enumerate_op_req&gt; i;
<a name="l02748"></a>02748     i.reserve(1);
<a name="l02749"></a>02749     i.push_back(req);
<a name="l02750"></a>02750     <span class="keyword">auto</span> ret=enumerate(i);
<a name="l02751"></a>02751     <span class="keywordflow">return</span> std::make_pair(std::move(ret.first.front()), std::move(ret.second.front()));
<a name="l02752"></a>02752 }
<a name="l02753"></a>02753 
<a name="l02754"></a>02754 
<a name="l02755"></a>02755 BOOST_AFIO_V1_NAMESPACE_END
<a name="l02756"></a>02756 
<a name="l02757"></a>02757 <span class="comment">// Specialise std::hash&lt;&gt; for directory_entry</span>
<a name="l02758"></a>02758 <span class="preprocessor">#ifndef BOOST_AFIO_DISABLE_STD_HASH_SPECIALIZATION</span>
<a name="l02759"></a>02759 <span class="preprocessor"></span><span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l02760"></a>02760 <span class="keyword">namespace </span>std
<a name="l02761"></a>02761 {
<a name="l02762"></a>02762     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>hash&lt;BOOST_AFIO_V1_NAMESPACE::<a class="code" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a>&gt;
<a name="l02763"></a>02763     {
<a name="l02764"></a>02764     <span class="keyword">public</span>:
<a name="l02765"></a>02765         <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> BOOST_AFIO_V1_NAMESPACE::directory_entry &amp;p)<span class="keyword"> const</span>
<a name="l02766"></a>02766 <span class="keyword">        </span>{
<a name="l02767"></a>02767             <span class="keywordflow">return</span> BOOST_AFIO_V1_NAMESPACE::directory_entry_hash()(p);
<a name="l02768"></a>02768         }
<a name="l02769"></a>02769     };
<a name="l02770"></a>02770 
<a name="l02771"></a>02771 }<span class="comment">//namesapce std</span>
<a name="l02772"></a>02772 <span class="preprocessor">#endif</span>
<a name="l02773"></a>02773 <span class="preprocessor"></span>
<a name="l02774"></a>02774 <span class="preprocessor">#ifdef BOOST_MSVC</span>
<a name="l02775"></a>02775 <span class="preprocessor"></span><span class="preprocessor">#pragma warning(pop)</span>
<a name="l02776"></a>02776 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02777"></a>02777 <span class="preprocessor"></span>
<a name="l02778"></a>02778 <span class="preprocessor">#if BOOST_AFIO_HEADERS_ONLY == 1 &amp;&amp; !defined(DOXYGEN_SHOULD_SKIP_THIS)</span>
<a name="l02779"></a>02779 <span class="preprocessor"></span><span class="preprocessor">#undef BOOST_AFIO_VALIDATE_INPUTS // Let BOOST_AFIO_NEVER_VALIDATE_INPUTS take over</span>
<a name="l02780"></a>02780 <span class="preprocessor"></span><span class="preprocessor">#include &quot;detail/impl/afio.ipp&quot;</span>
<a name="l02781"></a>02781 <span class="preprocessor">#endif</span>
<a name="l02782"></a>02782 <span class="preprocessor"></span>
<a name="l02783"></a>02783 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
