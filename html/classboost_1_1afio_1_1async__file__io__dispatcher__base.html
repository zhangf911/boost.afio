<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>boost</b>      </li>
      <li class="navelem"><b>afio</b>      </li>
      <li class="navelem"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html">async_file_io_dispatcher_base</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">boost::afio::async_file_io_dispatcher_base Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="boost::afio::async_file_io_dispatcher_base" -->
<p>Abstract base class for dispatching file i/o asynchronously.  
 <a href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#details">More...</a></p>

<p><a href="classboost_1_1afio_1_1async__file__io__dispatcher__base-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filter.html#ga10eca40ababf6e5fa3b3a88ce73f81b6">filter_t</a> (<a class="el" href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">detail::OpType</a>, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an op filter callback handler.  <a href="group__async__file__io__dispatcher__base____filter.html#ga10eca40ababf6e5fa3b3a88ce73f81b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filter.html#ga303b84424610f3834b70b0778ae1f0b3">filter_readwrite_t</a> (<a class="el" href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">detail::OpType</a>, <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> *, const detail::async_data_op_req_impl&lt; true &gt; &amp;, off_t, size_t, size_t, const asio::error_code &amp;, size_t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a readwrite filter callback handler.  <a href="group__async__file__io__dispatcher__base____filter.html#ga303b84424610f3834b70b0778ae1f0b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; bool, <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type returned by a completion handler.  <a href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga54bf743efd9a69d7dd11d01ce25fe304">completion_t</a> (size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a completion handler.  <a href="group__async__file__io__dispatcher__base____completion.html#ga54bf743efd9a69d7dd11d01ce25fe304"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#afdaf5abc2bc92330dc7c85295dfbcaed">~async_file_io_dispatcher_base</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the dispatcher, blocking inefficiently if any ops are still in flight.  <a href="#afdaf5abc2bc92330dc7c85295dfbcaed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1thread__source.html">thread_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ae49a5daedd876d48fc131bca5f0d2b93">threadsource</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread source used by this dispatcher.  <a href="#ae49a5daedd876d48fc131bca5f0d2b93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">file_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ad0eda011c34511f0d25de9902e16b2b7">fileflags</a> (<a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">file_flags</a> flags) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns file flags as would be used after forcing and masking bits passed during construction.  <a href="#ad0eda011c34511f0d25de9902e16b2b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#a360e6404ee3f0949209836b8184ee007">wait_queue_depth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current wait queue depth of this dispatcher.  <a href="#a360e6404ee3f0949209836b8184ee007"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#aabd3bce4b20a99a5c25668a7b229ae6f">fd_count</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of open items in this dispatcher.  <a href="#aabd3bce4b20a99a5c25668a7b229ae6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ac0a315fe8eb87c7827567ef8e916a413">op_from_scheduled_id</a> (size_t id) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an op ref for a given <b>currently</b> scheduled op id, throwing an exception if id not scheduled at the point of call. Can be used to retrieve exception state from some op id, or one's own shared future.  <a href="#ac0a315fe8eb87c7827567ef8e916a413"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filter.html#gacc15e280c64ab2f734b097069ed86240">post_op_filter_clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the post op and readwrite filters. Not threadsafe.  <a href="group__async__file__io__dispatcher__base____filter.html#gacc15e280c64ab2f734b097069ed86240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filter.html#ga9e25e1fbc055efe53bd63f6d700866f7">post_op_filter</a> (std::vector&lt; std::pair&lt; <a class="el" href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">detail::OpType</a>, std::function&lt; <a class="el" href="group__async__file__io__dispatcher__base____filter.html#ga10eca40ababf6e5fa3b3a88ce73f81b6">async_file_io_dispatcher_base::filter_t</a> &gt;&gt;&gt; filters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install op filters for non-buffer taking ops. Not threadsafe.  <a href="group__async__file__io__dispatcher__base____filter.html#ga9e25e1fbc055efe53bd63f6d700866f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filter.html#ga820758ad7b27f3fa3ca9fa4445db50ee">post_readwrite_filter</a> (std::vector&lt; std::pair&lt; <a class="el" href="namespaceboost_1_1afio_1_1detail.html#a0988089f34c099ad2ef946d6ff03c959">detail::OpType</a>, std::function&lt; <a class="el" href="group__async__file__io__dispatcher__base____filter.html#ga303b84424610f3834b70b0778ae1f0b3">async_file_io_dispatcher_base::filter_readwrite_t</a> &gt;&gt;&gt; filters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install read/write op filters, useful for tight ASIO integration. Not threadsafe.  <a href="group__async__file__io__dispatcher__base____filter.html#ga820758ad7b27f3fa3ca9fa4445db50ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga6cb87e3ca62468c8027a0cf052a9ff24">completion</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops, const std::vector&lt; std::pair&lt; <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a>, std::function&lt; <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga54bf743efd9a69d7dd11d01ce25fe304">async_file_io_dispatcher_base::completion_t</a> &gt;&gt;&gt; &amp;callbacks)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous invocations of the specified functions when their supplied operations complete.  <a href="group__async__file__io__dispatcher__base____completion.html#ga6cb87e3ca62468c8027a0cf052a9ff24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____completion.html#gac745f6f5424e142086cf45cc583f5aac">completion</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;req, const std::pair&lt; <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a>, std::function&lt; <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga54bf743efd9a69d7dd11d01ce25fe304">async_file_io_dispatcher_base::completion_t</a> &gt;&gt; &amp;callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the asynchronous invocation of the specified single function when the supplied single operation completes.  <a href="group__async__file__io__dispatcher__base____completion.html#gac745f6f5424e142086cf45cc583f5aac"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; shared_future&lt; R &gt;<br class="typebreak"/>
 &gt;, std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____call.html#gaa144378bedc4272b44c9b8f358a04fb7">call</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops, const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;callables)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete.  <a href="group__async__file__io__dispatcher__base____call.html#gaa144378bedc4272b44c9b8f358a04fb7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; shared_future&lt; R &gt;<br class="typebreak"/>
 &gt;, std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____call.html#ga9ccdb35979566b5852e1817388f6a39b">call</a> (const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;callables)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete.  <a href="group__async__file__io__dispatcher__base____call.html#ga9ccdb35979566b5852e1817388f6a39b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; shared_future&lt; R &gt;<br class="typebreak"/>
, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ab10c6c273f3e7825fea188cd6c2788b8">call</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;req, std::function&lt; R()&gt; callback)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous invocation of the specified bound function when its supplied precondition completes.  <a href="#ab10c6c273f3e7825fea188cd6c2788b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; shared_future<br class="typebreak"/>
&lt; typename std::result_of&lt; C(Args...)&gt;<br class="typebreak"/>
::type &gt;, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____call.html#gaf3bde0b207a33ac44e61a09ca93be50f">call</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;req, C callback, Args...args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous invocation of the specified unbound callable when its supplied precondition completes. Note that this function essentially calls `std::bind()` on the callable and the args and passes it to the other <a class="el" href="group__async__file__io__dispatcher__base____call.html#gaa144378bedc4272b44c9b8f358a04fb7" title="Schedule a batch of asynchronous invocations of the specified bound functions when their supplied pre...">call()</a> overload taking a `std::function&lt;&gt;`. You should therefore use `std::ref()` etc. as appropriate.  <a href="group__async__file__io__dispatcher__base____call.html#gaf3bde0b207a33ac44e61a09ca93be50f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga284b1612b2c0a3ea813660bc9fd6a54b">adopt</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt;&gt; &amp;hs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of third party handle adoptions.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga284b1612b2c0a3ea813660bc9fd6a54b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gaa3f199f010ded1399b4f903a194b9cd3">adopt</a> (std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt; h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an adoption of a third party handle.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gaa3f199f010ded1399b4f903a194b9cd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gaf6386ba1f9bd0e829470837bef6c7d73">dir</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous directory creations and opens after optional preconditions.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gaf6386ba1f9bd0e829470837bef6c7d73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gacceb89d11308e3137186aaccec282a17">dir</a> (const <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous directory creation and open after an optional precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gacceb89d11308e3137186aaccec282a17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga41e799782c22f41b16d408a977460153">rmdir</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous directory deletions after optional preconditions.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga41e799782c22f41b16d408a977460153"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gadb64fc6cabd8e1f394b112cf2361a20a">rmdir</a> (const <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous directory deletion after an optional precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gadb64fc6cabd8e1f394b112cf2361a20a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga5da57c9cb811cea214a1e36f007ecffb">file</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous file creations and opens after optional preconditions.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga5da57c9cb811cea214a1e36f007ecffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga59910bc569f75eac27c406c47ccd0643">file</a> (const <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous file creation and open after an optional precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga59910bc569f75eac27c406c47ccd0643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga1e2c1e20ed7a8d04c3dc63490f8e2580">rmfile</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous file deletions after optional preconditions.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga1e2c1e20ed7a8d04c3dc63490f8e2580"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gaa222f0e9e966ddddf823166105589316">rmfile</a> (const <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous file deletion after an optional precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gaa222f0e9e966ddddf823166105589316"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga831d3e585fab96f70b71b1b1a41bd858">symlink</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous symlink creations and opens after a precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga831d3e585fab96f70b71b1b1a41bd858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gac56fe0c4aa9d3ead576ff210b3bb3b92">symlink</a> (const <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous symlink creation and open after a precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gac56fe0c4aa9d3ead576ff210b3bb3b92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga5f83cde9b9428423ab6cfbefbe0865b9">rmsymlink</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous symlink deletions after optional preconditions.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga5f83cde9b9428423ab6cfbefbe0865b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga3d4a61ff8c31bade2d3a5f3aa7e1cb60">rmsymlink</a> (const <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous symlink deletion after an optional precondition.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga3d4a61ff8c31bade2d3a5f3aa7e1cb60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gab2bbf924a104039e4fb5b9a31f14e81e">sync</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gab2bbf924a104039e4fb5b9a31f14e81e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga7cb40ff0cb3eee7096f0a126bc509db8">sync</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous content synchronisation with physical storage after a preceding operation.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga7cb40ff0cb3eee7096f0a126bc509db8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f">zero</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops, const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;ranges)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations.  <a href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga4addd95d8cb11a94efc4712147b128fa">zero</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;req, const std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; &amp;ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous zero and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="group__async__file__io__dispatcher__base____extents.html#ga4addd95d8cb11a94efc4712147b128fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga56db87e1d05cf4c17c7587216b2413c9">close</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous file or directory handle closes after preceding operations.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga56db87e1d05cf4c17c7587216b2413c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga269273113b9ec5eea764791852cbd53a">close</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous file or directory handle close after a preceding operation.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga269273113b9ec5eea764791852cbd53a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga389a54f126d95872fa3981bbb0f4ca49">read</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html">async_data_op_req</a>&lt; T &gt;&gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga389a54f126d95872fa3981bbb0f4ca49"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga2f99a4c769b6d769e829cee1679763c1">read</a> (const <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html">async_data_op_req</a>&lt; T &gt; &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga2f99a4c769b6d769e829cee1679763c1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga2489d452720accc47d1bfeb5525cfd5b">write</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html">async_data_op_req</a>&lt; const T &gt;&gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size.  <a href="group__async__file__io__dispatcher__base____filedirops.html#ga2489d452720accc47d1bfeb5525cfd5b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gaccfb68e7fb84c36f418215e4d792988f">write</a> (const <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html">async_data_op_req</a>&lt; const T &gt; &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gaccfb68e7fb84c36f418215e4d792988f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gae3f243608a9f97af2461ead5bb8189af">truncate</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops, const std::vector&lt; off_t &gt; &amp;sizes)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous file length truncations after preceding operations.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gae3f243608a9f97af2461ead5bb8189af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#gaa6d63c51183b6f637a723b00155e1cac">truncate</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;op, off_t newsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous file length truncation after a preceding operation.  <a href="group__async__file__io__dispatcher__base____filedirops.html#gaa6d63c51183b6f637a723b00155e1cac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::vector<br class="typebreak"/>
&lt; future&lt; std::pair<br class="typebreak"/>
&lt; std::vector&lt; <a class="el" href="classboost_1_1afio_1_1directory__entry.html">directory_entry</a> &gt;<br class="typebreak"/>
, bool &gt; &gt; &gt;, std::vector<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____enumerate.html#ga9463c9d43626c23e5ef4c7c840d36fcd">enumerate</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__enumerate__op__req.html">async_enumerate_op_req</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous directory enumerations after preceding operations.  <a href="group__async__file__io__dispatcher__base____enumerate.html#ga9463c9d43626c23e5ef4c7c840d36fcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; future&lt; std::pair<br class="typebreak"/>
&lt; std::vector&lt; <a class="el" href="classboost_1_1afio_1_1directory__entry.html">directory_entry</a> &gt;<br class="typebreak"/>
, bool &gt; &gt;, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____enumerate.html#ga0695e33450ba820ebcb378f8b33d9ac1">enumerate</a> (const <a class="el" href="structboost_1_1afio_1_1async__enumerate__op__req.html">async_enumerate_op_req</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous directory enumeration after a preceding operation.  <a href="group__async__file__io__dispatcher__base____enumerate.html#ga0695e33450ba820ebcb378f8b33d9ac1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::vector<br class="typebreak"/>
&lt; future&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; off_t, off_t &gt;<br class="typebreak"/>
 &gt; &gt; &gt;, std::vector<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga7897bcac1891a7ffee77cf3c1eb870e0">extents</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous extent enumerations after preceding operations.  <a href="group__async__file__io__dispatcher__base____extents.html#ga7897bcac1891a7ffee77cf3c1eb870e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; future&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; off_t, off_t &gt;<br class="typebreak"/>
 &gt; &gt;, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga6fab7605a3e8e0bd5be61cb41eb514e4">extents</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous extent enumeration after a preceding operation.  <a href="group__async__file__io__dispatcher__base____extents.html#ga6fab7605a3e8e0bd5be61cb41eb514e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::vector<br class="typebreak"/>
&lt; future&lt; <a class="el" href="structboost_1_1afio_1_1statfs__t.html">statfs_t</a> &gt;<br class="typebreak"/>
 &gt;, std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____statfs.html#gacbeafa55623e83a890db62e190fc6c04">statfs</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops, const std::vector&lt; <a class="el" href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">fs_metadata_flags</a> &gt; &amp;reqs)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous volume enumerations after preceding operations.  <a href="group__async__file__io__dispatcher__base____statfs.html#gacbeafa55623e83a890db62e190fc6c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; future&lt; <a class="el" href="structboost_1_1afio_1_1statfs__t.html">statfs_t</a> &gt;<br class="typebreak"/>
, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____statfs.html#gacde9af80f4041fee04f759ad70e615d1">statfs</a> (const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;op, const <a class="el" href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">fs_metadata_flags</a> &amp;req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous volume enumeration after a preceding operation.  <a href="group__async__file__io__dispatcher__base____statfs.html#gacde9af80f4041fee04f759ad70e615d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____barrier.html#gacc278eff00d3740305863354cca4660b">barrier</a> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;ops)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous synchronisation of preceding operations.  <a href="group__async__file__io__dispatcher__base____barrier.html#gacc278eff00d3740305863354cca4660b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____misc.html#ga006bef030dab5c7bc67fbdc5bc352cef">complete_async_op</a> (size_t id, std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt; h, exception_ptr e=exception_ptr())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an operation with a handle or an error, usually used when an operation was previously deferred.  <a href="group__async__file__io__dispatcher__base____misc.html#ga006bef030dab5c7bc67fbdc5bc352cef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____misc.html#ga39bb6e878d9ad0b4b926e31ced073177">complete_async_op</a> (size_t id, exception_ptr e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes an operation with an error, usually used when an operation was previously deferred.  <a href="group__async__file__io__dispatcher__base____misc.html#ga39bb6e878d9ad0b4b926e31ced073177"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a735e7a659db8e76f0bfb77123c38f23b"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::write" ref="a735e7a659db8e76f0bfb77123c38f23b" args="(const std::vector&lt; async_data_op_req&lt; T &gt;&gt; &amp;ops)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>write</b> (const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__data__op__req.html">async_data_op_req</a>&lt; T &gt;&gt; &amp;ops)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____misc.html#ga0dbf229a0b5733133f74aabf22d47609">page_size</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page size of this architecture which is useful for calculating direct i/o multiples.  <a href="group__async__file__io__dispatcher__base____misc.html#ga0dbf229a0b5733133f74aabf22d47609"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547e953737c7270c6616976383221f91"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::async_file_io_dispatcher_base" ref="a547e953737c7270c6616976383221f91" args="(std::shared_ptr&lt; thread_source &gt; threadpool, file_flags flagsforce, file_flags flagsmask)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>async_file_io_dispatcher_base</b> (std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1thread__source.html">thread_source</a> &gt; threadpool, <a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">file_flags</a> flagsforce, <a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">file_flags</a> flagsmask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fc400c45bc79eb50db8b74e5d310368"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::doadopt" ref="a9fc400c45bc79eb50db8b74e5d310368" args="(size_t, async_io_op, std::shared_ptr&lt; async_io_handle &gt; h)" -->
std::pair&lt; bool, <br class="typebreak"/>
std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>doadopt</b> (size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt; h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e93a8a2ee8ce47e38f2b62ce7b7767f"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::invoke_user_completion_fast" ref="a0e93a8a2ee8ce47e38f2b62ce7b7767f" args="(size_t id, async_io_op h, completion_t *callback)" -->
<a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invoke_user_completion_fast</b> (size_t id, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> h, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga54bf743efd9a69d7dd11d01ce25fe304">completion_t</a> *callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb3120d27c9c3b469d30223f7ad63567"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::invoke_user_completion_slow" ref="adb3120d27c9c3b469d30223f7ad63567" args="(size_t id, async_io_op h, std::function&lt; completion_t &gt; callback)" -->
<a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invoke_user_completion_slow</b> (size_t id, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> h, std::function&lt; <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga54bf743efd9a69d7dd11d01ce25fe304">completion_t</a> &gt; callback)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abb9709f262eac032e28894ad0816ee66"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="abb9709f262eac032e28894ad0816ee66" args="(int optype, const std::vector&lt; async_io_op &gt; &amp;preconditions, const std::vector&lt; T &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, T))" -->
template&lt;class F , class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;preconditions, const std::vector&lt; T &gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, T))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acdd8dac6f24e9669392a48d9076dbea7"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="acdd8dac6f24e9669392a48d9076dbea7" args="(int optype, const std::vector&lt; T &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, T))" -->
template&lt;class F , class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; T &gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, T))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a40280aef4a028fe6e3407e582277ece4"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="a40280aef4a028fe6e3407e582277ece4" args="(int optype, const std::vector&lt; async_io_op &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_io_op))" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa77f30d0bbf428a4ac00bd5970b2656f"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="aa77f30d0bbf428a4ac00bd5970b2656f" args="(int optype, const std::vector&lt; async_path_op_req &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_path_op_req))" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a> &gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, <a class="el" href="structboost_1_1afio_1_1async__path__op__req.html">async_path_op_req</a>))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af17a821515f54bdac6b6f792c751d01f"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="af17a821515f54bdac6b6f792c751d01f" args="(int optype, const std::vector&lt; detail::async_data_op_req_impl&lt; iswrite &gt;&gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, detail::async_data_op_req_impl&lt; iswrite &gt;))" -->
template&lt;class F , bool iswrite&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; detail::async_data_op_req_impl&lt; iswrite &gt;&gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, detail::async_data_op_req_impl&lt; iswrite &gt;))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a06bed7cee8e7ec9ecfb1c6cfad57151c"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="a06bed7cee8e7ec9ecfb1c6cfad57151c" args="(int optype, const std::vector&lt; async_enumerate_op_req &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_enumerate_op_req, std::shared_ptr&lt; promise&lt; std::pair&lt; std::vector&lt; directory_entry &gt;, bool &gt;&gt;&gt;))" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; future<br class="typebreak"/>
&lt; std::pair&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1afio_1_1directory__entry.html">directory_entry</a> &gt;, bool &gt;<br class="typebreak"/>
 &gt; &gt;, std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__enumerate__op__req.html">async_enumerate_op_req</a> &gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, <a class="el" href="structboost_1_1afio_1_1async__enumerate__op__req.html">async_enumerate_op_req</a>, std::shared_ptr&lt; promise&lt; std::pair&lt; std::vector&lt; <a class="el" href="classboost_1_1afio_1_1directory__entry.html">directory_entry</a> &gt;, bool &gt;&gt;&gt;))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e1831ca95cea942db1b103df98a4c0b"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="a8e1831ca95cea942db1b103df98a4c0b" args="(int optype, const std::vector&lt; async_io_op &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, std::shared_ptr&lt; promise&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt;&gt; ret))" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; future<br class="typebreak"/>
&lt; std::vector&lt; std::pair<br class="typebreak"/>
&lt; off_t, off_t &gt;<br class="typebreak"/>
 &gt; &gt; &gt;, std::vector<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;container, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, std::shared_ptr&lt; promise&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt;&gt; ret))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6507c066dec0a35f324d4ac39f46d5d1"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_ops" ref="a6507c066dec0a35f324d4ac39f46d5d1" args="(int optype, const std::vector&lt; async_io_op &gt; &amp;container, const std::vector&lt; fs_metadata_flags &gt; &amp;req, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, fs_metadata_flags, std::shared_ptr&lt; promise&lt; statfs_t &gt;&gt; ret))" -->
template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; future<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1afio_1_1statfs__t.html">statfs_t</a> &gt; &gt;, std::vector<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_ops</b> (int optype, const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;container, const std::vector&lt; <a class="el" href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">fs_metadata_flags</a> &gt; &amp;req, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, <a class="el" href="group__fs__metadata__flags.html#gadc548bc518f40378c9c9c97f4a994438">fs_metadata_flags</a>, std::shared_ptr&lt; promise&lt; <a class="el" href="structboost_1_1afio_1_1statfs__t.html">statfs_t</a> &gt;&gt; ret))</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a95c2ee11e4c7dc653543eea219c41b3b"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::dobarrier" ref="a95c2ee11e4c7dc653543eea219c41b3b" args="(size_t id, async_io_op h, T)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">async_file_io_dispatcher_base::completion_returntype</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dobarrier</b> (size_t id, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> h, T)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e25bd9ab26e1a945d14c984a6192e29"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::invoke_async_op_completions" ref="a0e25bd9ab26e1a945d14c984a6192e29" args="(size_t id, async_io_op h, completion_returntype(F::*f)(size_t, async_io_op, Args...), Args...args)" -->
template&lt;class F , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classboost_1_1afio_1_1async__io__handle.html">async_io_handle</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke_async_op_completions</b> (size_t id, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> h, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, Args...), Args...args)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f3f249fa5da4f26b5dc19d7fe8de69b"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::chain_async_op" ref="a1f3f249fa5da4f26b5dc19d7fe8de69b" args="(detail::immediate_async_ops &amp;immediates, int optype, const async_io_op &amp;precondition, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, Args...), Args...args)" -->
template&lt;class F , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chain_async_op</b> (detail::immediate_async_ops &amp;immediates, int optype, const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;precondition, <a class="el" href="group__async__op__flags.html#ga3d03d4b42e2ae303e282d0a1dec22976">async_op_flags</a> flags, <a class="el" href="group__async__file__io__dispatcher__base____completion.html#ga384aa77fea0f91d58814c50feeee44dc">completion_returntype</a>(F::*f)(size_t, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a>, Args...), Args...args)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a196118fdfdc083334123c10fbebd60c3"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::detail::async_io_handle_posix" ref="a196118fdfdc083334123c10fbebd60c3" args="" -->
struct&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_io_handle_posix</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f789025521b0e1f43e78056a480daf6"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::detail::async_io_handle_windows" ref="a4f789025521b0e1f43e78056a480daf6" args="" -->
struct&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_io_handle_windows</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f496ba01c9b613e83758582f2b06c9"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::detail::async_file_io_dispatcher_compat" ref="a56f496ba01c9b613e83758582f2b06c9" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_compat</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb74be36e15618561c7df1fbdacea5c"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::detail::async_file_io_dispatcher_windows" ref="a7eb74be36e15618561c7df1fbdacea5c" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_windows</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e10cc6179894e1e8bab39ccba6c476"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::detail::async_file_io_dispatcher_linux" ref="a06e10cc6179894e1e8bab39ccba6c476" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_linux</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb6d073a418fd80cc2b81450cc82687"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::detail::async_file_io_dispatcher_qnx" ref="a4fb6d073a418fd80cc2b81450cc82687" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_qnx</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Abstract base class for dispatching file i/o asynchronously. </p>
<p>This is a reference counted instance with platform-specific implementation optionally hidden in object code. Construct an instance using the `boost<a class="el" href="group__async__file__io__dispatcher.html#ga412e5ba3eaf5c1df0499dad2ddd79fb8" title="Instatiates the best available async_file_io_dispatcher implementation for this system.">afio::make_async_file_io_dispatcher()</a>` function.</p>
 
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l01022">1022</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afdaf5abc2bc92330dc7c85295dfbcaed"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::~async_file_io_dispatcher_base" ref="afdaf5abc2bc92330dc7c85295dfbcaed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#afdaf5abc2bc92330dc7c85295dfbcaed">boost::afio::async_file_io_dispatcher_base::~async_file_io_dispatcher_base</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys the dispatcher, blocking inefficiently if any ops are still in flight. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae49a5daedd876d48fc131bca5f0d2b93"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::threadsource" ref="ae49a5daedd876d48fc131bca5f0d2b93" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classboost_1_1afio_1_1thread__source.html">thread_source</a>&gt; <a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ae49a5daedd876d48fc131bca5f0d2b93">boost::afio::async_file_io_dispatcher_base::threadsource</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the thread source used by this dispatcher. </p>

</div>
</div>
<a class="anchor" id="ad0eda011c34511f0d25de9902e16b2b7"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::fileflags" ref="ad0eda011c34511f0d25de9902e16b2b7" args="(file_flags flags) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">file_flags</a> <a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ad0eda011c34511f0d25de9902e16b2b7">boost::afio::async_file_io_dispatcher_base::fileflags</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__file__flags.html#ga1615042683add1802cfc6dc86bd078ee">file_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns file flags as would be used after forcing and masking bits passed during construction. </p>

</div>
</div>
<a class="anchor" id="a360e6404ee3f0949209836b8184ee007"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::wait_queue_depth" ref="a360e6404ee3f0949209836b8184ee007" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#a360e6404ee3f0949209836b8184ee007">boost::afio::async_file_io_dispatcher_base::wait_queue_depth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current wait queue depth of this dispatcher. </p>

</div>
</div>
<a class="anchor" id="aabd3bce4b20a99a5c25668a7b229ae6f"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::fd_count" ref="aabd3bce4b20a99a5c25668a7b229ae6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#aabd3bce4b20a99a5c25668a7b229ae6f">boost::afio::async_file_io_dispatcher_base::fd_count</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of open items in this dispatcher. </p>

</div>
</div>
<a class="anchor" id="ac0a315fe8eb87c7827567ef8e916a413"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::op_from_scheduled_id" ref="ac0a315fe8eb87c7827567ef8e916a413" args="(size_t id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> <a class="el" href="classboost_1_1afio_1_1async__file__io__dispatcher__base.html#ac0a315fe8eb87c7827567ef8e916a413">boost::afio::async_file_io_dispatcher_base::op_from_scheduled_id</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an op ref for a given <b>currently</b> scheduled op id, throwing an exception if id not scheduled at the point of call. Can be used to retrieve exception state from some op id, or one's own shared future. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structboost_1_1afio_1_1async__io__op.html" title="A reference to an asynchronous operation.">async_io_op</a> with the same shared future as all op refs with this id. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique integer id for the op. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab10c6c273f3e7825fea188cd6c2788b8"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::call" ref="ab10c6c273f3e7825fea188cd6c2788b8" args="(const async_io_op &amp;req, std::function&lt; R()&gt; callback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; shared_future&lt; R &gt;, <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; <a class="el" href="group__async__file__io__dispatcher__base____call.html#gaa144378bedc4272b44c9b8f358a04fb7">boost::afio::async_file_io_dispatcher_base::call</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule an asynchronous invocation of the specified bound function when its supplied precondition completes. </p>
<p>This is effectively a convenience wrapper for `completion()`. It creates an <a class="el" href="classenqueued__task.html" title="Effectively our own custom std::packaged_task&lt;&gt;, with copy semantics and letting us early set value t...">enqueued_task</a> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit. If you are seeing performance issues, using `completion()` directly will have much less overhead.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair with a future returning the result of the callable and an op handle. </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">class R</td><td>A compiler deduced return type of the bound functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>A precondition op handle. If default constructed, the precondition is null. </td></tr>
    <tr><td class="paramname">callback</td><td>A bound functions to call, returning R.</td></tr>
  </table>
  </dd>
</dl>
    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l02858">2858</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
