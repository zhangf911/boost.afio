<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">directory_entry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="directory_entry" -->
<p>The abstract base class for an entry in a directory with lazily filled metadata.  
 <a href="classdirectory__entry.html#details">More...</a></p>

<p><a href="classdirectory__entry-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958">directory_entry</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ac8325aeead5009b12ea664e073729958"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a9f9450830547a63eb719ca01b37c4325">directory_entry</a> (filesystem::path _leafname, <a class="el" href="structstat__t.html">stat_t</a> __stat, <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> _have_metadata)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a9f9450830547a63eb719ca01b37c4325"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a141b726eca554e91ec68b91d94320651"></a><!-- doxytag: member="directory_entry::directory_entry" ref="a141b726eca554e91ec68b91d94320651" args="(const directory_entry &amp;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>directory_entry</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5fc5c1e1b06cc8a72abef8ef52eec0c"></a><!-- doxytag: member="directory_entry::operator=" ref="af5fc5c1e1b06cc8a72abef8ef52eec0c" args="(const directory_entry &amp;)" -->
<a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd22e8c4837c9512ab44d80f8652dbb"></a><!-- doxytag: member="directory_entry::directory_entry" ref="abfd22e8c4837c9512ab44d80f8652dbb" args="(directory_entry &amp;&amp;o)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>directory_entry</b> (<a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;&amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add73e27a193651f48af01bd57356828c"></a><!-- doxytag: member="directory_entry::operator=" ref="add73e27a193651f48af01bd57356828c" args="(directory_entry &amp;&amp;o)" -->
<a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;&amp;o)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad31e3d7ab859eccfcea75345309c871"></a><!-- doxytag: member="directory_entry::operator==" ref="aad31e3d7ab859eccfcea75345309c871" args="(const directory_entry &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a331ce011347d49c805259f3497a7e1d8"></a><!-- doxytag: member="directory_entry::operator!=" ref="a331ce011347d49c805259f3497a7e1d8" args="(const directory_entry &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae4c4466021a722f6638f476b7877ba"></a><!-- doxytag: member="directory_entry::operator&lt;" ref="a2ae4c4466021a722f6638f476b7877ba" args="(const directory_entry &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a810e4ae68666806c1f13c6b2c921efcb"></a><!-- doxytag: member="directory_entry::operator&lt;=" ref="a810e4ae68666806c1f13c6b2c921efcb" args="(const directory_entry &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae64fd6b940ed07398c33c775bd7f575"></a><!-- doxytag: member="directory_entry::operator&gt;" ref="aae64fd6b940ed07398c33c775bd7f575" args="(const directory_entry &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7ab6f6e5c0bee6f1e5cda2b892e3afe"></a><!-- doxytag: member="directory_entry::operator&gt;=" ref="af7ab6f6e5c0bee6f1e5cda2b892e3afe" args="(const directory_entry &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classdirectory__entry.html">directory_entry</a> &amp;rhs) const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a99c7aa29c44148401588fb680ab44334">name</a> () const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a67bdc31854318138ba9c34d8469f6b1c">metadata_ready</a> () const BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a3ad8cabe9b14690a2f0eb7776d556458">fetch_metadata</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh, <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> wanted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the specified metadata, returning that newly available. This is a blocking call if wanted metadata is not yet ready.  <a href="#a3ad8cabe9b14690a2f0eb7776d556458"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstat__t.html">stat_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a82c821341533ccd6e7a6841f0df62362">fetch_lstat</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh, <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> wanted=<a class="el" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3">directory_entry::metadata_fastpath</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the internal `stat_t` structure. This is a blocking call if wanted metadata is not yet ready.  <a href="#a82c821341533ccd6e7a6841f0df62362"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#ab9fe9a795efa2479cde43919af0d4289">st_dev</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_dev.  <a href="#ab9fe9a795efa2479cde43919af0d4289"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#aa668bf3b3f0e2825244214ab6fdb7b70">st_ino</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_ino.  <a href="#aa668bf3b3f0e2825244214ab6fdb7b70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a04f94fc6f5b03fba8afd4b82866211a3">st_type</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_type.  <a href="#a04f94fc6f5b03fba8afd4b82866211a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a4e302e731c846a58c2f767a83c68f14e">st_perms</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_perms.  <a href="#a4e302e731c846a58c2f767a83c68f14e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a014d472a4bff85d7a182756e3c0f9824">st_nlink</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_nlink.  <a href="#a014d472a4bff85d7a182756e3c0f9824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#aef4bb48fb46e6c78dc1ad2aeda4681a9">st_uid</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_uid.  <a href="#aef4bb48fb46e6c78dc1ad2aeda4681a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a30cf008e632ad3c0590d5d5433b11d52">st_gid</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_gid.  <a href="#a30cf008e632ad3c0590d5d5433b11d52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a1eb27dc286a7614ab5b06c08b4dba60e">st_rdev</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_rdev.  <a href="#a1eb27dc286a7614ab5b06c08b4dba60e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#abdd2752820b4f89ca615a6ab93ce3a06">st_atim</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_atim.  <a href="#abdd2752820b4f89ca615a6ab93ce3a06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a15c133f6acd511e518fcf213711b24e8">st_mtim</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_mtim.  <a href="#a15c133f6acd511e518fcf213711b24e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a92de110c65ccc52b2f009c1d17e2c428">st_ctim</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_ctim.  <a href="#a92de110c65ccc52b2f009c1d17e2c428"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#ac7928966ebc20bc4e2b73321c8d3cf2b">st_size</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_size.  <a href="#ac7928966ebc20bc4e2b73321c8d3cf2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#aaa7dfff87e368bb138676c2f8e194314">st_allocated</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_allocated.  <a href="#aaa7dfff87e368bb138676c2f8e194314"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a931b760be9308d5a20161713f63e2529">st_blocks</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_blocks.  <a href="#a931b760be9308d5a20161713f63e2529"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a43ff38c6d1d1da845db602411ec3b3fb">st_blksize</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_blksize.  <a href="#a43ff38c6d1d1da845db602411ec3b3fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a5a1961a9215593f7f11ace287afa4001">st_flags</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_flags.  <a href="#a5a1961a9215593f7f11ace287afa4001"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a5bea44318235f6e0937d9e68dcc66aea">st_gen</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_gen.  <a href="#a5bea44318235f6e0937d9e68dcc66aea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fieldtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a98a8615a9123218b9aeaa195b7179486">st_birthtim</a> (std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt; dirh=std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns st_birthtim.  <a href="#a98a8615a9123218b9aeaa195b7179486"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#ac111d690ae103454c2c48c873b37ba77">metadata_supported</a> () BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitfield of what metadata is available on this platform. This doesn't mean all is available for every filing system.  <a href="#ac111d690ae103454c2c48c873b37ba77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3">metadata_fastpath</a> () BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitfield of what metadata is fast on this platform. This doesn't mean all is available for every filing system.  <a href="#a2c5b9aa9a9fade1f36c8f2cab151a2f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdirectory__entry.html#a280a7fc89e46f8bde5ead3e3ecb10163">compatibility_maximum</a> () BOOST_NOEXCEPT_OR_NOTHROW</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of entries which is "usual" to fetch at once i.e. what your libc does.  <a href="#a280a7fc89e46f8bde5ead3e3ecb10163"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f496ba01c9b613e83758582f2b06c9"></a><!-- doxytag: member="directory_entry::detail::async_file_io_dispatcher_compat" ref="a56f496ba01c9b613e83758582f2b06c9" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_compat</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb74be36e15618561c7df1fbdacea5c"></a><!-- doxytag: member="directory_entry::detail::async_file_io_dispatcher_windows" ref="a7eb74be36e15618561c7df1fbdacea5c" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_windows</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e10cc6179894e1e8bab39ccba6c476"></a><!-- doxytag: member="directory_entry::detail::async_file_io_dispatcher_linux" ref="a06e10cc6179894e1e8bab39ccba6c476" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_linux</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb6d073a418fd80cc2b81450cc82687"></a><!-- doxytag: member="directory_entry::detail::async_file_io_dispatcher_qnx" ref="a4fb6d073a418fd80cc2b81450cc82687" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::async_file_io_dispatcher_qnx</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The abstract base class for an entry in a directory with lazily filled metadata. </p>
<p>Note that `directory_entry_hash` will hash one of these for you, and a `std::hash&lt;directory_entry&gt;` specialisation is defined for you so you ought to be able to use <a class="el" href="classdirectory__entry.html" title="The abstract base class for an entry in a directory with lazily filled metadata.">directory_entry</a> directly in an `unordered_map&lt;&gt;`. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00668">668</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac8325aeead5009b12ea664e073729958"></a><!-- doxytag: member="directory_entry::directory_entry" ref="ac8325aeead5009b12ea664e073729958" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958">directory_entry::directory_entry</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00681">681</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f9450830547a63eb719ca01b37c4325"></a><!-- doxytag: member="directory_entry::directory_entry" ref="a9f9450830547a63eb719ca01b37c4325" args="(filesystem::path _leafname, stat_t __stat, metadata_flags _have_metadata)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdirectory__entry.html#ac8325aeead5009b12ea664e073729958">directory_entry::directory_entry</a> </td>
          <td>(</td>
          <td class="paramtype">filesystem::path&#160;</td>
          <td class="paramname"><em>_leafname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structstat__t.html">stat_t</a>&#160;</td>
          <td class="paramname"><em>__stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td>
          <td class="paramname"><em>_have_metadata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00683">683</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a99c7aa29c44148401588fb680ab44334"></a><!-- doxytag: member="directory_entry::name" ref="a99c7aa29c44148401588fb680ab44334" args="() const BOOST_NOEXCEPT_OR_NOTHROW" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">filesystem::path <a class="el" href="classdirectory__entry.html#a99c7aa29c44148401588fb680ab44334">directory_entry::name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the directory entry </dd></dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00702">702</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67bdc31854318138ba9c34d8469f6b1c"></a><!-- doxytag: member="directory_entry::metadata_ready" ref="a67bdc31854318138ba9c34d8469f6b1c" args="() const BOOST_NOEXCEPT_OR_NOTHROW" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> <a class="el" href="classdirectory__entry.html#a67bdc31854318138ba9c34d8469f6b1c">directory_entry::metadata_ready</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A bitfield of what metadata is ready right now </dd></dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00704">704</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ad8cabe9b14690a2f0eb7776d556458"></a><!-- doxytag: member="directory_entry::fetch_metadata" ref="a3ad8cabe9b14690a2f0eb7776d556458" args="(std::shared_ptr&lt; async_io_handle &gt; dirh, metadata_flags wanted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> <a class="el" href="classdirectory__entry.html#a3ad8cabe9b14690a2f0eb7776d556458">directory_entry::fetch_metadata</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td>
          <td class="paramname"><em>wanted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetches the specified metadata, returning that newly available. This is a blocking call if wanted metadata is not yet ready. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The metadata now available in this directory entry. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An open handle to the entry's containing directory. You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
    <tr><td class="paramname">wanted</td><td>A bitfield of the metadata to fetch. This does not replace existing metadata. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00710">710</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82c821341533ccd6e7a6841f0df62362"></a><!-- doxytag: member="directory_entry::fetch_lstat" ref="a82c821341533ccd6e7a6841f0df62362" args="(std::shared_ptr&lt; async_io_handle &gt; dirh, metadata_flags wanted=directory_entry::metadata_fastpath())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstat__t.html">stat_t</a> <a class="el" href="classdirectory__entry.html#a82c821341533ccd6e7a6841f0df62362">directory_entry::fetch_lstat</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a>&#160;</td>
          <td class="paramname"><em>wanted</em> = <code><a class="el" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3">directory_entry::metadata_fastpath</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of the internal `stat_t` structure. This is a blocking call if wanted metadata is not yet ready. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A copy of the internal `stat_t` structure. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An open handle to the entry's containing directory. You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
    <tr><td class="paramname">wanted</td><td>A bitfield of the metadata to fetch. This does not replace existing metadata. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00723">723</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9fe9a795efa2479cde43919af0d4289"></a><!-- doxytag: member="directory_entry::st_dev" ref="ab9fe9a795efa2479cde43919af0d4289" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#ab9fe9a795efa2479cde43919af0d4289">directory_entry::st_dev</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_dev. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00738">738</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa668bf3b3f0e2825244214ab6fdb7b70"></a><!-- doxytag: member="directory_entry::st_ino" ref="aa668bf3b3f0e2825244214ab6fdb7b70" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#aa668bf3b3f0e2825244214ab6fdb7b70">directory_entry::st_ino</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_ino. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00741">741</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04f94fc6f5b03fba8afd4b82866211a3"></a><!-- doxytag: member="directory_entry::st_type" ref="a04f94fc6f5b03fba8afd4b82866211a3" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a04f94fc6f5b03fba8afd4b82866211a3">directory_entry::st_type</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00743">743</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e302e731c846a58c2f767a83c68f14e"></a><!-- doxytag: member="directory_entry::st_perms" ref="a4e302e731c846a58c2f767a83c68f14e" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a4e302e731c846a58c2f767a83c68f14e">directory_entry::st_perms</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_perms. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00746">746</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a014d472a4bff85d7a182756e3c0f9824"></a><!-- doxytag: member="directory_entry::st_nlink" ref="a014d472a4bff85d7a182756e3c0f9824" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a014d472a4bff85d7a182756e3c0f9824">directory_entry::st_nlink</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_nlink. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00749">749</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef4bb48fb46e6c78dc1ad2aeda4681a9"></a><!-- doxytag: member="directory_entry::st_uid" ref="aef4bb48fb46e6c78dc1ad2aeda4681a9" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#aef4bb48fb46e6c78dc1ad2aeda4681a9">directory_entry::st_uid</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_uid. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00752">752</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30cf008e632ad3c0590d5d5433b11d52"></a><!-- doxytag: member="directory_entry::st_gid" ref="a30cf008e632ad3c0590d5d5433b11d52" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a30cf008e632ad3c0590d5d5433b11d52">directory_entry::st_gid</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_gid. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00754">754</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eb27dc286a7614ab5b06c08b4dba60e"></a><!-- doxytag: member="directory_entry::st_rdev" ref="a1eb27dc286a7614ab5b06c08b4dba60e" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a1eb27dc286a7614ab5b06c08b4dba60e">directory_entry::st_rdev</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_rdev. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00756">756</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdd2752820b4f89ca615a6ab93ce3a06"></a><!-- doxytag: member="directory_entry::st_atim" ref="abdd2752820b4f89ca615a6ab93ce3a06" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#abdd2752820b4f89ca615a6ab93ce3a06">directory_entry::st_atim</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_atim. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00759">759</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15c133f6acd511e518fcf213711b24e8"></a><!-- doxytag: member="directory_entry::st_mtim" ref="a15c133f6acd511e518fcf213711b24e8" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a15c133f6acd511e518fcf213711b24e8">directory_entry::st_mtim</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_mtim. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00761">761</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92de110c65ccc52b2f009c1d17e2c428"></a><!-- doxytag: member="directory_entry::st_ctim" ref="a92de110c65ccc52b2f009c1d17e2c428" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a92de110c65ccc52b2f009c1d17e2c428">directory_entry::st_ctim</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_ctim. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00763">763</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7928966ebc20bc4e2b73321c8d3cf2b"></a><!-- doxytag: member="directory_entry::st_size" ref="ac7928966ebc20bc4e2b73321c8d3cf2b" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#ac7928966ebc20bc4e2b73321c8d3cf2b">directory_entry::st_size</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_size. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00765">765</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa7dfff87e368bb138676c2f8e194314"></a><!-- doxytag: member="directory_entry::st_allocated" ref="aaa7dfff87e368bb138676c2f8e194314" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#aaa7dfff87e368bb138676c2f8e194314">directory_entry::st_allocated</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_allocated. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00767">767</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a931b760be9308d5a20161713f63e2529"></a><!-- doxytag: member="directory_entry::st_blocks" ref="a931b760be9308d5a20161713f63e2529" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a931b760be9308d5a20161713f63e2529">directory_entry::st_blocks</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_blocks. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00769">769</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43ff38c6d1d1da845db602411ec3b3fb"></a><!-- doxytag: member="directory_entry::st_blksize" ref="a43ff38c6d1d1da845db602411ec3b3fb" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a43ff38c6d1d1da845db602411ec3b3fb">directory_entry::st_blksize</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_blksize. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00771">771</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a1961a9215593f7f11ace287afa4001"></a><!-- doxytag: member="directory_entry::st_flags" ref="a5a1961a9215593f7f11ace287afa4001" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a5a1961a9215593f7f11ace287afa4001">directory_entry::st_flags</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_flags. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00773">773</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5bea44318235f6e0937d9e68dcc66aea"></a><!-- doxytag: member="directory_entry::st_gen" ref="a5bea44318235f6e0937d9e68dcc66aea" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a5bea44318235f6e0937d9e68dcc66aea">directory_entry::st_gen</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_gen. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00775">775</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a98a8615a9123218b9aeaa195b7179486"></a><!-- doxytag: member="directory_entry::st_birthtim" ref="a98a8615a9123218b9aeaa195b7179486" args="(std::shared_ptr&lt; async_io_handle &gt; dirh=std::shared_ptr&lt; async_io_handle &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fieldtype <a class="el" href="classdirectory__entry.html#a98a8615a9123218b9aeaa195b7179486">directory_entry::st_birthtim</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classasync__io__handle.html">async_io_handle</a> &gt;&#160;</td>
          <td class="paramname"><em>dirh</em> = <code>std::shared_ptr&lt;<a class="el" href="classasync__io__handle.html">async_io_handle</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns st_birthtim. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dirh</td><td>An optional open handle to the entry's containing directory if fetching missing metadata is desired (an exception is thrown otherwise). You can get this from an op ref using dirop.h-&gt;get(). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="afio_8hpp_source.html#l00777">777</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac111d690ae103454c2c48c873b37ba77"></a><!-- doxytag: member="directory_entry::metadata_supported" ref="ac111d690ae103454c2c48c873b37ba77" args="() BOOST_NOEXCEPT_OR_NOTHROW" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> <a class="el" href="classdirectory__entry.html#ac111d690ae103454c2c48c873b37ba77">directory_entry::metadata_supported</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A bitfield of what metadata is available on this platform. This doesn't mean all is available for every filing system. </p>

</div>
</div>
<a class="anchor" id="a2c5b9aa9a9fade1f36c8f2cab151a2f3"></a><!-- doxytag: member="directory_entry::metadata_fastpath" ref="a2c5b9aa9a9fade1f36c8f2cab151a2f3" args="() BOOST_NOEXCEPT_OR_NOTHROW" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__metadata__flags.html#ga9d8b6ad0ba3e48637529aace103e11fe">metadata_flags</a> <a class="el" href="classdirectory__entry.html#a2c5b9aa9a9fade1f36c8f2cab151a2f3">directory_entry::metadata_fastpath</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A bitfield of what metadata is fast on this platform. This doesn't mean all is available for every filing system. </p>

</div>
</div>
<a class="anchor" id="a280a7fc89e46f8bde5ead3e3ecb10163"></a><!-- doxytag: member="directory_entry::compatibility_maximum" ref="a280a7fc89e46f8bde5ead3e3ecb10163" args="() BOOST_NOEXCEPT_OR_NOTHROW" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classdirectory__entry.html#a280a7fc89e46f8bde5ead3e3ecb10163">directory_entry::compatibility_maximum</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum number of entries which is "usual" to fetch at once i.e. what your libc does. </p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
