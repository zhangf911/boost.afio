<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">x</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; async_io_op &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f">boost::afio::async_file_io_dispatcher_base::zero</a> (const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;ranges)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations.  <a href="#ga48ad1fa0d998d6764b8ee28efaa3a62f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">async_io_op&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga4addd95d8cb11a94efc4712147b128fa">boost::afio::async_file_io_dispatcher_base::zero</a> (const async_io_op &amp;req, const std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; &amp;ranges)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous zero and deallocation of physical storage ("hole punching") after a preceding operation.  <a href="#ga4addd95d8cb11a94efc4712147b128fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; std::vector<br class="typebreak"/>
&lt; future&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; off_t, off_t &gt;<br class="typebreak"/>
 &gt; &gt; &gt;, std::vector<br class="typebreak"/>
&lt; async_io_op &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga7897bcac1891a7ffee77cf3c1eb870e0">boost::afio::async_file_io_dispatcher_base::extents</a> (const std::vector&lt; async_io_op &gt; &amp;ops)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a batch of asynchronous extent enumerations after preceding operations.  <a href="#ga7897bcac1891a7ffee77cf3c1eb870e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; future&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; off_t, off_t &gt;<br class="typebreak"/>
 &gt; &gt;, async_io_op &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga6fab7605a3e8e0bd5be61cb41eb514e4">boost::afio::async_file_io_dispatcher_base::extents</a> (const async_io_op &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an asynchronous extent enumeration after a preceding operation.  <a href="#ga6fab7605a3e8e0bd5be61cb41eb514e4"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga48ad1fa0d998d6764b8ee28efaa3a62f"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::zero" ref="ga48ad1fa0d998d6764b8ee28efaa3a62f" args="(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;ranges)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;async_io_op&gt; <a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f">boost::afio::async_file_io_dispatcher_base::zero</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations. </p>
<p>Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC_FL_PUNCH_HOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A batch of op handles. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>A batch of op handles. </td></tr>
    <tr><td class="paramname">ranges</td><td>A batch of vectors of extents to zero and deallocate.</td></tr>
  </table>
  </dd>
</dl>
    
</div>
</div>
<a class="anchor" id="ga4addd95d8cb11a94efc4712147b128fa"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::zero" ref="ga4addd95d8cb11a94efc4712147b128fa" args="(const async_io_op &amp;req, const std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; &amp;ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">async_io_op <a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f">boost::afio::async_file_io_dispatcher_base::zero</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule an asynchronous zero and deallocation of physical storage ("hole punching") after a preceding operation. </p>
<p>Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC_FL_PUNCH_HOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An op handle. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An op handle. </td></tr>
    <tr><td class="paramname">ranges</td><td>A vector of extents to zero and deallocate.</td></tr>
  </table>
  </dd>
</dl>
    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l02850">2850</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7897bcac1891a7ffee77cf3c1eb870e0"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::extents" ref="ga7897bcac1891a7ffee77cf3c1eb870e0" args="(const std::vector&lt; async_io_op &gt; &amp;ops)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;std::vector&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt; &gt; &gt; &gt;, std::vector&lt;async_io_op&gt; &gt; <a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga7897bcac1891a7ffee77cf3c1eb870e0">boost::afio::async_file_io_dispatcher_base::extents</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a batch of asynchronous extent enumerations after preceding operations. </p>
<p>In a sparsely allocated file, it can be useful to know which extents contain non-zero data. Note that this call is racy (i.e. the extents are enumerated one by one on some platforms, this means they may be out of date with respect to one another) when other threads or processes are concurrently calling <a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f" title="Schedule a batch of asynchronous zeroing and deallocations of physical storage (&quot;hole punching&quot;) afte...">zero()</a> or <a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga2489d452720accc47d1bfeb5525cfd5b" title="Schedule a batch of asynchronous data writes after preceding operations, where offset and total data ...">write()</a> - this is a host OS API limitation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A batch of future vectors of extents. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>A batch of op handles.</td></tr>
  </table>
  </dd>
</dl>
    
</div>
</div>
<a class="anchor" id="ga6fab7605a3e8e0bd5be61cb41eb514e4"></a><!-- doxytag: member="boost::afio::async_file_io_dispatcher_base::extents" ref="ga6fab7605a3e8e0bd5be61cb41eb514e4" args="(const async_io_op &amp;op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; future&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt; &gt; &gt;, async_io_op &gt; <a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga7897bcac1891a7ffee77cf3c1eb870e0">boost::afio::async_file_io_dispatcher_base::extents</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structboost_1_1afio_1_1async__io__op.html">async_io_op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule an asynchronous extent enumeration after a preceding operation. </p>
<p>In a sparsely allocated file, it can be useful to know which extents contain non-zero data. Note that this call is racy (i.e. the extents are enumerated one by one on some platforms, this means they may be out of date with respect to one another) when other threads or processes are concurrently calling <a class="el" href="group__async__file__io__dispatcher__base____extents.html#ga48ad1fa0d998d6764b8ee28efaa3a62f" title="Schedule a batch of asynchronous zeroing and deallocations of physical storage (&quot;hole punching&quot;) afte...">zero()</a> or <a class="el" href="group__async__file__io__dispatcher__base____filedirops.html#ga2489d452720accc47d1bfeb5525cfd5b" title="Schedule a batch of asynchronous data writes after preceding operations, where offset and total data ...">write()</a> - this is a host OS API limitation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A future vector of extents. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>An op handle.</td></tr>
  </table>
  </dd>
</dl>
    
<p>Definition at line <a class="el" href="afio_8hpp_source.html#l02909">2909</a> of file <a class="el" href="afio_8hpp_source.html">afio.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
