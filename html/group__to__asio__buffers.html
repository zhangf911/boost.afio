<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.AFIO</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>

<table cellpadding="2" width="100%">
<tbody>
<tr>
<td valign="top">
<img alt="Boost.AFIO" src="images/ggl-logo-big.png" height="80" width="200">
&nbsp;&nbsp;
</td>
<td valign="top" align="right">
<a href="http://www.boost.org">
<img alt="Boost C++ Libraries" src="images/accepted_by_boost.png" height="80" width="230" border="0">
</a>
</td>
</tr>
</tbody>
</table>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Overloadable free functions converting the types passed to async_data_op_req&lt;&gt; into an asio buffer sequence for read() and write().</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4d5b48b8b62041f0eb1d332b6ee3c8a9"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="ga4d5b48b8b62041f0eb1d332b6ee3c8a9" args="(asio::mutable_buffer &amp;v)" -->
std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (asio::mutable_buffer &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaad8ba2d78365cbb49705467d8e3923b8"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="gaad8ba2d78365cbb49705467d8e3923b8" args="(asio::const_buffer &amp;v)" -->
std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (asio::const_buffer &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gae9038306b955f1af06f765ae0f2880a1"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="gae9038306b955f1af06f765ae0f2880a1" args="(T *v, size_t length)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (T *v, size_t length)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gad414435390ce9e4cfe4bf85d43447c0b"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="gad414435390ce9e4cfe4bf85d43447c0b" args="(const T *v, size_t length)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (const T *v, size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d517384616b5648508780391b3e8f5f"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="ga6d517384616b5648508780391b3e8f5f" args="(void *v, size_t length)" -->
std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (void *v, size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42be30127e97be9c73906906e74b24b0"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="ga42be30127e97be9c73906906e74b24b0" args="(const void *v, size_t length)" -->
std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (const void *v, size_t length)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga772fe53eebaa2177dc53227bbef03f3f"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="ga772fe53eebaa2177dc53227bbef03f3f" args="(T &amp;v)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (T &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0967653554334e6532eeaf4de0f7fe07"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="ga0967653554334e6532eeaf4de0f7fe07" args="(const T &amp;v)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (const T &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga403430fff790e5142116cfbf562cdf07"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="ga403430fff790e5142116cfbf562cdf07" args="(T(&amp;v)[N])" -->
template&lt;class T , size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::mutable_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (T(&amp;v)[N])</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac055cc87431a0c5700e9cda29453f3bb"></a><!-- doxytag: member="to_asio_buffers::to_asio_buffers" ref="gac055cc87431a0c5700e9cda29453f3bb" args="(const T(&amp;v)[N])" -->
template&lt;class T , size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; asio::const_buffer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boost::afio::to_asio_buffers</b> (const T(&amp;v)[N])</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>You can add your own free function overloads to tell AFIO how to convert your custom types into ASIO scatter gather buffers. Note that const types must convert into asio::const_buffer, and non-const types must convert into asio::mutable_buffer. It is entirely acceptable for types to allow writing (const) only and not reading.</p>
<p>Default overloads provided are as follows:</p>
<ul>
<li>Any trivial type T * and number of items.</li>
<li>void * and const void * with number of bytes.</li>
<li>C array types are treated as if a std::array.</li>
<li>asio::const_buffer and asio::mutable_buffer are passed through as-is.</li>
<li>Any container type holding a trivial type T. This includes std::basic_string (write only), std::vector and std::array, all three of which are specially collapsed into a single scatter gather as they guarantee storing their contents contiguously.</li>
<li>Any container type holding any of the above, including other containers. These will be converted into scatter gather lists for you. Note that the constness of the type returned by the container's iterator is respected, so if the container iterator returns a const reference (e.g. std::basic_string) then you cannot gather read into that container, and instead should receive a compile time error. </li>
</ul>
</div><!-- contents -->
<hr size="1">
<table width="100%">
<tbody>
<tr>
<td align="left"><small>
<p>January, 2014</p>
</small></td>
<td align="right">
<small>
Copyright &copy; 2013-2014 Niall Douglas, Cork, Ireland<br>
Copyright &copy; 2013 Paul Kirth, California<br>
</small>
</td>
</tr>
</tbody>
</table>

<address style="text-align: right;"><small>
Documentation is generated by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen</a>
</small></address>
</body>
</html>
