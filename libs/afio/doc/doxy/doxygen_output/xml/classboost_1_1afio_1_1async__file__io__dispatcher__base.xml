<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="classboost_1_1afio_1_1async__file__io__dispatcher__base" kind="class" prot="public">
    <compoundname>boost::afio::async_file_io_dispatcher_base</compoundname>
    <includes refid="afio_8hpp" local="no">afio.hpp</includes>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="group__async__file__io__dispatcher__base____filter_1ga10eca40ababf6e5fa3b3a88ce73f81b6" prot="public" static="no">
        <type>void</type>
        <definition>typedef void boost::afio::async_file_io_dispatcher_base::filter_t(detail::OpType, async_io_op &amp;)</definition>
        <argsstring>(detail::OpType, async_io_op &amp;)</argsstring>
        <name>filter_t</name>
        <briefdescription>
<para>The type of an op filter callback handler. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1109" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__async__file__io__dispatcher__base____filter_1ga303b84424610f3834b70b0778ae1f0b3" prot="public" static="no">
        <type>void</type>
        <definition>typedef void boost::afio::async_file_io_dispatcher_base::filter_readwrite_t(detail::OpType, async_io_handle *, const detail::async_data_op_req_impl&lt; true &gt; &amp;, off_t, size_t, size_t, const asio::error_code &amp;, size_t)</definition>
        <argsstring>(detail::OpType, async_io_handle *, const detail::async_data_op_req_impl&lt; true &gt; &amp;, off_t, size_t, size_t, const asio::error_code &amp;, size_t)</argsstring>
        <name>filter_readwrite_t</name>
        <briefdescription>
<para>The type of a readwrite filter callback handler. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1111" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1111" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" prot="public" static="no">
        <type>std::pair&lt; bool, std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt; &gt;</type>
        <definition>typedef std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt; &gt; boost::afio::async_file_io_dispatcher_base::completion_returntype</definition>
        <argsstring></argsstring>
        <name>completion_returntype</name>
        <briefdescription>
<para>The type returned by a completion handler. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1154" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1154" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__async__file__io__dispatcher__base____completion_1ga54bf743efd9a69d7dd11d01ce25fe304" prot="public" static="no">
        <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref></type>
        <definition>typedef completion_returntype boost::afio::async_file_io_dispatcher_base::completion_t(size_t, async_io_op)</definition>
        <argsstring>(size_t, async_io_op)</argsstring>
        <name>completion_t</name>
        <briefdescription>
<para>The type of a completion handler. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1156" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1156" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a196118fdfdc083334123c10fbebd60c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend struct</type>
        <definition>friend struct detail::async_io_handle_posix</definition>
        <argsstring></argsstring>
        <name>detail::async_io_handle_posix</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1071" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1071" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a4f789025521b0e1f43e78056a480daf6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend struct</type>
        <definition>friend struct detail::async_io_handle_windows</definition>
        <argsstring></argsstring>
        <name>detail::async_io_handle_windows</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1072" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1072" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a56f496ba01c9b613e83758582f2b06c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class detail::async_file_io_dispatcher_compat</definition>
        <argsstring></argsstring>
        <name>detail::async_file_io_dispatcher_compat</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1073" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1073" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a7eb74be36e15618561c7df1fbdacea5c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class detail::async_file_io_dispatcher_windows</definition>
        <argsstring></argsstring>
        <name>detail::async_file_io_dispatcher_windows</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1074" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1074" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a06e10cc6179894e1e8bab39ccba6c476" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class detail::async_file_io_dispatcher_linux</definition>
        <argsstring></argsstring>
        <name>detail::async_file_io_dispatcher_linux</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1075" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1075" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a4fb6d073a418fd80cc2b81450cc82687" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class detail::async_file_io_dispatcher_qnx</definition>
        <argsstring></argsstring>
        <name>detail::async_file_io_dispatcher_qnx</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1076" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1076" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a7b7943811b9e7c7ab34df79e3015e15c" prot="private" static="no" mutable="no">
        <type>detail::async_file_io_dispatcher_base_p *</type>
        <definition>detail::async_file_io_dispatcher_base_p* boost::afio::async_file_io_dispatcher_base::p</definition>
        <argsstring></argsstring>
        <name>p</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1078" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1078" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a19a8708e9e0a56d1f4a112ef223bdb58" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::int_add_io_handle</definition>
        <argsstring>(void *key, std::shared_ptr&lt; async_io_handle &gt; h)</argsstring>
        <name>int_add_io_handle</name>
        <param>
          <type>void *</type>
          <declname>key</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1079"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a997cb149876c5afa6669dba9e5b6eacd" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::int_del_io_handle</definition>
        <argsstring>(void *key)</argsstring>
        <name>int_del_io_handle</name>
        <param>
          <type>void *</type>
          <declname>key</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1080"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a8ded155f7a322783093a576f72f21fa1" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::int_op_from_scheduled_id</definition>
        <argsstring>(size_t id) const </argsstring>
        <name>int_op_from_scheduled_id</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1081"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a547e953737c7270c6616976383221f91" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>boost::afio::async_file_io_dispatcher_base::async_file_io_dispatcher_base</definition>
        <argsstring>(std::shared_ptr&lt; thread_source &gt; threadpool, file_flags flagsforce, file_flags flagsmask)</argsstring>
        <name>async_file_io_dispatcher_base</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1thread__source" kindref="compound">thread_source</ref> &gt;</type>
          <declname>threadpool</declname>
        </param>
        <param>
          <type><ref refid="group__file__flags_1ga1615042683add1802cfc6dc86bd078ee" kindref="member">file_flags</ref></type>
          <declname>flagsforce</declname>
        </param>
        <param>
          <type><ref refid="group__file__flags_1ga1615042683add1802cfc6dc86bd078ee" kindref="member">file_flags</ref></type>
          <declname>flagsmask</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1083"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a9fc400c45bc79eb50db8b74e5d310368" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; bool, std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt; &gt;</type>
        <definition>std::pair&lt;bool, std::shared_ptr&lt;async_io_handle&gt; &gt; boost::afio::async_file_io_dispatcher_base::doadopt</definition>
        <argsstring>(size_t, async_io_op, std::shared_ptr&lt; async_io_handle &gt; h)</argsstring>
        <name>doadopt</name>
        <param>
          <type>size_t</type>
        </param>
        <param>
          <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1085" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1084" bodyend="1087"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a0e93a8a2ee8ce47e38f2b62ce7b7767f" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref></type>
        <definition>completion_returntype boost::afio::async_file_io_dispatcher_base::invoke_user_completion_fast</definition>
        <argsstring>(size_t id, async_io_op h, completion_t *callback)</argsstring>
        <name>invoke_user_completion_fast</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <param>
          <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
          <declname>h</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga54bf743efd9a69d7dd11d01ce25fe304" kindref="member">completion_t</ref> *</type>
          <declname>callback</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1798"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1adb3120d27c9c3b469d30223f7ad63567" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref></type>
        <definition>completion_returntype boost::afio::async_file_io_dispatcher_base::invoke_user_completion_slow</definition>
        <argsstring>(size_t id, async_io_op h, std::function&lt; completion_t &gt; callback)</argsstring>
        <name>invoke_user_completion_slow</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <param>
          <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
          <declname>h</declname>
        </param>
        <param>
          <type>std::function&lt; <ref refid="group__async__file__io__dispatcher__base____completion_1ga54bf743efd9a69d7dd11d01ce25fe304" kindref="member">completion_t</ref> &gt;</type>
          <declname>callback</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1799"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1abb9709f262eac032e28894ad0816ee66" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_io_op &gt; &amp;preconditions, const std::vector&lt; T &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, T))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>preconditions</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1800"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1acdd8dac6f24e9669392a48d9076dbea7" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; T &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, T))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; T &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, T)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1801"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a40280aef4a028fe6e3407e582277ece4" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_io_op &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_io_op))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1802"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aa77f30d0bbf428a4ac00bd5970b2656f" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_path_op_req &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_path_op_req))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref>)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1803"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1af17a821515f54bdac6b6f792c751d01f" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>bool</type>
            <declname>iswrite</declname>
            <defname>iswrite</defname>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; detail::async_data_op_req_impl&lt; iswrite &gt;&gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, detail::async_data_op_req_impl&lt; iswrite &gt;))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; detail::async_data_op_req_impl&lt; iswrite &gt;&gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, detail::async_data_op_req_impl&lt; iswrite &gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1804"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a06bed7cee8e7ec9ecfb1c6cfad57151c" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; future&lt; std::pair&lt; std::vector&lt; <ref refid="classboost_1_1afio_1_1directory__entry" kindref="compound">directory_entry</ref> &gt;, bool &gt; &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>std::pair&lt;std::vector&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; &gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_enumerate_op_req &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_enumerate_op_req, std::shared_ptr&lt; promise&lt; std::pair&lt; std::vector&lt; directory_entry &gt;, bool &gt;&gt;&gt;))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__enumerate__op__req" kindref="compound">async_enumerate_op_req</ref> &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, <ref refid="structboost_1_1afio_1_1async__enumerate__op__req" kindref="compound">async_enumerate_op_req</ref>, std::shared_ptr&lt; promise&lt; std::pair&lt; std::vector&lt; <ref refid="classboost_1_1afio_1_1directory__entry" kindref="compound">directory_entry</ref> &gt;, bool &gt;&gt;&gt;)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1805"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a8e1831ca95cea942db1b103df98a4c0b" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; future&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt; &gt; &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>std::pair&lt;std::vector&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt; &gt; &gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_io_op &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, std::shared_ptr&lt; promise&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt;&gt; ret))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, std::shared_ptr&lt; promise&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt;&gt; ret)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1806"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a6507c066dec0a35f324d4ac39f46d5d1" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; future&lt; <ref refid="structboost_1_1afio_1_1statfs__t" kindref="compound">statfs_t</ref> &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>std::pair&lt;std::vector&lt;future&lt;statfs_t&gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_io_op &gt; &amp;container, const std::vector&lt; fs_metadata_flags &gt; &amp;req, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, fs_metadata_flags, std::shared_ptr&lt; promise&lt; statfs_t &gt;&gt; ret))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="group__fs__metadata__flags_1gadc548bc518f40378c9c9c97f4a994438" kindref="member">fs_metadata_flags</ref> &gt; &amp;</type>
          <declname>req</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, <ref refid="group__fs__metadata__flags_1gadc548bc518f40378c9c9c97f4a994438" kindref="member">fs_metadata_flags</ref>, std::shared_ptr&lt; promise&lt; <ref refid="structboost_1_1afio_1_1statfs__t" kindref="compound">statfs_t</ref> &gt;&gt; ret)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1807"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aeb54b1979419b169165a72abd3d831f5" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::chain_async_ops</definition>
        <argsstring>(int optype, const std::vector&lt; async_lock_op_req &gt; &amp;container, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, async_lock_op_req))</argsstring>
        <name>chain_async_ops</name>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__lock__op__req" kindref="compound">async_lock_op_req</ref> &gt; &amp;</type>
          <declname>container</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, <ref refid="structboost_1_1afio_1_1async__lock__op__req" kindref="compound">async_lock_op_req</ref>)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1808"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a95c2ee11e4c7dc653543eea219c41b3b" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">async_file_io_dispatcher_base::completion_returntype</ref></type>
        <definition>async_file_io_dispatcher_base::completion_returntype boost::afio::async_file_io_dispatcher_base::dobarrier</definition>
        <argsstring>(size_t id, async_io_op h, T)</argsstring>
        <name>dobarrier</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <param>
          <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
          <declname>h</declname>
        </param>
        <param>
          <type>T</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1809"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a0e25bd9ab26e1a945d14c984a6192e29" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt;</type>
        <definition>std::shared_ptr&lt;async_io_handle&gt; boost::afio::async_file_io_dispatcher_base::invoke_async_op_completions</definition>
        <argsstring>(size_t id, async_io_op h, completion_returntype(F::*f)(size_t, async_io_op, Args...), Args...args)</argsstring>
        <name>invoke_async_op_completions</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <param>
          <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
          <declname>h</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, Args...)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1812"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a1f3f249fa5da4f26b5dc19d7fe8de69b" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class F</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::chain_async_op</definition>
        <argsstring>(detail::immediate_async_ops &amp;immediates, int optype, const async_io_op &amp;precondition, async_op_flags flags, completion_returntype(F::*f)(size_t, async_io_op, Args...), Args...args)</argsstring>
        <name>chain_async_op</name>
        <param>
          <type>detail::immediate_async_ops &amp;</type>
          <declname>immediates</declname>
        </param>
        <param>
          <type>int</type>
          <declname>optype</declname>
        </param>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>precondition</declname>
        </param>
        <param>
          <type><ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type><ref refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" kindref="member">completion_returntype</ref>(F::*)(size_t, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref>, Args...)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1813"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1afdaf5abc2bc92330dc7c85295dfbcaed" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual boost::afio::async_file_io_dispatcher_base::~async_file_io_dispatcher_base</definition>
        <argsstring>()</argsstring>
        <name>~async_file_io_dispatcher_base</name>
        <briefdescription>
<para>Destroys the dispatcher, blocking inefficiently if any ops are still in flight. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1090"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ae49a5daedd876d48fc131bca5f0d2b93" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1thread__source" kindref="compound">thread_source</ref> &gt;</type>
        <definition>std::shared_ptr&lt;thread_source&gt; boost::afio::async_file_io_dispatcher_base::threadsource</definition>
        <argsstring>() const </argsstring>
        <name>threadsource</name>
        <briefdescription>
<para>Returns the thread source used by this dispatcher. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1093"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ad0eda011c34511f0d25de9902e16b2b7" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__file__flags_1ga1615042683add1802cfc6dc86bd078ee" kindref="member">file_flags</ref></type>
        <definition>file_flags boost::afio::async_file_io_dispatcher_base::fileflags</definition>
        <argsstring>(file_flags flags) const </argsstring>
        <name>fileflags</name>
        <param>
          <type><ref refid="group__file__flags_1ga1615042683add1802cfc6dc86bd078ee" kindref="member">file_flags</ref></type>
          <declname>flags</declname>
        </param>
        <briefdescription>
<para>Returns file flags as would be used after forcing and masking bits passed during construction. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1095"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a360e6404ee3f0949209836b8184ee007" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t boost::afio::async_file_io_dispatcher_base::wait_queue_depth</definition>
        <argsstring>() const </argsstring>
        <name>wait_queue_depth</name>
        <briefdescription>
<para>Returns the current wait queue depth of this dispatcher. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1097"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aabd3bce4b20a99a5c25668a7b229ae6f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t boost::afio::async_file_io_dispatcher_base::fd_count</definition>
        <argsstring>() const </argsstring>
        <name>fd_count</name>
        <briefdescription>
<para>Returns the number of open items in this dispatcher. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1099"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ac0a315fe8eb87c7827567ef8e916a413" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::op_from_scheduled_id</definition>
        <argsstring>(size_t id) const </argsstring>
        <name>op_from_scheduled_id</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>Returns an op ref for a given <bold>currently</bold> scheduled op id, throwing an exception if id not scheduled at the point of call. Can be used to retrieve exception state from some op id, or one&apos;s own shared future. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> with the same shared future as all op refs with this id. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>The unique integer id for the op. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1106"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filter_1gacc15e280c64ab2f734b097069ed86240" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::post_op_filter_clear</definition>
        <argsstring>()</argsstring>
        <name>post_op_filter_clear</name>
        <briefdescription>
<para>Clears the post op and readwrite filters. Not threadsafe. </para>        </briefdescription>
        <detaileddescription>
<para> <qbk>[heading Complexity]O(1).</qbk>   <qbk>[heading Example][filter_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1118"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filter_1ga9e25e1fbc055efe53bd63f6d700866f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::post_op_filter</definition>
        <argsstring>(std::vector&lt; std::pair&lt; detail::OpType, std::function&lt; async_file_io_dispatcher_base::filter_t &gt;&gt;&gt; filters)</argsstring>
        <name>post_op_filter</name>
        <param>
          <type>std::vector&lt; std::pair&lt; <ref refid="namespaceboost_1_1afio_1_1detail_1a0988089f34c099ad2ef946d6ff03c959" kindref="member">detail::OpType</ref>, std::function&lt; <ref refid="group__async__file__io__dispatcher__base____filter_1ga10eca40ababf6e5fa3b3a88ce73f81b6" kindref="member">async_file_io_dispatcher_base::filter_t</ref> &gt;&gt;&gt;</type>
          <declname>filters</declname>
        </param>
        <briefdescription>
<para>Install op filters for non-buffer taking ops. Not threadsafe. </para>        </briefdescription>
        <detaileddescription>
<para>`std::function&lt;async_file_io_dispatcher_base::filter_t&gt;` will be called after every op of type `detail::OpType` completes (`detail::OpType::Unknown` means call this filter for all ops) with the op type and op output.</para><para>Note that filters are currently implemented as a linear scan, so a full iteration of all filters is done for every op completed. The filter is called straight after an op&apos;s future is set and before any completions are issued. Any exceptions thrown by the filter are thrown away.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filters</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of pairs of op type to be filtered and bound filter handler functions of type `filter_t`</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[heading Complexity]O(N) where N is the total number of filters currently configured.</qbk>   <qbk>[heading Example][filter_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1133"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filter_1ga820758ad7b27f3fa3ca9fa4445db50ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::post_readwrite_filter</definition>
        <argsstring>(std::vector&lt; std::pair&lt; detail::OpType, std::function&lt; async_file_io_dispatcher_base::filter_readwrite_t &gt;&gt;&gt; filters)</argsstring>
        <name>post_readwrite_filter</name>
        <param>
          <type>std::vector&lt; std::pair&lt; <ref refid="namespaceboost_1_1afio_1_1detail_1a0988089f34c099ad2ef946d6ff03c959" kindref="member">detail::OpType</ref>, std::function&lt; <ref refid="group__async__file__io__dispatcher__base____filter_1ga303b84424610f3834b70b0778ae1f0b3" kindref="member">async_file_io_dispatcher_base::filter_readwrite_t</ref> &gt;&gt;&gt;</type>
          <declname>filters</declname>
        </param>
        <briefdescription>
<para>Install read/write op filters, useful for tight ASIO integration. Not threadsafe. </para>        </briefdescription>
        <detaileddescription>
<para>`std::function&lt;async_file_io_dispatcher_base::filter_buffers_t&gt;` will be called after every op of type `detail::OpType` completes (`detail::OpType::Unknown` means call this filter for all ops) with the op type, file handle, op input, file offset, buffers offset, buffers amount, error state and bytes transferred. Any filter other than <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga389a54f126d95872fa3981bbb0f4ca49" kindref="member">read()</ref> and <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga2489d452720accc47d1bfeb5525cfd5b" kindref="member">write()</ref> will be ignored, for those use <ref refid="group__async__file__io__dispatcher__base____filter_1ga9e25e1fbc055efe53bd63f6d700866f7" kindref="member">post_op_filter()</ref>.</para><para>Note that buffer filters are currently implemented as a linear scan, so a full iteration of all buffer filters is done for every read/write op completed. The filter is called straight after a read or write operation has completed, and BEFORE any checks that it transferred the data it was supposed to. Any exceptions thrown by the filter are reported as if the read/write operation threw them, and filter processing stops at the filter which threw.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>filters</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of pairs of op type to be filtered and bound filter handler functions of type `filter_buffers_t`</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk>[heading Complexity]O(N) where N is the total number of filters currently configured.</qbk>   <qbk>[heading Example][filter_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1151"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____completion_1ga6cb87e3ca62468c8027a0cf052a9ff24" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::completion</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; std::pair&lt; async_op_flags, std::function&lt; async_file_io_dispatcher_base::completion_t &gt;&gt;&gt; &amp;callbacks)</argsstring>
        <name>completion</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::pair&lt; <ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref>, std::function&lt; <ref refid="group__async__file__io__dispatcher__base____completion_1ga54bf743efd9a69d7dd11d01ce25fe304" kindref="member">async_file_io_dispatcher_base::completion_t</ref> &gt;&gt;&gt; &amp;</type>
          <declname>callbacks</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous invocations of the specified functions when their supplied operations complete. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of precondition op handles. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callbacks</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of pairs of op flags and bound completion handler functions of type `completion_t`</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch bound functions</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][completion_example1]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1174"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____completion_1gac745f6f5424e142086cf45cc583f5aac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::completion</definition>
        <argsstring>(const async_io_op &amp;req, const std::pair&lt; async_op_flags, std::function&lt; async_file_io_dispatcher_base::completion_t &gt;&gt; &amp;callback)</argsstring>
        <name>completion</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <param>
          <type>const std::pair&lt; <ref refid="group__async__op__flags_1ga3d03d4b42e2ae303e282d0a1dec22976" kindref="member">async_op_flags</ref>, std::function&lt; <ref refid="group__async__file__io__dispatcher__base____completion_1ga54bf743efd9a69d7dd11d01ce25fe304" kindref="member">async_file_io_dispatcher_base::completion_t</ref> &gt;&gt; &amp;</type>
          <declname>callback</declname>
        </param>
        <briefdescription>
<para>Schedule the asynchronous invocation of the specified single function when the supplied single operation completes. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>A precondition op handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>A pair of op flag and bound completion handler function of type `completion_t`</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single bound function</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][completion_example1]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1186" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2810" bodyend="2818"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____call_1gaa144378bedc4272b44c9b8f358a04fb7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; shared_future&lt; R &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>std::pair&lt; std::vector&lt; shared_future&lt; R &gt; &gt;, std::vector&lt; async_io_op &gt; &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;callables)</argsstring>
        <name>call</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;</type>
          <declname>callables</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit.</para><para><simplesect kind="return"><para>A pair with a batch of futures returning the result of each of the callables and a batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class R</parametername>
</parameternamelist>
<parameterdescription>
<para>A compiler deduced return type of the bound functions. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of precondition op handles. If default constructed, a precondition is null. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callables</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of bound functions to call, returning R.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch bound functions</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1203" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2826" bodyend="2841"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____call_1ga9ccdb35979566b5852e1817388f6a39b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; shared_future&lt; R &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>std::pair&lt;std::vector&lt;shared_future&lt;R&gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;callables)</argsstring>
        <name>call</name>
        <param>
          <type>const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;</type>
          <declname>callables</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit. If you are seeing performance issues, using `completion()` directly will have much less overhead.</para><para><simplesect kind="return"><para>A pair with a batch of futures returning the result of each of the callables and a batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class R</parametername>
</parameternamelist>
<parameterdescription>
<para>A compiler deduced return type of the bound functions. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callables</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of bound functions to call, returning R.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch bound functions without preconditions</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1219" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1219" bodyend="1219"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ab10c6c273f3e7825fea188cd6c2788b8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; shared_future&lt; R &gt;, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::pair&lt; shared_future&lt; R &gt;, async_io_op &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const async_io_op &amp;req, std::function&lt; R()&gt; callback)</argsstring>
        <name>call</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <param>
          <type>std::function&lt; R()&gt;</type>
          <declname>callback</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous invocation of the specified bound function when its supplied precondition completes. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit. If you are seeing performance issues, using `completion()` directly will have much less overhead.</para><para><simplesect kind="return"><para>A pair with a future returning the result of the callable and an op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class R</parametername>
</parameternamelist>
<parameterdescription>
<para>A compiler deduced return type of the bound functions. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>A precondition op handle. If default constructed, the precondition is null. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>A bound functions to call, returning R.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single bound function</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1236" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2842" bodyend="2851"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____call_1gaf3bde0b207a33ac44e61a09ca93be50f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class C</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::pair&lt; shared_future&lt; typename std::result_of&lt; C(Args...)&gt;::type &gt;, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::pair&lt; shared_future&lt; typename std::result_of&lt; C(Args...)&gt;::type &gt;, async_io_op &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const async_io_op &amp;req, C callback, Args...args)</argsstring>
        <name>call</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callback</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous invocation of the specified unbound callable when its supplied precondition completes. Note that this function essentially calls `std::bind()` on the callable and the args and passes it to the other <ref refid="group__async__file__io__dispatcher__base____call_1gaa144378bedc4272b44c9b8f358a04fb7" kindref="member">call()</ref> overload taking a `std::function&lt;&gt;`. You should therefore use `std::ref()` etc. as appropriate. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit. If you are seeing performance issues, using `completion()` directly will have much less overhead.</para><para><simplesect kind="return"><para>A pair with a future returning the result of the callable and an op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class C</parametername>
</parameternamelist>
<parameterdescription>
<para>Any callable type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Any sequence of argument types. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>A precondition op handle. If default constructed, the precondition is null. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>An unbound callable to call. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>An arbitrary sequence of arguments to bind to the callable.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single unbound callable</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1264" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2856" bodyend="2861"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga284b1612b2c0a3ea813660bc9fd6a54b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::adopt</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; async_io_handle &gt;&gt; &amp;hs)</argsstring>
        <name>adopt</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt;&gt; &amp;</type>
          <declname>hs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of third party handle adoptions. </para>        </briefdescription>
        <detaileddescription>
<para>This function enables you to adopt third party custom <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> derivatives as ops into the scheduler. Think of it as if you were calling <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" kindref="member">file()</ref>, except the op returns the supplied handle and otherwise does nothing.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>hs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of handles to adopt.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][adopt_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1283"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaa3f199f010ded1399b4f903a194b9cd3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::adopt</definition>
        <argsstring>(std::shared_ptr&lt; async_io_handle &gt; h)</argsstring>
        <name>adopt</name>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>Schedule an adoption of a third party handle. </para>        </briefdescription>
        <detaileddescription>
<para>This function enables you to adopt third party custom <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> derivatives as ops into the scheduler. Think of it as if you were calling <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" kindref="member">file()</ref>, except the op returns the supplied handle and otherwise does nothing.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>h</parametername>
</parameternamelist>
<parameterdescription>
<para>A handle to adopt.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][adopt_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1298" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2863" bodyend="2869"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaf6386ba1f9bd0e829470837bef6c7d73" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::dir</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>dir</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous directory creations and opens after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file_flags::UniqueDirectoryHandle is specified.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if directory creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1312"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gacceb89d11308e3137186aaccec282a17" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::dir</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>dir</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous directory creation and open after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file_flags::UniqueDirectoryHandle is specified.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1326" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2870" bodyend="2876"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga41e799782c22f41b16d408a977460153" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::rmdir</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>rmdir</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous directory deletions after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if directory deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1337"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gadb64fc6cabd8e1f394b112cf2361a20a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::rmdir</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>rmdir</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous directory deletion after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1348" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2877" bodyend="2883"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::file</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>file</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file creations and opens after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para>Be aware that any files created are by default sparse if supported on the local filing system. Use file_flags::NoSparse to prevent this on those filing systems which permit it.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1362"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga59910bc569f75eac27c406c47ccd0643" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::file</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>file</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file creation and open after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Be aware that any files created are by default sparse if supported on the local filing system. Use file_flags::NoSparse to prevent this on those filing systems which permit it.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1376" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2884" bodyend="2890"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga1e2c1e20ed7a8d04c3dc63490f8e2580" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::rmfile</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>rmfile</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file deletions after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1387"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaa222f0e9e966ddddf823166105589316" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::rmfile</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>rmfile</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file deletion after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1398" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2891" bodyend="2897"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga831d3e585fab96f70b71b1b1a41bd858" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::symlink</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>symlink</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous symlink creations and opens after a precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the <computeroutput>SeCreateSymbolicLinkPrivilege</computeroutput> for non-Administrative users.</para><para>Note that currently on Windows non-directory symbolic links are not supported. If there is demand for this we may add support.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1415"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gac56fe0c4aa9d3ead576ff210b3bb3b92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::symlink</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>symlink</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous symlink creation and open after a precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the <computeroutput>SeCreateSymbolicLinkPrivilege</computeroutput> for non-Administrative users.</para><para>Note that currently on Windows non-directory symbolic links are not supported. If there is demand for this we may add support.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1432" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2898" bodyend="2904"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga5f83cde9b9428423ab6cfbefbe0865b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::rmsymlink</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>rmsymlink</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous symlink deletions after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1443"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga3d4a61ff8c31bade2d3a5f3aa7e1cb60" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::rmsymlink</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>rmsymlink</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__path__op__req" kindref="compound">async_path_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous symlink deletion after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1454" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2905" bodyend="2911"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gab2bbf924a104039e4fb5b9a31f14e81e" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::sync</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops)=0</argsstring>
        <name>sync</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if content synchronisation is constant time (which is extremely unlikely).</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1465"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga7cb40ff0cb3eee7096f0a126bc509db8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::sync</definition>
        <argsstring>(const async_io_op &amp;req)</argsstring>
        <name>sync</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous content synchronisation with physical storage after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if content synchronisation is constant time (which is extremely unlikely).</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1476" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2912" bodyend="2918"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____extents_1ga48ad1fa0d998d6764b8ee28efaa3a62f" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::zero</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;ranges)=0</argsstring>
        <name>zero</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt;&gt; &amp;</type>
          <declname>ranges</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous zeroing and deallocations of physical storage (&quot;hole punching&quot;) after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para>Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC_FL_PUNCH_HOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ranges</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of vectors of extents to zero and deallocate.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if deallocation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][extents_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1498"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____extents_1ga4addd95d8cb11a94efc4712147b128fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::zero</definition>
        <argsstring>(const async_io_op &amp;req, const std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; &amp;ranges)</argsstring>
        <name>zero</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::pair&lt; off_t, off_t &gt;&gt; &amp;</type>
          <declname>ranges</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous zero and deallocation of physical storage (&quot;hole punching&quot;) after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para>Most extent based filing systems provide an optimised way of zeroing parts of a file by deallocating the storage backing those regions, and marking those regions as unwritten instead of actually writing zero bytes to storage. They appear as zeroes to anything reading those ranges, and have the big advantage of not consuming any actual physical storage. On Windows, extent deallocation writes zeros for ordinary files and only actually deallocates physical storage if the file is sparse or compressed (note that AFIO by default creates sparse files where possible, and converts any file opened for writing to a sparse file). For your information, deallocation on NTFS is on a 64Kb granularity, but the zeros are written at a byte granularity. On Linux, an attempt is made to use FALLOC_FL_PUNCH_HOLE which if it fails then a write of zeros corresponding to the same ranges is made instead. On FreeBSD, long runs of zeros are automatically detected and eliminated on physical storage, and so zeros are simply written. On OS X, there is no formal hole punching API that we are aware of, and so zeros are simply written.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ranges</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector of extents to zero and deallocate.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if deallocation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][extents_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1520" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2919" bodyend="2928"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga56db87e1d05cf4c17c7587216b2413c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::close</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops)=0</argsstring>
        <name>close</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file or directory handle closes after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para>Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref>. This can consume considerable time, especially if SyncOnClose is enabled.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if closing handles is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1534"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga269273113b9ec5eea764791852cbd53a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::close</definition>
        <argsstring>(const async_io_op &amp;req)</argsstring>
        <name>close</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file or directory handle close after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para>Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref>. This can consume considerable time, especially if SyncOnClose is enabled.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if closing handles is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1548" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2929" bodyend="2935"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga389a54f126d95872fa3981bbb0f4ca49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="pure-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt; async_io_op &gt; boost::afio::async_file_io_dispatcher_base::read</definition>
        <argsstring>(const std::vector&lt; async_data_op_req&lt; T &gt;&gt; &amp;ops)=0</argsstring>
        <name>read</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__data__op__req" kindref="compound">async_data_op_req</ref>&lt; T &gt;&gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of async_data_op_req&lt;T&gt; structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if reading data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1567" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2952" bodyend="2955"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga2f99a4c769b6d769e829cee1679763c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::read</definition>
        <argsstring>(const async_data_op_req&lt; T &gt; &amp;req)</argsstring>
        <name>read</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__data__op__req" kindref="compound">async_data_op_req</ref>&lt; T &gt; &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An async_data_op_req&lt;T&gt; structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1585"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga2489d452720accc47d1bfeb5525cfd5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::write</definition>
        <argsstring>(const std::vector&lt; async_data_op_req&lt; const T &gt;&gt; &amp;ops)=0</argsstring>
        <name>write</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__data__op__req" kindref="compound">async_data_op_req</ref>&lt; const T &gt;&gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of <ref refid="structboost_1_1afio_1_1async__data__op__req_3_01const_01_t_01_4" kindref="compound">async_data_op_req&lt;const T&gt;</ref> structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if writing data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1604"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaccfb68e7fb84c36f418215e4d792988f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::write</definition>
        <argsstring>(const async_data_op_req&lt; const T &gt; &amp;req)</argsstring>
        <name>write</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__data__op__req" kindref="compound">async_data_op_req</ref>&lt; const T &gt; &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An <ref refid="structboost_1_1afio_1_1async__data__op__req_3_01const_01_t_01_4" kindref="compound">async_data_op_req&lt;const T&gt;</ref> structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1622"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gae3f243608a9f97af2461ead5bb8189af" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::truncate</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; off_t &gt; &amp;sizes)=0</argsstring>
        <name>truncate</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; off_t &gt; &amp;</type>
          <declname>sizes</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file length truncations after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of new lengths.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if truncating file lengths is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1636"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaa6d63c51183b6f637a723b00155e1cac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref></type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::truncate</definition>
        <argsstring>(const async_io_op &amp;op, off_t newsize)</argsstring>
        <name>truncate</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>off_t</type>
          <declname>newsize</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file length truncation after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newsize</parametername>
</parameternamelist>
<parameterdescription>
<para>The new size for the file.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if truncating file lengths is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1648" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2960" bodyend="2969"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____enumerate_1ga9463c9d43626c23e5ef4c7c840d36fcd" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::pair&lt; std::vector&lt; future&lt; std::pair&lt; std::vector&lt; <ref refid="classboost_1_1afio_1_1directory__entry" kindref="compound">directory_entry</ref> &gt;, bool &gt; &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>virtual std::pair&lt;std::vector&lt;future&lt;std::pair&lt;std::vector&lt;directory_entry&gt;, bool&gt; &gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::enumerate</definition>
        <argsstring>(const std::vector&lt; async_enumerate_op_req &gt; &amp;reqs)=0</argsstring>
        <name>enumerate</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__enumerate__op__req" kindref="compound">async_enumerate_op_req</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous directory enumerations after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para>By default <ref refid="group__async__file__io__dispatcher__base____filedirops_1gaf6386ba1f9bd0e829470837bef6c7d73" kindref="member">dir()</ref> returns shared handles i.e. dir(&quot;foo&quot;) and dir(&quot;foo&quot;) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file_flags::UniqueDirectoryHandle flag.</para><para>Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time.</para><para><simplesect kind="return"><para>A batch of future vectors of directory entries with boolean returning false if done. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of enumeration requests.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool*M) to complete where M is the average number of entries in each directory.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][enumerate_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1669"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____enumerate_1ga0695e33450ba820ebcb378f8b33d9ac1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; future&lt; std::pair&lt; std::vector&lt; <ref refid="classboost_1_1afio_1_1directory__entry" kindref="compound">directory_entry</ref> &gt;, bool &gt; &gt;, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::pair&lt; future&lt; std::pair&lt; std::vector&lt; directory_entry &gt;, bool &gt; &gt;, async_io_op &gt; boost::afio::async_file_io_dispatcher_base::enumerate</definition>
        <argsstring>(const async_enumerate_op_req &amp;req)</argsstring>
        <name>enumerate</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__enumerate__op__req" kindref="compound">async_enumerate_op_req</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous directory enumeration after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para>By default <ref refid="group__async__file__io__dispatcher__base____filedirops_1gaf6386ba1f9bd0e829470837bef6c7d73" kindref="member">dir()</ref> returns shared handles i.e. dir(&quot;foo&quot;) and dir(&quot;foo&quot;) will return the exact same handle, and therefore enumerating not all of the entries at once is a race condition. The solution is to either set maxitems to a value large enough to guarantee a directory will be enumerated in a single shot, or to open a separate directory handle using the file_flags::UniqueDirectoryHandle flag.</para><para>Note that setting maxitems=1 will often cause a buffer space exhaustion, causing a second syscall with an enlarged buffer. This is because AFIO cannot know if the allocated buffer can hold all of the filename being retrieved, so it may have to retry. Put another way, setting maxitems=1 will give you the worst performance possible, whereas maxitems=2 will probably only return one item most of the time.</para><para><simplesect kind="return"><para>A future vector of directory entries with a boolean returning false if done. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An enumeration request.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of entries in each directory.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][enumerate_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1690" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2970" bodyend="2977"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____extents_1ga7897bcac1891a7ffee77cf3c1eb870e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::pair&lt; std::vector&lt; future&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt; &gt; &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>virtual std::pair&lt;std::vector&lt;future&lt;std::vector&lt;std::pair&lt;off_t, off_t&gt; &gt; &gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::extents</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops)=0</argsstring>
        <name>extents</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous extent enumerations after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para>In a sparsely allocated file, it can be useful to know which extents contain non-zero data. Note that this call is racy (i.e. the extents are enumerated one by one on some platforms, this means they may be out of date with respect to one another) when other threads or processes are concurrently calling <ref refid="group__async__file__io__dispatcher__base____extents_1ga48ad1fa0d998d6764b8ee28efaa3a62f" kindref="member">zero()</ref> or <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga2489d452720accc47d1bfeb5525cfd5b" kindref="member">write()</ref> - this is a host OS API limitation.</para><para><simplesect kind="return"><para>A batch of future vectors of extents. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool*M) to complete where M is the average number of extents in each file.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][extents_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1706"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____extents_1ga6fab7605a3e8e0bd5be61cb41eb514e4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; future&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt; &gt; &gt;, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::pair&lt; future&lt; std::vector&lt; std::pair&lt; off_t, off_t &gt; &gt; &gt;, async_io_op &gt; boost::afio::async_file_io_dispatcher_base::extents</definition>
        <argsstring>(const async_io_op &amp;op)</argsstring>
        <name>extents</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous extent enumeration after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para>In a sparsely allocated file, it can be useful to know which extents contain non-zero data. Note that this call is racy (i.e. the extents are enumerated one by one on some platforms, this means they may be out of date with respect to one another) when other threads or processes are concurrently calling <ref refid="group__async__file__io__dispatcher__base____extents_1ga48ad1fa0d998d6764b8ee28efaa3a62f" kindref="member">zero()</ref> or <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga2489d452720accc47d1bfeb5525cfd5b" kindref="member">write()</ref> - this is a host OS API limitation.</para><para><simplesect kind="return"><para>A future vector of extents. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(M) to complete where M is the average number of extents in each file.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][extents_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1722" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2978" bodyend="2985"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____statfs_1gacbeafa55623e83a890db62e190fc6c04" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::pair&lt; std::vector&lt; future&lt; <ref refid="structboost_1_1afio_1_1statfs__t" kindref="compound">statfs_t</ref> &gt; &gt;, std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &gt;</type>
        <definition>virtual std::pair&lt;std::vector&lt;future&lt;statfs_t&gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::statfs</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; fs_metadata_flags &gt; &amp;reqs)=0</argsstring>
        <name>statfs</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="group__fs__metadata__flags_1gadc548bc518f40378c9c9c97f4a994438" kindref="member">fs_metadata_flags</ref> &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous volume enumerations after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of future volume metadatas. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of metadata requests.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool*M) to complete where M is the average number of entries in each directory.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][statfs_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1734"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____statfs_1gacde9af80f4041fee04f759ad70e615d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; future&lt; <ref refid="structboost_1_1afio_1_1statfs__t" kindref="compound">statfs_t</ref> &gt;, <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::pair&lt; future&lt; statfs_t &gt;, async_io_op &gt; boost::afio::async_file_io_dispatcher_base::statfs</definition>
        <argsstring>(const async_io_op &amp;op, const fs_metadata_flags &amp;req)</argsstring>
        <name>statfs</name>
        <param>
          <type>const <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>const <ref refid="group__fs__metadata__flags_1gadc548bc518f40378c9c9c97f4a994438" kindref="member">fs_metadata_flags</ref> &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous volume enumeration after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A future volume metadatas. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>A metadata request.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][statfs_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1746" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2986" bodyend="2996"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aa6c989e2c9e5d3d5c425bebc986bc06c" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::lock</definition>
        <argsstring>(const std::vector&lt; async_lock_op_req &gt; &amp;req)=0</argsstring>
        <name>lock</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__lock__op__req" kindref="compound">async_lock_op_req</ref> &gt; &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1749"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____barrier_1gacc278eff00d3740305863354cca4660b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::barrier</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops)</argsstring>
        <name>barrier</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous synchronisation of preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para>If you perform many asynchronous operations of unequal duration but wish to schedule one of more operations to occur only after <bold>all</bold> of those operations have completed, this is the correct function to use. The returned batch of ops exactly match the input batch of ops (including their exception states), but they will only complete when the last of the input batch of ops completes.</para><para><simplesect kind="note"><para>If an input op is in an exceptioned state at the point of entry into this function, this function will propagate the exception there and then. <emphasis>Only</emphasis> error states which occur <emphasis>after</emphasis> this function has been scheduled are propagated into the output set of ops.</para></simplesect>
<simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N) to complete.</qbk>   <qbk>[heading Exception Model]See detailed description above.</qbk>   <qbk>[heading Example][barrier_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1770"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____misc_1ga006bef030dab5c7bc67fbdc5bc352cef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::complete_async_op</definition>
        <argsstring>(size_t id, std::shared_ptr&lt; async_io_handle &gt; h, exception_ptr e=exception_ptr())</argsstring>
        <name>complete_async_op</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> &gt;</type>
          <declname>h</declname>
        </param>
        <param>
          <type>exception_ptr</type>
          <declname>e</declname>
          <defval>exception_ptr()</defval>
        </param>
        <briefdescription>
<para>Completes an operation with a handle or an error, usually used when an operation was previously deferred. </para>        </briefdescription>
        <detaileddescription>
<para> <qbk.distinguish> normal</qbk.distinguish>   <qbk>[heading Complexity]O(N) where N is the number of completions dependent on this op.</qbk>   <qbk>[heading Exception Model]Should not throw any exception except for out of memory.</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1788"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____misc_1ga39bb6e878d9ad0b4b926e31ced073177" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void boost::afio::async_file_io_dispatcher_base::complete_async_op</definition>
        <argsstring>(size_t id, exception_ptr e)</argsstring>
        <name>complete_async_op</name>
        <param>
          <type>size_t</type>
          <declname>id</declname>
        </param>
        <param>
          <type>exception_ptr</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Completes an operation with an error, usually used when an operation was previously deferred. </para>        </briefdescription>
        <detaileddescription>
<para> <qbk.distinguish> errored</qbk.distinguish>   <qbk>[heading Complexity]O(N) where N is the number of completions dependent on this op.</qbk>   <qbk>[heading Exception Model]Should not throw any exception except for out of memory.</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1796" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1796" bodyend="1796"/>
      </memberdef>
      <memberdef kind="function" id="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a735e7a659db8e76f0bfb77123c38f23b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structboost_1_1afio_1_1async__io__op" kindref="compound">async_io_op</ref> &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::write</definition>
        <argsstring>(const std::vector&lt; async_data_op_req&lt; T &gt;&gt; &amp;ops)</argsstring>
        <name>write</name>
        <param>
          <type>const std::vector&lt; <ref refid="structboost_1_1afio_1_1async__data__op__req" kindref="compound">async_data_op_req</ref>&lt; T &gt;&gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="2957" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2956" bodyend="2959"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____misc_1ga0dbf229a0b5733133f74aabf22d47609" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>static size_t boost::afio::async_file_io_dispatcher_base::page_size</definition>
        <argsstring>() noexcept</argsstring>
        <name>page_size</name>
        <briefdescription>
<para>Returns the page size of this architecture which is useful for calculating direct i/o multiples. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The page size of this architecture.</para></simplesect>
 <qbk>[heading Complexity]Whatever the system API takes (one would hope constant time).</qbk>   <qbk>[heading Exception Model]Never throws any exception.</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1779"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Abstract base class for dispatching file i/o asynchronously. </para>    </briefdescription>
    <detaileddescription>
<para>This is a reference counted instance with platform-specific implementation optionally hidden in object code. Construct an instance using the `boost<ref refid="group__async__file__io__dispatcher_1ga412e5ba3eaf5c1df0499dad2ddd79fb8" kindref="member">afio::make_async_file_io_dispatcher()</ref>` function.</para><para> <qbk>
[/ link afio.reference.functions.async_file_io_dispatcher `async_file_io_dispatcher()`]
[include generated/group_async_file_io_dispatcher_base__filter.qbk]
[include generated/group_async_file_io_dispatcher_base__completion.qbk]
[include generated/group_async_file_io_dispatcher_base__call.qbk]
[include generated/group_async_file_io_dispatcher_base__filedirops.qbk]
[include generated/group_async_file_io_dispatcher_base__barrier.qbk]
[include generated/group_async_file_io_dispatcher_base__enumerate.qbk]
[include generated/group_async_file_io_dispatcher_base__extents.qbk]
[include generated/group_async_file_io_dispatcher_base__statfs.qbk]
[include generated/group_async_file_io_dispatcher_base__misc.qbk]
</qbk>  </para>    </detaileddescription>
    <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1069" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="1068" bodyend="1814"/>
    <listofallmembers>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga284b1612b2c0a3ea813660bc9fd6a54b" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>adopt</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gaa3f199f010ded1399b4f903a194b9cd3" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>adopt</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a547e953737c7270c6616976383221f91" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>async_file_io_dispatcher_base</name></member>
      <member refid="group__async__file__io__dispatcher__base____barrier_1gacc278eff00d3740305863354cca4660b" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>barrier</name></member>
      <member refid="group__async__file__io__dispatcher__base____call_1gaa144378bedc4272b44c9b8f358a04fb7" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>call</name></member>
      <member refid="group__async__file__io__dispatcher__base____call_1ga9ccdb35979566b5852e1817388f6a39b" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>call</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ab10c6c273f3e7825fea188cd6c2788b8" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>call</name></member>
      <member refid="group__async__file__io__dispatcher__base____call_1gaf3bde0b207a33ac44e61a09ca93be50f" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>call</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a1f3f249fa5da4f26b5dc19d7fe8de69b" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_op</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1abb9709f262eac032e28894ad0816ee66" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1acdd8dac6f24e9669392a48d9076dbea7" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a40280aef4a028fe6e3407e582277ece4" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aa77f30d0bbf428a4ac00bd5970b2656f" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1af17a821515f54bdac6b6f792c751d01f" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a06bed7cee8e7ec9ecfb1c6cfad57151c" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a8e1831ca95cea942db1b103df98a4c0b" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a6507c066dec0a35f324d4ac39f46d5d1" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aeb54b1979419b169165a72abd3d831f5" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>chain_async_ops</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga56db87e1d05cf4c17c7587216b2413c9" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>close</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga269273113b9ec5eea764791852cbd53a" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>close</name></member>
      <member refid="group__async__file__io__dispatcher__base____misc_1ga006bef030dab5c7bc67fbdc5bc352cef" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>complete_async_op</name></member>
      <member refid="group__async__file__io__dispatcher__base____misc_1ga39bb6e878d9ad0b4b926e31ced073177" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>complete_async_op</name></member>
      <member refid="group__async__file__io__dispatcher__base____completion_1ga6cb87e3ca62468c8027a0cf052a9ff24" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>completion</name></member>
      <member refid="group__async__file__io__dispatcher__base____completion_1gac745f6f5424e142086cf45cc583f5aac" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>completion</name></member>
      <member refid="group__async__file__io__dispatcher__base____completion_1ga384aa77fea0f91d58814c50feeee44dc" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>completion_returntype</name></member>
      <member refid="group__async__file__io__dispatcher__base____completion_1ga54bf743efd9a69d7dd11d01ce25fe304" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>completion_t</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a56f496ba01c9b613e83758582f2b06c9" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>detail::async_file_io_dispatcher_compat</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a06e10cc6179894e1e8bab39ccba6c476" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>detail::async_file_io_dispatcher_linux</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a4fb6d073a418fd80cc2b81450cc82687" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>detail::async_file_io_dispatcher_qnx</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a7eb74be36e15618561c7df1fbdacea5c" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>detail::async_file_io_dispatcher_windows</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a196118fdfdc083334123c10fbebd60c3" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>detail::async_io_handle_posix</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a4f789025521b0e1f43e78056a480daf6" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>detail::async_io_handle_windows</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gaf6386ba1f9bd0e829470837bef6c7d73" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>dir</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gacceb89d11308e3137186aaccec282a17" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>dir</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a9fc400c45bc79eb50db8b74e5d310368" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>doadopt</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a95c2ee11e4c7dc653543eea219c41b3b" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>dobarrier</name></member>
      <member refid="group__async__file__io__dispatcher__base____enumerate_1ga9463c9d43626c23e5ef4c7c840d36fcd" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>enumerate</name></member>
      <member refid="group__async__file__io__dispatcher__base____enumerate_1ga0695e33450ba820ebcb378f8b33d9ac1" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>enumerate</name></member>
      <member refid="group__async__file__io__dispatcher__base____extents_1ga7897bcac1891a7ffee77cf3c1eb870e0" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>extents</name></member>
      <member refid="group__async__file__io__dispatcher__base____extents_1ga6fab7605a3e8e0bd5be61cb41eb514e4" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>extents</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aabd3bce4b20a99a5c25668a7b229ae6f" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>fd_count</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>file</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga59910bc569f75eac27c406c47ccd0643" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>file</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ad0eda011c34511f0d25de9902e16b2b7" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>fileflags</name></member>
      <member refid="group__async__file__io__dispatcher__base____filter_1ga303b84424610f3834b70b0778ae1f0b3" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>filter_readwrite_t</name></member>
      <member refid="group__async__file__io__dispatcher__base____filter_1ga10eca40ababf6e5fa3b3a88ce73f81b6" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>filter_t</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a19a8708e9e0a56d1f4a112ef223bdb58" prot="private" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>int_add_io_handle</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a997cb149876c5afa6669dba9e5b6eacd" prot="private" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>int_del_io_handle</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a8ded155f7a322783093a576f72f21fa1" prot="private" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>int_op_from_scheduled_id</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a0e25bd9ab26e1a945d14c984a6192e29" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>invoke_async_op_completions</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a0e93a8a2ee8ce47e38f2b62ce7b7767f" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>invoke_user_completion_fast</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1adb3120d27c9c3b469d30223f7ad63567" prot="protected" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>invoke_user_completion_slow</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1aa6c989e2c9e5d3d5c425bebc986bc06c" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>lock</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ac0a315fe8eb87c7827567ef8e916a413" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>op_from_scheduled_id</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a7b7943811b9e7c7ab34df79e3015e15c" prot="private" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>p</name></member>
      <member refid="group__async__file__io__dispatcher__base____misc_1ga0dbf229a0b5733133f74aabf22d47609" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>page_size</name></member>
      <member refid="group__async__file__io__dispatcher__base____filter_1ga9e25e1fbc055efe53bd63f6d700866f7" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>post_op_filter</name></member>
      <member refid="group__async__file__io__dispatcher__base____filter_1gacc15e280c64ab2f734b097069ed86240" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>post_op_filter_clear</name></member>
      <member refid="group__async__file__io__dispatcher__base____filter_1ga820758ad7b27f3fa3ca9fa4445db50ee" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>post_readwrite_filter</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga389a54f126d95872fa3981bbb0f4ca49" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>read</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga2f99a4c769b6d769e829cee1679763c1" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>read</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga41e799782c22f41b16d408a977460153" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>rmdir</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gadb64fc6cabd8e1f394b112cf2361a20a" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>rmdir</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga1e2c1e20ed7a8d04c3dc63490f8e2580" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>rmfile</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gaa222f0e9e966ddddf823166105589316" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>rmfile</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga5f83cde9b9428423ab6cfbefbe0865b9" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>rmsymlink</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga3d4a61ff8c31bade2d3a5f3aa7e1cb60" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>rmsymlink</name></member>
      <member refid="group__async__file__io__dispatcher__base____statfs_1gacbeafa55623e83a890db62e190fc6c04" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>statfs</name></member>
      <member refid="group__async__file__io__dispatcher__base____statfs_1gacde9af80f4041fee04f759ad70e615d1" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>statfs</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga831d3e585fab96f70b71b1b1a41bd858" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>symlink</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gac56fe0c4aa9d3ead576ff210b3bb3b92" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>symlink</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gab2bbf924a104039e4fb5b9a31f14e81e" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>sync</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga7cb40ff0cb3eee7096f0a126bc509db8" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>sync</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1ae49a5daedd876d48fc131bca5f0d2b93" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>threadsource</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gae3f243608a9f97af2461ead5bb8189af" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>truncate</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gaa6d63c51183b6f637a723b00155e1cac" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>truncate</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a360e6404ee3f0949209836b8184ee007" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>wait_queue_depth</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1ga2489d452720accc47d1bfeb5525cfd5b" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>write</name></member>
      <member refid="group__async__file__io__dispatcher__base____filedirops_1gaccfb68e7fb84c36f418215e4d792988f" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>write</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1a735e7a659db8e76f0bfb77123c38f23b" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>write</name></member>
      <member refid="group__async__file__io__dispatcher__base____extents_1ga48ad1fa0d998d6764b8ee28efaa3a62f" prot="public" virt="pure-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>zero</name></member>
      <member refid="group__async__file__io__dispatcher__base____extents_1ga4addd95d8cb11a94efc4712147b128fa" prot="public" virt="non-virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>zero</name></member>
      <member refid="classboost_1_1afio_1_1async__file__io__dispatcher__base_1afdaf5abc2bc92330dc7c85295dfbcaed" prot="public" virt="virtual"><scope>boost::afio::async_file_io_dispatcher_base</scope><name>~async_file_io_dispatcher_base</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
