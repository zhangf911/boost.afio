<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="group__async__file__io__dispatcher__base____call" kind="group">
    <compoundname>async_file_io_dispatcher_base__call</compoundname>
    <title>x</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____call_1gaa144378bedc4272b44c9b8f358a04fb7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; shared_future&lt; R &gt; &gt;, std::vector&lt; async_io_op &gt; &gt;</type>
        <definition>std::pair&lt; std::vector&lt; shared_future&lt; R &gt; &gt;, std::vector&lt; async_io_op &gt; &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;callables)</argsstring>
        <name>call</name>
        <param>
          <type>const std::vector&lt; async_io_op &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;</type>
          <declname>callables</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit.</para><para><simplesect kind="return"><para>A pair with a batch of futures returning the result of each of the callables and a batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class R</parametername>
</parameternamelist>
<parameterdescription>
<para>A compiler deduced return type of the bound functions. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of precondition op handles. If default constructed, a precondition is null. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callables</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of bound functions to call, returning R.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch bound functions</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp" line="1188" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp" bodystart="2774" bodyend="2789"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____call_1ga9ccdb35979566b5852e1817388f6a39b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class R</type>
          </param>
        </templateparamlist>
        <type>std::pair&lt; std::vector&lt; shared_future&lt; R &gt; &gt;, std::vector&lt; async_io_op &gt; &gt;</type>
        <definition>std::pair&lt;std::vector&lt;shared_future&lt;R&gt; &gt;, std::vector&lt;async_io_op&gt; &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;callables)</argsstring>
        <name>call</name>
        <param>
          <type>const std::vector&lt; std::function&lt; R()&gt;&gt; &amp;</type>
          <declname>callables</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit. If you are seeing performance issues, using `completion()` directly will have much less overhead.</para><para><simplesect kind="return"><para>A pair with a batch of futures returning the result of each of the callables and a batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class R</parametername>
</parameternamelist>
<parameterdescription>
<para>A compiler deduced return type of the bound functions. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callables</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of bound functions to call, returning R.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch bound functions without preconditions</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp" line="1204" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp" bodystart="1204" bodyend="1204"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____call_1gaf3bde0b207a33ac44e61a09ca93be50f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class C</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>std::pair&lt; shared_future&lt; typename std::result_of&lt; C(Args...)&gt;::type &gt;, async_io_op &gt;</type>
        <definition>std::pair&lt; shared_future&lt; typename std::result_of&lt; C(Args...)&gt;::type &gt;, async_io_op &gt; boost::afio::async_file_io_dispatcher_base::call</definition>
        <argsstring>(const async_io_op &amp;req, C callback, Args...args)</argsstring>
        <name>call</name>
        <param>
          <type>const async_io_op &amp;</type>
          <declname>req</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callback</declname>
        </param>
        <param>
          <type>Args...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous invocation of the specified unbound callable when its supplied precondition completes. Note that this function essentially calls `std::bind()` on the callable and the args and passes it to the other <ref refid="group__async__file__io__dispatcher__base____call_1gaa144378bedc4272b44c9b8f358a04fb7" kindref="member">call()</ref> overload taking a `std::function&lt;&gt;`. You should therefore use `std::ref()` etc. as appropriate. </para>        </briefdescription>
        <detaileddescription>
<para>This is effectively a convenience wrapper for `completion()`. It creates an <ref refid="classenqueued__task" kindref="compound">enqueued_task</ref> matching the `completion_t` handler specification and calls the specified arbitrary callable, always returning completion on exit. If you are seeing performance issues, using `completion()` directly will have much less overhead.</para><para><simplesect kind="return"><para>A pair with a future returning the result of the callable and an op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class C</parametername>
</parameternamelist>
<parameterdescription>
<para>Any callable type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Any sequence of argument types. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>A precondition op handle. If default constructed, the precondition is null. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>An unbound callable to call. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>An arbitrary sequence of arguments to bind to the callable.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single unbound callable</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][call_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp" line="1251" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/include/boost/afio/afio.hpp" bodystart="2806" bodyend="2811"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
