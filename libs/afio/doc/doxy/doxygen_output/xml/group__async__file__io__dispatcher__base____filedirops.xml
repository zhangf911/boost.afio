<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="group__async__file__io__dispatcher__base____filedirops" kind="group">
    <compoundname>async_file_io_dispatcher_base__filedirops</compoundname>
    <title>x</title>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga284b1612b2c0a3ea813660bc9fd6a54b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::adopt</definition>
        <argsstring>(const std::vector&lt; std::shared_ptr&lt; async_io_handle &gt;&gt; &amp;hs)</argsstring>
        <name>adopt</name>
        <param>
          <type>const std::vector&lt; std::shared_ptr&lt; async_io_handle &gt;&gt; &amp;</type>
          <declname>hs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of third party handle adoptions. </para>        </briefdescription>
        <detaileddescription>
<para>This function enables you to adopt third party custom <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> derivatives as ops into the scheduler. Think of it as if you were calling <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" kindref="member">file()</ref>, except the op returns the supplied handle and otherwise does nothing.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>hs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of handles to adopt.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][adopt_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1283"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaa3f199f010ded1399b4f903a194b9cd3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::adopt</definition>
        <argsstring>(std::shared_ptr&lt; async_io_handle &gt; h)</argsstring>
        <name>adopt</name>
        <param>
          <type>std::shared_ptr&lt; async_io_handle &gt;</type>
          <declname>h</declname>
        </param>
        <briefdescription>
<para>Schedule an adoption of a third party handle. </para>        </briefdescription>
        <detaileddescription>
<para>This function enables you to adopt third party custom <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref> derivatives as ops into the scheduler. Think of it as if you were calling <ref refid="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" kindref="member">file()</ref>, except the op returns the supplied handle and otherwise does nothing.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>h</parametername>
</parameternamelist>
<parameterdescription>
<para>A handle to adopt.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][adopt_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1298" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2863" bodyend="2869"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaf6386ba1f9bd0e829470837bef6c7d73" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::dir</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>dir</name>
        <param>
          <type>const std::vector&lt; async_path_op_req &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous directory creations and opens after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file_flags::UniqueDirectoryHandle is specified.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if directory creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1312"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gacceb89d11308e3137186aaccec282a17" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::dir</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>dir</name>
        <param>
          <type>const async_path_op_req &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous directory creation and open after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if there is already a handle open to the directory requested, that will be returned instead of a new handle unless file_flags::UniqueDirectoryHandle is specified.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1326" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2870" bodyend="2876"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga41e799782c22f41b16d408a977460153" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::rmdir</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>rmdir</name>
        <param>
          <type>const std::vector&lt; async_path_op_req &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous directory deletions after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if directory deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1337"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gadb64fc6cabd8e1f394b112cf2361a20a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::rmdir</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>rmdir</name>
        <param>
          <type>const async_path_op_req &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous directory deletion after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if directory deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1348" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2877" bodyend="2883"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga5da57c9cb811cea214a1e36f007ecffb" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::file</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>file</name>
        <param>
          <type>const std::vector&lt; async_path_op_req &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file creations and opens after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para>Be aware that any files created are by default sparse if supported on the local filing system. Use file_flags::NoSparse to prevent this on those filing systems which permit it.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1362"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga59910bc569f75eac27c406c47ccd0643" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::file</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>file</name>
        <param>
          <type>const async_path_op_req &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file creation and open after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Be aware that any files created are by default sparse if supported on the local filing system. Use file_flags::NoSparse to prevent this on those filing systems which permit it.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1376" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2884" bodyend="2890"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga1e2c1e20ed7a8d04c3dc63490f8e2580" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::rmfile</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>rmfile</name>
        <param>
          <type>const std::vector&lt; async_path_op_req &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file deletions after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if file deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1387"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaa222f0e9e966ddddf823166105589316" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::rmfile</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>rmfile</name>
        <param>
          <type>const async_path_op_req &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file deletion after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if file deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1398" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2891" bodyend="2897"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga831d3e585fab96f70b71b1b1a41bd858" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::symlink</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>symlink</name>
        <param>
          <type>const std::vector&lt; async_path_op_req &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous symlink creations and opens after a precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the <computeroutput>SeCreateSymbolicLinkPrivilege</computeroutput> for non-Administrative users.</para><para>Note that currently on Windows non-directory symbolic links are not supported. If there is demand for this we may add support.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1415"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gac56fe0c4aa9d3ead576ff210b3bb3b92" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::symlink</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>symlink</name>
        <param>
          <type>const async_path_op_req &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous symlink creation and open after a precondition. </para>        </briefdescription>
        <detaileddescription>
<para>Note that if creating, the target for the symlink is the precondition. On Windows directories are symlinked using a reparse point instead of a symlink due to the default lack of the <computeroutput>SeCreateSymbolicLinkPrivilege</computeroutput> for non-Administrative users.</para><para>Note that currently on Windows non-directory symbolic links are not supported. If there is demand for this we may add support.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink creation is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1432" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2898" bodyend="2904"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga5f83cde9b9428423ab6cfbefbe0865b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::rmsymlink</definition>
        <argsstring>(const std::vector&lt; async_path_op_req &gt; &amp;reqs)=0</argsstring>
        <name>rmsymlink</name>
        <param>
          <type>const std::vector&lt; async_path_op_req &gt; &amp;</type>
          <declname>reqs</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous symlink deletions after optional preconditions. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reqs</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of `async_path_op_req` structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if symlink deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1443"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga3d4a61ff8c31bade2d3a5f3aa7e1cb60" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::rmsymlink</definition>
        <argsstring>(const async_path_op_req &amp;req)</argsstring>
        <name>rmsymlink</name>
        <param>
          <type>const async_path_op_req &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous symlink deletion after an optional precondition. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An `async_path_op_req` structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if symlink deletion is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1454" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2905" bodyend="2911"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gab2bbf924a104039e4fb5b9a31f14e81e" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::sync</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops)=0</argsstring>
        <name>sync</name>
        <param>
          <type>const std::vector&lt; async_io_op &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if content synchronisation is constant time (which is extremely unlikely).</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1465"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga7cb40ff0cb3eee7096f0a126bc509db8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::sync</definition>
        <argsstring>(const async_io_op &amp;req)</argsstring>
        <name>sync</name>
        <param>
          <type>const async_io_op &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous content synchronisation with physical storage after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if content synchronisation is constant time (which is extremely unlikely).</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1476" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2912" bodyend="2918"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga56db87e1d05cf4c17c7587216b2413c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::close</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops)=0</argsstring>
        <name>close</name>
        <param>
          <type>const std::vector&lt; async_io_op &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file or directory handle closes after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para>Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref>. This can consume considerable time, especially if SyncOnClose is enabled.</para><para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if closing handles is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1534"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga269273113b9ec5eea764791852cbd53a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::close</definition>
        <argsstring>(const async_io_op &amp;req)</argsstring>
        <name>close</name>
        <param>
          <type>const async_io_op &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file or directory handle close after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para>Note that failure to explicitly schedule closing a file handle using this call means it will be [*synchronously] closed on last reference count by <ref refid="classboost_1_1afio_1_1async__io__handle" kindref="compound">async_io_handle</ref>. This can consume considerable time, especially if SyncOnClose is enabled.</para><para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if closing handles is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][filedir_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1548" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2929" bodyend="2935"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga389a54f126d95872fa3981bbb0f4ca49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="pure-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>std::vector&lt; async_io_op &gt; boost::afio::async_file_io_dispatcher_base::read</definition>
        <argsstring>(const std::vector&lt; async_data_op_req&lt; T &gt;&gt; &amp;ops)=0</argsstring>
        <name>read</name>
        <param>
          <type>const std::vector&lt; async_data_op_req&lt; T &gt;&gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of async_data_op_req&lt;T&gt; structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if reading data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1567" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2952" bodyend="2955"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga2f99a4c769b6d769e829cee1679763c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::read</definition>
        <argsstring>(const async_data_op_req&lt; T &gt; &amp;req)</argsstring>
        <name>read</name>
        <param>
          <type>const async_data_op_req&lt; T &gt; &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An async_data_op_req&lt;T&gt; structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if reading data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1585"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1ga2489d452720accc47d1bfeb5525cfd5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::write</definition>
        <argsstring>(const std::vector&lt; async_data_op_req&lt; const T &gt;&gt; &amp;ops)=0</argsstring>
        <name>write</name>
        <param>
          <type>const std::vector&lt; async_data_op_req&lt; const T &gt;&gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of <ref refid="structboost_1_1afio_1_1async__data__op__req_3_01const_01_t_01_4" kindref="compound">async_data_op_req&lt;const T&gt;</ref> structures.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if writing data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1604"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaccfb68e7fb84c36f418215e4d792988f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::write</definition>
        <argsstring>(const async_data_op_req&lt; const T &gt; &amp;req)</argsstring>
        <name>write</name>
        <param>
          <type>const async_data_op_req&lt; const T &gt; &amp;</type>
          <declname>req</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. </para>        </briefdescription>
        <detaileddescription>
<para>Note that on Windows this call issues a separate async file operation for each buffer supplied, thus making scatter/gather i/o no more efficient than making separate calls. The big exception to this is when doing unbuffered page aligned i/o for which Windows provides special scatter/gather i/o functions. <simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>class T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>req</parametername>
</parameternamelist>
<parameterdescription>
<para>An <ref refid="structboost_1_1afio_1_1async__data__op__req_3_01const_01_t_01_4" kindref="compound">async_data_op_req&lt;const T&gt;</ref> structure.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if writing data is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1622"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gae3f243608a9f97af2461ead5bb8189af" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::vector&lt; async_io_op &gt;</type>
        <definition>virtual std::vector&lt;async_io_op&gt; boost::afio::async_file_io_dispatcher_base::truncate</definition>
        <argsstring>(const std::vector&lt; async_io_op &gt; &amp;ops, const std::vector&lt; off_t &gt; &amp;sizes)=0</argsstring>
        <name>truncate</name>
        <param>
          <type>const std::vector&lt; async_io_op &gt; &amp;</type>
          <declname>ops</declname>
        </param>
        <param>
          <type>const std::vector&lt; off_t &gt; &amp;</type>
          <declname>sizes</declname>
        </param>
        <briefdescription>
<para>Schedule a batch of asynchronous file length truncations after preceding operations. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A batch of op handles. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of op handles. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sizes</parametername>
</parameternamelist>
<parameterdescription>
<para>A batch of new lengths.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> batch</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(N) to dispatch. Amortised O(N/threadpool) to complete if truncating file lengths is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1636"/>
      </memberdef>
      <memberdef kind="function" id="group__async__file__io__dispatcher__base____filedirops_1gaa6d63c51183b6f637a723b00155e1cac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>async_io_op</type>
        <definition>async_io_op boost::afio::async_file_io_dispatcher_base::truncate</definition>
        <argsstring>(const async_io_op &amp;op, off_t newsize)</argsstring>
        <name>truncate</name>
        <param>
          <type>const async_io_op &amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>off_t</type>
          <declname>newsize</declname>
        </param>
        <briefdescription>
<para>Schedule an asynchronous file length truncation after a preceding operation. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>An op handle. </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>An op handle. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>newsize</parametername>
</parameternamelist>
<parameterdescription>
<para>The new size for the file.</para></parameterdescription>
</parameteritem>
</parameterlist>
 <qbk.distinguish> single</qbk.distinguish>   <qbk>[heading Complexity]Amortised O(1) to dispatch. Amortised O(1) to complete if truncating file lengths is constant time.</qbk>   <qbk>[heading Exception Model]Propagates exceptions of any input preconditions with an errored state at the point of dispatch, and throws a `std::invalid_argument` if any inputs have values which could not possibly be correct. Once a batch of input ops has been verified at the point of entry as not errored, you are guaranteed that the batch is atomically scheduled as a whole, unless a failure to allocate memory occurs.</qbk>   <qbk>[heading Example][readwrite_example]</qbk>  </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" line="1648" bodyfile="/home/jenkins-slave/workspace/Boost.AFIO Build Documentation/boost-local/libs/afio/include/boost/afio/afio.hpp" bodystart="2960" bodyend="2969"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
