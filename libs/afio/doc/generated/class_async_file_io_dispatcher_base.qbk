[/============================================================================
  Boost.AFIO

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from doxy/doxygen_output/xml/classboost_1_1afio_1_1async__file__io__dispatcher__base.xml]
[section:async_file_io_dispatcher_base async_file_io_dispatcher_base]

'''<indexterm><primary>async_file_io_dispatcher_base</primary></indexterm>'''
Abstract base class for dispatching file i/o asynchronously. 

[heading Description]
This is a reference counted instance with platform-specific implementation optionally hidden in object code. Construct an instance using the [^`boost::afio::make_async_file_io_dispatcher()`] function.

[heading Synopsis]
``class async_file_io_dispatcher_base
      : public std::enable_shared_from_this< async_file_io_dispatcher_base >
{
  // ...
};
``

[heading Constructor(s)]
[table
[[Function] [Description] [Parameters] ]
[[``~async_file_io_dispatcher_base()``

] [Destroys the dispatcher, blocking inefficiently if any ops are still in flight. ] [


]]
]

[heading Member Function(s)]
[table
[[Function] [Description] [Parameters]  [Returns]]
[[``std::shared_ptr< thread_source > threadsource()``

] [Returns the thread source used by this dispatcher. ] [


]]
[[``file_flags fileflags(file_flags flags)``

] [Returns file flags as would be used after forcing and masking bits passed during construction. ] [[* file_flags]: ['flags]:  




]]
[[``size_t wait_queue_depth()``

] [Returns the current wait queue depth of this dispatcher. ] [


]]
[[``size_t fd_count()``

] [Returns the number of open items in this dispatcher. ] [


]]
[[``async_io_op op_from_scheduled_id(size_t id)``

] [Returns an op ref for a given [*currently] scheduled op id, throwing an exception if id not scheduled at the point of call. Can be used to retrieve exception state from some op id, or one's own shared future. ] [[* size_t]: ['id]:  The unique integer id for the op. 



][
An async_io_op with the same shared future as all op refs with this id. 


]]
[[``void post_op_filter_clear()``

] [Clears the post op and readwrite filters. Not threadsafe. ] [


]]
[[``void post_op_filter(std::vector< std::pair< detail::OpType, std::function< async_file_io_dispatcher_base::filter_t >>> filters)``

] [Install op filters for non-buffer taking ops. Not threadsafe. ] [[* std::vector< std::pair< detail::OpType, std::function< async_file_io_dispatcher_base::filter_t >>>]: ['filters]:  A batch of pairs of op type to be filtered and bound filter handler functions of type [^`filter_t`]




]]
[[``void post_readwrite_filter(std::vector< std::pair< detail::OpType, std::function< async_file_io_dispatcher_base::filter_readwrite_t >>> filters)``

] [Install read/write op filters, useful for tight ASIO integration. Not threadsafe. ] [[* std::vector< std::pair< detail::OpType, std::function< async_file_io_dispatcher_base::filter_readwrite_t >>>]: ['filters]:  A batch of pairs of op type to be filtered and bound filter handler functions of type [^`filter_buffers_t`]




]]
[[``std::vector< async_io_op > completion(const std::vector< async_io_op > & ops, const std::vector< std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >>> & callbacks)``

] [Schedule a batch of asynchronous invocations of the specified functions when their supplied operations complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of precondition op handles. 

[* const std::vector< std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >>> &]: ['callbacks]:  A batch of pairs of op flags and bound completion handler functions of type [^`completion_t`]



][
A batch of op handles 


]]
[[``async_io_op completion(const async_io_op & req, const std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >> & callback)``

] [Schedule the asynchronous invocation of the specified single function when the supplied single operation completes. ] [[* const async_io_op &]: ['req]:  A precondition op handle 

[* const std::pair< async_op_flags, std::function< async_file_io_dispatcher_base::completion_t >> &]: ['callback]:  A pair of op flag and bound completion handler function of type [^`completion_t`]



][
An op handle 


]]
[[``template<class R>
std::pair< std::vector< shared_future< R > >, std::vector< async_io_op > > call(const std::vector< async_io_op > & ops, const std::vector< std::function< R()>> & callables)``

] [Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of precondition op handles. If default constructed, a precondition is null. 

[* const std::vector< std::function< R()>> &]: ['callables]:  A batch of bound functions to call, returning R.



][
A pair with a batch of futures returning the result of each of the callables and a batch of op handles. 


]]
[[``template<class R>
std::pair< std::vector< shared_future< R > >, std::vector< async_io_op > > call(const std::vector< std::function< R()>> & callables)``

] [Schedule a batch of asynchronous invocations of the specified bound functions when their supplied preconditions complete. ] [[* const std::vector< std::function< R()>> &]: ['callables]:  A batch of bound functions to call, returning R.



][
A pair with a batch of futures returning the result of each of the callables and a batch of op handles. 


]]
[[``template<class R>
std::pair< shared_future< R >, async_io_op > call(const async_io_op & req, std::function< R()> callback)``

] [Schedule an asynchronous invocation of the specified bound function when its supplied precondition completes. ] [[* const async_io_op &]: ['req]:  A precondition op handle. If default constructed, the precondition is null. 

[* std::function< R()>]: ['callback]:  A bound functions to call, returning R.



][
A pair with a future returning the result of the callable and an op handle. 


]]
[[``template<class C, class... Args>
std::pair< shared_future< typename std::result_of< C(Args...)>::type >, async_io_op > call(const async_io_op & req, C callback, Args... args)``

] [Schedule an asynchronous invocation of the specified unbound callable when its supplied precondition completes. Note that this function essentially calls [^`std::bind()`] on the callable and the args and passes it to the other call() overload taking a [^`std::function<>`]. You should therefore use [^`std::ref()`] etc. as appropriate. ] [[* const async_io_op &]: ['req]:  A precondition op handle. If default constructed, the precondition is null. 

[* C]: ['callback]:  An unbound callable to call. 

[* Args...]: ['args]:  An arbitrary sequence of arguments to bind to the callable.



][
A pair with a future returning the result of the callable and an op handle. 


]]
[[``std::vector< async_io_op > adopt(const std::vector< std::shared_ptr< async_io_handle >> & hs)``

] [Schedule a batch of third party handle adoptions. ] [[* const std::vector< std::shared_ptr< async_io_handle >> &]: ['hs]:  A batch of handles to adopt.



][
A batch of op handles. 


]]
[[``async_io_op adopt(std::shared_ptr< async_io_handle > h)``

] [Schedule an adoption of a third party handle. ] [[* std::shared_ptr< async_io_handle >]: ['h]:  A handle to adopt.



][
An op handle. 


]]
[[``std::vector< async_io_op > dir(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous directory creations and opens after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op dir(const async_path_op_req & req)``

] [Schedule an asynchronous directory creation and open after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > rmdir(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous directory deletions after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op rmdir(const async_path_op_req & req)``

] [Schedule an asynchronous directory deletion after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > file(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous file creations and opens after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op file(const async_path_op_req & req)``

] [Schedule an asynchronous file creation and open after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > rmfile(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous file deletions after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op rmfile(const async_path_op_req & req)``

] [Schedule an asynchronous file deletion after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > symlink(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous symlink creations and opens after a precondition. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op symlink(const async_path_op_req & req)``

] [Schedule an asynchronous symlink creation and open after a precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > rmsymlink(const std::vector< async_path_op_req > & reqs)``

] [Schedule a batch of asynchronous symlink deletions after optional preconditions. ] [[* const std::vector< async_path_op_req > &]: ['reqs]:  A batch of [^`async_path_op_req`] structures.



][
A batch of op handles. 


]]
[[``async_io_op rmsymlink(const async_path_op_req & req)``

] [Schedule an asynchronous symlink deletion after an optional precondition. ] [[* const async_path_op_req &]: ['req]:  An [^`async_path_op_req`] structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > sync(const std::vector< async_io_op > & ops)``

] [Schedule a batch of asynchronous content synchronisations with physical storage after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 


]]
[[``async_io_op sync(const async_io_op & req)``

] [Schedule an asynchronous content synchronisation with physical storage after a preceding operation. ] [[* const async_io_op &]: ['req]:  An op handle.



][
An op handle. 


]]
[[``std::vector< async_io_op > zero(const std::vector< async_io_op > & ops, const std::vector< std::vector< std::pair< off_t, off_t >>> & ranges)``

] [Schedule a batch of asynchronous zeroing and deallocations of physical storage ("hole punching") after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles. 

[* const std::vector< std::vector< std::pair< off_t, off_t >>> &]: ['ranges]:  A batch of vectors of extents to zero and deallocate.



][
A batch of op handles. 


]]
[[``async_io_op zero(const async_io_op & req, const std::vector< std::pair< off_t, off_t >> & ranges)``

] [Schedule an asynchronous zero and deallocation of physical storage ("hole punching") after a preceding operation. ] [[* const async_io_op &]: ['req]:  An op handle. 

[* const std::vector< std::pair< off_t, off_t >> &]: ['ranges]:  A vector of extents to zero and deallocate.



][
An op handle. 


]]
[[``std::vector< async_io_op > close(const std::vector< async_io_op > & ops)``

] [Schedule a batch of asynchronous file or directory handle closes after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 


]]
[[``async_io_op close(const async_io_op & req)``

] [Schedule an asynchronous file or directory handle close after a preceding operation. ] [[* const async_io_op &]: ['req]:  An op handle.



][
An op handle. 


]]
[[``template<class T>
std::vector< async_io_op > read(const std::vector< async_data_op_req< T >> & ops)``

] [Schedule a batch of asynchronous data reads after preceding operations, where offset and total data read must not exceed the present file size. ] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  A batch of async_data_op_req<T> structures.



][
A batch of op handles. 


]]
[[``template<class T>
async_io_op read(const async_data_op_req< T > & req)``

] [Schedule an asynchronous data read after a preceding operation, where offset and total data read must not exceed the present file size. ] [[* const async_data_op_req< T > &]: ['req]:  An async_data_op_req<T> structure.



][
An op handle. 


]]
[[``template<class T>
std::vector< async_io_op > write(const std::vector< async_data_op_req< const T >> & ops)``

] [Schedule a batch of asynchronous data writes after preceding operations, where offset and total data written must not exceed the present file size. ] [[* const std::vector< async_data_op_req< const T >> &]: ['ops]:  A batch of async_data_op_req<const T> structures.



][
A batch of op handles. 


]]
[[``template<class T>
async_io_op write(const async_data_op_req< const T > & req)``

] [Schedule an asynchronous data write after a preceding operation, where offset and total data written must not exceed the present file size. ] [[* const async_data_op_req< const T > &]: ['req]:  An async_data_op_req<const T> structure.



][
An op handle. 


]]
[[``std::vector< async_io_op > truncate(const std::vector< async_io_op > & ops, const std::vector< off_t > & sizes)``

] [Schedule a batch of asynchronous file length truncations after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles. 

[* const std::vector< off_t > &]: ['sizes]:  A batch of new lengths.



][
A batch of op handles. 


]]
[[``async_io_op truncate(const async_io_op & op, off_t newsize)``

] [Schedule an asynchronous file length truncation after a preceding operation. ] [[* const async_io_op &]: ['op]:  An op handle. 

[* off_t]: ['newsize]:  The new size for the file.



][
An op handle. 


]]
[[``std::pair< std::vector< future< std::pair< std::vector< directory_entry >, bool > > >, std::vector< async_io_op > > enumerate(const std::vector< async_enumerate_op_req > & reqs)``

] [Schedule a batch of asynchronous directory enumerations after preceding operations. ] [[* const std::vector< async_enumerate_op_req > &]: ['reqs]:  A batch of enumeration requests.



][
A batch of future vectors of directory entries with boolean returning false if done. 


]]
[[``std::pair< future< std::pair< std::vector< directory_entry >, bool > >, async_io_op > enumerate(const async_enumerate_op_req & req)``

] [Schedule an asynchronous directory enumeration after a preceding operation. ] [[* const async_enumerate_op_req &]: ['req]:  An enumeration request.



][
A future vector of directory entries with a boolean returning false if done. 


]]
[[``std::pair< std::vector< future< std::vector< std::pair< off_t, off_t > > > >, std::vector< async_io_op > > extents(const std::vector< async_io_op > & ops)``

] [Schedule a batch of asynchronous extent enumerations after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of future vectors of extents. 


]]
[[``std::pair< future< std::vector< std::pair< off_t, off_t > > >, async_io_op > extents(const async_io_op & op)``

] [Schedule an asynchronous extent enumeration after a preceding operation. ] [[* const async_io_op &]: ['op]:  An op handle.



][
A future vector of extents. 


]]
[[``std::pair< std::vector< future< statfs_t > >, std::vector< async_io_op > > statfs(const std::vector< async_io_op > & ops, const std::vector< fs_metadata_flags > & reqs)``

] [Schedule a batch of asynchronous volume enumerations after preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles. 

[* const std::vector< fs_metadata_flags > &]: ['reqs]:  A batch of metadata requests.



][
A batch of future volume metadatas. 


]]
[[``std::pair< future< statfs_t >, async_io_op > statfs(const async_io_op & op, const fs_metadata_flags & req)``

] [Schedule an asynchronous volume enumeration after a preceding operation. ] [[* const async_io_op &]: ['op]:  An op handle. 

[* const fs_metadata_flags &]: ['req]:  A metadata request.



][
A future volume metadatas. 


]]
[[``std::vector< async_io_op > barrier(const std::vector< async_io_op > & ops)``

] [Schedule an asynchronous synchronisation of preceding operations. ] [[* const std::vector< async_io_op > &]: ['ops]:  A batch of op handles.



][
A batch of op handles. 


]]
[[``size_t page_size()``

] [Returns the page size of this architecture which is useful for calculating direct i/o multiples. ] [

][
The page size of this architecture.


]]
[[``void complete_async_op(size_t id, std::shared_ptr< async_io_handle > h, exception_ptr e = exception_ptr())``

] [Completes an operation with a handle or an error, usually used when an operation was previously deferred. ] [[* size_t]: ['id]:  

[* std::shared_ptr< async_io_handle >]: ['h]:  

[* exception_ptr]: ['e]:  




]]
[[``void complete_async_op(size_t id, exception_ptr e)``

] [Completes an operation with an error, usually used when an operation was previously deferred. ] [[* size_t]: ['id]:  

[* exception_ptr]: ['e]:  




]]
[[``template<class T>
std::vector< async_io_op > read(const std::vector< async_data_op_req< T >> & ops)``

] [] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  




]]
[[``template<class T>
std::vector< async_io_op > write(const std::vector< async_data_op_req< T >> & ops)``

] [] [[* const std::vector< async_data_op_req< T >> &]: ['ops]:  




]]
]

[heading Header]
`#include <boost/afio/afio.hpp>`

[/ link afio.reference.functions.async_file_io_dispatcher `async_file_io_dispatcher()`]
[include generated/group_async_file_io_dispatcher_base__filter.qbk]
[include generated/group_async_file_io_dispatcher_base__completion.qbk]
[include generated/group_async_file_io_dispatcher_base__call.qbk]
[include generated/group_async_file_io_dispatcher_base__filedirops.qbk]
[include generated/group_async_file_io_dispatcher_base__barrier.qbk]
[include generated/group_async_file_io_dispatcher_base__enumerate.qbk]
[include generated/group_async_file_io_dispatcher_base__extents.qbk]
[include generated/group_async_file_io_dispatcher_base__statfs.qbk]
[include generated/group_async_file_io_dispatcher_base__misc.qbk]

[endsect]

